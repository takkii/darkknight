"use strict";
(() => {
  // app.js
  (() => {
    (() => {
      (() => {
        (() => {
          (() => {
            (() => {
              (() => {
                (() => {
                  (() => {
                    (() => {
                      (() => {
                        (() => {
                          (() => {
                            (() => {
                              (() => {
                                (() => {
                                  (() => {
                                    (() => {
                                      (() => {
                                        (() => {
                                          (() => {
                                            (() => {
                                              (() => {
                                                (() => {
                                                  (() => {
                                                    (function() {
                                                      var PolyfillEvent = eventConstructor();
                                                      function eventConstructor() {
                                                        if (typeof window.CustomEvent === "function") return window.CustomEvent;
                                                        function CustomEvent2(event, params) {
                                                          params = params || { bubbles: false, cancelable: false, detail: void 0 };
                                                          var evt = document.createEvent("CustomEvent");
                                                          evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
                                                          return evt;
                                                        }
                                                        CustomEvent2.prototype = window.Event.prototype;
                                                        return CustomEvent2;
                                                      }
                                                      function buildHiddenInput(name, value) {
                                                        var input = document.createElement("input");
                                                        input.type = "hidden";
                                                        input.name = name;
                                                        input.value = value;
                                                        return input;
                                                      }
                                                      function handleClick(element, targetModifierKey) {
                                                        var to = element.getAttribute("data-to"), method = buildHiddenInput("_method", element.getAttribute("data-method")), csrf = buildHiddenInput("_csrf_token", element.getAttribute("data-csrf")), form = document.createElement("form"), submit = document.createElement("input"), target = element.getAttribute("target");
                                                        form.method = element.getAttribute("data-method") === "get" ? "get" : "post";
                                                        form.action = to;
                                                        form.style.display = "none";
                                                        if (target) form.target = target;
                                                        else if (targetModifierKey) form.target = "_blank";
                                                        form.appendChild(csrf);
                                                        form.appendChild(method);
                                                        document.body.appendChild(form);
                                                        submit.type = "submit";
                                                        form.appendChild(submit);
                                                        submit.click();
                                                      }
                                                      window.addEventListener("click", function(e) {
                                                        var element = e.target;
                                                        if (e.defaultPrevented) return;
                                                        while (element && element.getAttribute) {
                                                          var phoenixLinkEvent = new PolyfillEvent("phoenix.link.click", {
                                                            "bubbles": true,
                                                            "cancelable": true
                                                          });
                                                          if (!element.dispatchEvent(phoenixLinkEvent)) {
                                                            e.preventDefault();
                                                            e.stopImmediatePropagation();
                                                            return false;
                                                          }
                                                          if (element.getAttribute("data-method") && element.getAttribute("data-to")) {
                                                            handleClick(element, e.metaKey || e.shiftKey);
                                                            e.preventDefault();
                                                            return false;
                                                          } else {
                                                            element = element.parentNode;
                                                          }
                                                        }
                                                      }, false);
                                                      window.addEventListener("phoenix.link.click", function(e) {
                                                        var message = e.target.getAttribute("data-confirm");
                                                        if (message && !window.confirm(message)) {
                                                          e.preventDefault();
                                                        }
                                                      }, false);
                                                    })();
                                                    var closure = (value) => {
                                                      if (typeof value === "function") {
                                                        return value;
                                                      } else {
                                                        let closure22 = function() {
                                                          return value;
                                                        };
                                                        return closure22;
                                                      }
                                                    };
                                                    var globalSelf = typeof self !== "undefined" ? self : null;
                                                    var phxWindow = typeof window !== "undefined" ? window : null;
                                                    var global = globalSelf || phxWindow || globalThis;
                                                    var DEFAULT_VSN = "2.0.0";
                                                    var SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };
                                                    var DEFAULT_TIMEOUT = 1e4;
                                                    var WS_CLOSE_NORMAL = 1e3;
                                                    var CHANNEL_STATES = {
                                                      closed: "closed",
                                                      errored: "errored",
                                                      joined: "joined",
                                                      joining: "joining",
                                                      leaving: "leaving"
                                                    };
                                                    var CHANNEL_EVENTS = {
                                                      close: "phx_close",
                                                      error: "phx_error",
                                                      join: "phx_join",
                                                      reply: "phx_reply",
                                                      leave: "phx_leave"
                                                    };
                                                    var TRANSPORTS = {
                                                      longpoll: "longpoll",
                                                      websocket: "websocket"
                                                    };
                                                    var XHR_STATES = {
                                                      complete: 4
                                                    };
                                                    var AUTH_TOKEN_PREFIX = "base64url.bearer.phx.";
                                                    var Push = class {
                                                      constructor(channel, event, payload, timeout) {
                                                        this.channel = channel;
                                                        this.event = event;
                                                        this.payload = payload || function() {
                                                          return {};
                                                        };
                                                        this.receivedResp = null;
                                                        this.timeout = timeout;
                                                        this.timeoutTimer = null;
                                                        this.recHooks = [];
                                                        this.sent = false;
                                                      }
                                                      /**
                                                       *
                                                       * @param {number} timeout
                                                       */
                                                      resend(timeout) {
                                                        this.timeout = timeout;
                                                        this.reset();
                                                        this.send();
                                                      }
                                                      /**
                                                       *
                                                       */
                                                      send() {
                                                        if (this.hasReceived("timeout")) {
                                                          return;
                                                        }
                                                        this.startTimeout();
                                                        this.sent = true;
                                                        this.channel.socket.push({
                                                          topic: this.channel.topic,
                                                          event: this.event,
                                                          payload: this.payload(),
                                                          ref: this.ref,
                                                          join_ref: this.channel.joinRef()
                                                        });
                                                      }
                                                      /**
                                                       *
                                                       * @param {*} status
                                                       * @param {*} callback
                                                       */
                                                      receive(status, callback) {
                                                        if (this.hasReceived(status)) {
                                                          callback(this.receivedResp.response);
                                                        }
                                                        this.recHooks.push({ status, callback });
                                                        return this;
                                                      }
                                                      /**
                                                       * @private
                                                       */
                                                      reset() {
                                                        this.cancelRefEvent();
                                                        this.ref = null;
                                                        this.refEvent = null;
                                                        this.receivedResp = null;
                                                        this.sent = false;
                                                      }
                                                      /**
                                                       * @private
                                                       */
                                                      matchReceive({ status, response, _ref }) {
                                                        this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));
                                                      }
                                                      /**
                                                       * @private
                                                       */
                                                      cancelRefEvent() {
                                                        if (!this.refEvent) {
                                                          return;
                                                        }
                                                        this.channel.off(this.refEvent);
                                                      }
                                                      /**
                                                       * @private
                                                       */
                                                      cancelTimeout() {
                                                        clearTimeout(this.timeoutTimer);
                                                        this.timeoutTimer = null;
                                                      }
                                                      /**
                                                       * @private
                                                       */
                                                      startTimeout() {
                                                        if (this.timeoutTimer) {
                                                          this.cancelTimeout();
                                                        }
                                                        this.ref = this.channel.socket.makeRef();
                                                        this.refEvent = this.channel.replyEventName(this.ref);
                                                        this.channel.on(this.refEvent, (payload) => {
                                                          this.cancelRefEvent();
                                                          this.cancelTimeout();
                                                          this.receivedResp = payload;
                                                          this.matchReceive(payload);
                                                        });
                                                        this.timeoutTimer = setTimeout(() => {
                                                          this.trigger("timeout", {});
                                                        }, this.timeout);
                                                      }
                                                      /**
                                                       * @private
                                                       */
                                                      hasReceived(status) {
                                                        return this.receivedResp && this.receivedResp.status === status;
                                                      }
                                                      /**
                                                       * @private
                                                       */
                                                      trigger(status, response) {
                                                        this.channel.trigger(this.refEvent, { status, response });
                                                      }
                                                    };
                                                    var Timer = class {
                                                      constructor(callback, timerCalc) {
                                                        this.callback = callback;
                                                        this.timerCalc = timerCalc;
                                                        this.timer = null;
                                                        this.tries = 0;
                                                      }
                                                      reset() {
                                                        this.tries = 0;
                                                        clearTimeout(this.timer);
                                                      }
                                                      /**
                                                       * Cancels any previous scheduleTimeout and schedules callback
                                                       */
                                                      scheduleTimeout() {
                                                        clearTimeout(this.timer);
                                                        this.timer = setTimeout(() => {
                                                          this.tries = this.tries + 1;
                                                          this.callback();
                                                        }, this.timerCalc(this.tries + 1));
                                                      }
                                                    };
                                                    var Channel = class {
                                                      constructor(topic, params, socket) {
                                                        this.state = CHANNEL_STATES.closed;
                                                        this.topic = topic;
                                                        this.params = closure(params || {});
                                                        this.socket = socket;
                                                        this.bindings = [];
                                                        this.bindingRef = 0;
                                                        this.timeout = this.socket.timeout;
                                                        this.joinedOnce = false;
                                                        this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);
                                                        this.pushBuffer = [];
                                                        this.stateChangeRefs = [];
                                                        this.rejoinTimer = new Timer(() => {
                                                          if (this.socket.isConnected()) {
                                                            this.rejoin();
                                                          }
                                                        }, this.socket.rejoinAfterMs);
                                                        this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()));
                                                        this.stateChangeRefs.push(
                                                          this.socket.onOpen(() => {
                                                            this.rejoinTimer.reset();
                                                            if (this.isErrored()) {
                                                              this.rejoin();
                                                            }
                                                          })
                                                        );
                                                        this.joinPush.receive("ok", () => {
                                                          this.state = CHANNEL_STATES.joined;
                                                          this.rejoinTimer.reset();
                                                          this.pushBuffer.forEach((pushEvent) => pushEvent.send());
                                                          this.pushBuffer = [];
                                                        });
                                                        this.joinPush.receive("error", () => {
                                                          this.state = CHANNEL_STATES.errored;
                                                          if (this.socket.isConnected()) {
                                                            this.rejoinTimer.scheduleTimeout();
                                                          }
                                                        });
                                                        this.onClose(() => {
                                                          this.rejoinTimer.reset();
                                                          if (this.socket.hasLogger()) this.socket.log("channel", `close ${this.topic} ${this.joinRef()}`);
                                                          this.state = CHANNEL_STATES.closed;
                                                          this.socket.remove(this);
                                                        });
                                                        this.onError((reason) => {
                                                          if (this.socket.hasLogger()) this.socket.log("channel", `error ${this.topic}`, reason);
                                                          if (this.isJoining()) {
                                                            this.joinPush.reset();
                                                          }
                                                          this.state = CHANNEL_STATES.errored;
                                                          if (this.socket.isConnected()) {
                                                            this.rejoinTimer.scheduleTimeout();
                                                          }
                                                        });
                                                        this.joinPush.receive("timeout", () => {
                                                          if (this.socket.hasLogger()) this.socket.log("channel", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout);
                                                          let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);
                                                          leavePush.send();
                                                          this.state = CHANNEL_STATES.errored;
                                                          this.joinPush.reset();
                                                          if (this.socket.isConnected()) {
                                                            this.rejoinTimer.scheduleTimeout();
                                                          }
                                                        });
                                                        this.on(CHANNEL_EVENTS.reply, (payload, ref) => {
                                                          this.trigger(this.replyEventName(ref), payload);
                                                        });
                                                      }
                                                      /**
                                                       * Join the channel
                                                       * @param {integer} timeout
                                                       * @returns {Push}
                                                       */
                                                      join(timeout = this.timeout) {
                                                        if (this.joinedOnce) {
                                                          throw new Error("tried to join multiple times. 'join' can only be called a single time per channel instance");
                                                        } else {
                                                          this.timeout = timeout;
                                                          this.joinedOnce = true;
                                                          this.rejoin();
                                                          return this.joinPush;
                                                        }
                                                      }
                                                      /**
                                                       * Hook into channel close
                                                       * @param {Function} callback
                                                       */
                                                      onClose(callback) {
                                                        this.on(CHANNEL_EVENTS.close, callback);
                                                      }
                                                      /**
                                                       * Hook into channel errors
                                                       * @param {Function} callback
                                                       */
                                                      onError(callback) {
                                                        return this.on(CHANNEL_EVENTS.error, (reason) => callback(reason));
                                                      }
                                                      /**
                                                       * Subscribes on channel events
                                                       *
                                                       * Subscription returns a ref counter, which can be used later to
                                                       * unsubscribe the exact event listener
                                                       *
                                                       * @example
                                                       * const ref1 = channel.on("event", do_stuff)
                                                       * const ref2 = channel.on("event", do_other_stuff)
                                                       * channel.off("event", ref1)
                                                       * // Since unsubscription, do_stuff won't fire,
                                                       * // while do_other_stuff will keep firing on the "event"
                                                       *
                                                       * @param {string} event
                                                       * @param {Function} callback
                                                       * @returns {integer} ref
                                                       */
                                                      on(event, callback) {
                                                        let ref = this.bindingRef++;
                                                        this.bindings.push({ event, ref, callback });
                                                        return ref;
                                                      }
                                                      /**
                                                       * Unsubscribes off of channel events
                                                       *
                                                       * Use the ref returned from a channel.on() to unsubscribe one
                                                       * handler, or pass nothing for the ref to unsubscribe all
                                                       * handlers for the given event.
                                                       *
                                                       * @example
                                                       * // Unsubscribe the do_stuff handler
                                                       * const ref1 = channel.on("event", do_stuff)
                                                       * channel.off("event", ref1)
                                                       *
                                                       * // Unsubscribe all handlers from event
                                                       * channel.off("event")
                                                       *
                                                       * @param {string} event
                                                       * @param {integer} ref
                                                       */
                                                      off(event, ref) {
                                                        this.bindings = this.bindings.filter((bind) => {
                                                          return !(bind.event === event && (typeof ref === "undefined" || ref === bind.ref));
                                                        });
                                                      }
                                                      /**
                                                       * @private
                                                       */
                                                      canPush() {
                                                        return this.socket.isConnected() && this.isJoined();
                                                      }
                                                      /**
                                                       * Sends a message `event` to phoenix with the payload `payload`.
                                                       * Phoenix receives this in the `handle_in(event, payload, socket)`
                                                       * function. if phoenix replies or it times out (default 10000ms),
                                                       * then optionally the reply can be received.
                                                       *
                                                       * @example
                                                       * channel.push("event")
                                                       *   .receive("ok", payload => console.log("phoenix replied:", payload))
                                                       *   .receive("error", err => console.log("phoenix errored", err))
                                                       *   .receive("timeout", () => console.log("timed out pushing"))
                                                       * @param {string} event
                                                       * @param {Object} payload
                                                       * @param {number} [timeout]
                                                       * @returns {Push}
                                                       */
                                                      push(event, payload, timeout = this.timeout) {
                                                        payload = payload || {};
                                                        if (!this.joinedOnce) {
                                                          throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`);
                                                        }
                                                        let pushEvent = new Push(this, event, function() {
                                                          return payload;
                                                        }, timeout);
                                                        if (this.canPush()) {
                                                          pushEvent.send();
                                                        } else {
                                                          pushEvent.startTimeout();
                                                          this.pushBuffer.push(pushEvent);
                                                        }
                                                        return pushEvent;
                                                      }
                                                      /** Leaves the channel
                                                       *
                                                       * Unsubscribes from server events, and
                                                       * instructs channel to terminate on server
                                                       *
                                                       * Triggers onClose() hooks
                                                       *
                                                       * To receive leave acknowledgements, use the `receive`
                                                       * hook to bind to the server ack, ie:
                                                       *
                                                       * @example
                                                       * channel.leave().receive("ok", () => alert("left!") )
                                                       *
                                                       * @param {integer} timeout
                                                       * @returns {Push}
                                                       */
                                                      leave(timeout = this.timeout) {
                                                        this.rejoinTimer.reset();
                                                        this.joinPush.cancelTimeout();
                                                        this.state = CHANNEL_STATES.leaving;
                                                        let onClose = () => {
                                                          if (this.socket.hasLogger()) this.socket.log("channel", `leave ${this.topic}`);
                                                          this.trigger(CHANNEL_EVENTS.close, "leave");
                                                        };
                                                        let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);
                                                        leavePush.receive("ok", () => onClose()).receive("timeout", () => onClose());
                                                        leavePush.send();
                                                        if (!this.canPush()) {
                                                          leavePush.trigger("ok", {});
                                                        }
                                                        return leavePush;
                                                      }
                                                      /**
                                                       * Overridable message hook
                                                       *
                                                       * Receives all events for specialized message handling
                                                       * before dispatching to the channel callbacks.
                                                       *
                                                       * Must return the payload, modified or unmodified
                                                       * @param {string} event
                                                       * @param {Object} payload
                                                       * @param {integer} ref
                                                       * @returns {Object}
                                                       */
                                                      onMessage(_event, payload, _ref) {
                                                        return payload;
                                                      }
                                                      /**
                                                       * @private
                                                       */
                                                      isMember(topic, event, payload, joinRef) {
                                                        if (this.topic !== topic) {
                                                          return false;
                                                        }
                                                        if (joinRef && joinRef !== this.joinRef()) {
                                                          if (this.socket.hasLogger()) this.socket.log("channel", "dropping outdated message", { topic, event, payload, joinRef });
                                                          return false;
                                                        } else {
                                                          return true;
                                                        }
                                                      }
                                                      /**
                                                       * @private
                                                       */
                                                      joinRef() {
                                                        return this.joinPush.ref;
                                                      }
                                                      /**
                                                       * @private
                                                       */
                                                      rejoin(timeout = this.timeout) {
                                                        if (this.isLeaving()) {
                                                          return;
                                                        }
                                                        this.socket.leaveOpenTopic(this.topic);
                                                        this.state = CHANNEL_STATES.joining;
                                                        this.joinPush.resend(timeout);
                                                      }
                                                      /**
                                                       * @private
                                                       */
                                                      trigger(event, payload, ref, joinRef) {
                                                        let handledPayload = this.onMessage(event, payload, ref, joinRef);
                                                        if (payload && !handledPayload) {
                                                          throw new Error("channel onMessage callbacks must return the payload, modified or unmodified");
                                                        }
                                                        let eventBindings = this.bindings.filter((bind) => bind.event === event);
                                                        for (let i = 0; i < eventBindings.length; i++) {
                                                          let bind = eventBindings[i];
                                                          bind.callback(handledPayload, ref, joinRef || this.joinRef());
                                                        }
                                                      }
                                                      /**
                                                       * @private
                                                       */
                                                      replyEventName(ref) {
                                                        return `chan_reply_${ref}`;
                                                      }
                                                      /**
                                                       * @private
                                                       */
                                                      isClosed() {
                                                        return this.state === CHANNEL_STATES.closed;
                                                      }
                                                      /**
                                                       * @private
                                                       */
                                                      isErrored() {
                                                        return this.state === CHANNEL_STATES.errored;
                                                      }
                                                      /**
                                                       * @private
                                                       */
                                                      isJoined() {
                                                        return this.state === CHANNEL_STATES.joined;
                                                      }
                                                      /**
                                                       * @private
                                                       */
                                                      isJoining() {
                                                        return this.state === CHANNEL_STATES.joining;
                                                      }
                                                      /**
                                                       * @private
                                                       */
                                                      isLeaving() {
                                                        return this.state === CHANNEL_STATES.leaving;
                                                      }
                                                    };
                                                    var Ajax = class {
                                                      static request(method, endPoint, headers, body, timeout, ontimeout, callback) {
                                                        if (global.XDomainRequest) {
                                                          let req = new global.XDomainRequest();
                                                          return this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);
                                                        } else if (global.XMLHttpRequest) {
                                                          let req = new global.XMLHttpRequest();
                                                          return this.xhrRequest(req, method, endPoint, headers, body, timeout, ontimeout, callback);
                                                        } else if (global.fetch && global.AbortController) {
                                                          return this.fetchRequest(method, endPoint, headers, body, timeout, ontimeout, callback);
                                                        } else {
                                                          throw new Error("No suitable XMLHttpRequest implementation found");
                                                        }
                                                      }
                                                      static fetchRequest(method, endPoint, headers, body, timeout, ontimeout, callback) {
                                                        let options = {
                                                          method,
                                                          headers,
                                                          body
                                                        };
                                                        let controller = null;
                                                        if (timeout) {
                                                          controller = new AbortController();
                                                          const _timeoutId = setTimeout(() => controller.abort(), timeout);
                                                          options.signal = controller.signal;
                                                        }
                                                        global.fetch(endPoint, options).then((response) => response.text()).then((data) => this.parseJSON(data)).then((data) => callback && callback(data)).catch((err) => {
                                                          if (err.name === "AbortError" && ontimeout) {
                                                            ontimeout();
                                                          } else {
                                                            callback && callback(null);
                                                          }
                                                        });
                                                        return controller;
                                                      }
                                                      static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {
                                                        req.timeout = timeout;
                                                        req.open(method, endPoint);
                                                        req.onload = () => {
                                                          let response = this.parseJSON(req.responseText);
                                                          callback && callback(response);
                                                        };
                                                        if (ontimeout) {
                                                          req.ontimeout = ontimeout;
                                                        }
                                                        req.onprogress = () => {
                                                        };
                                                        req.send(body);
                                                        return req;
                                                      }
                                                      static xhrRequest(req, method, endPoint, headers, body, timeout, ontimeout, callback) {
                                                        req.open(method, endPoint, true);
                                                        req.timeout = timeout;
                                                        for (let [key, value] of Object.entries(headers)) {
                                                          req.setRequestHeader(key, value);
                                                        }
                                                        req.onerror = () => callback && callback(null);
                                                        req.onreadystatechange = () => {
                                                          if (req.readyState === XHR_STATES.complete && callback) {
                                                            let response = this.parseJSON(req.responseText);
                                                            callback(response);
                                                          }
                                                        };
                                                        if (ontimeout) {
                                                          req.ontimeout = ontimeout;
                                                        }
                                                        req.send(body);
                                                        return req;
                                                      }
                                                      static parseJSON(resp) {
                                                        if (!resp || resp === "") {
                                                          return null;
                                                        }
                                                        try {
                                                          return JSON.parse(resp);
                                                        } catch {
                                                          console && console.log("failed to parse JSON response", resp);
                                                          return null;
                                                        }
                                                      }
                                                      static serialize(obj, parentKey) {
                                                        let queryStr = [];
                                                        for (var key in obj) {
                                                          if (!Object.prototype.hasOwnProperty.call(obj, key)) {
                                                            continue;
                                                          }
                                                          let paramKey = parentKey ? `${parentKey}[${key}]` : key;
                                                          let paramVal = obj[key];
                                                          if (typeof paramVal === "object") {
                                                            queryStr.push(this.serialize(paramVal, paramKey));
                                                          } else {
                                                            queryStr.push(encodeURIComponent(paramKey) + "=" + encodeURIComponent(paramVal));
                                                          }
                                                        }
                                                        return queryStr.join("&");
                                                      }
                                                      static appendParams(url, params) {
                                                        if (Object.keys(params).length === 0) {
                                                          return url;
                                                        }
                                                        let prefix = url.match(/\?/) ? "&" : "?";
                                                        return `${url}${prefix}${this.serialize(params)}`;
                                                      }
                                                    };
                                                    var arrayBufferToBase64 = (buffer) => {
                                                      let binary = "";
                                                      let bytes = new Uint8Array(buffer);
                                                      let len = bytes.byteLength;
                                                      for (let i = 0; i < len; i++) {
                                                        binary += String.fromCharCode(bytes[i]);
                                                      }
                                                      return btoa(binary);
                                                    };
                                                    var LongPoll = class {
                                                      constructor(endPoint, protocols) {
                                                        if (protocols && protocols.length === 2 && protocols[1].startsWith(AUTH_TOKEN_PREFIX)) {
                                                          this.authToken = atob(protocols[1].slice(AUTH_TOKEN_PREFIX.length));
                                                        }
                                                        this.endPoint = null;
                                                        this.token = null;
                                                        this.skipHeartbeat = true;
                                                        this.reqs = /* @__PURE__ */ new Set();
                                                        this.awaitingBatchAck = false;
                                                        this.currentBatch = null;
                                                        this.currentBatchTimer = null;
                                                        this.batchBuffer = [];
                                                        this.onopen = function() {
                                                        };
                                                        this.onerror = function() {
                                                        };
                                                        this.onmessage = function() {
                                                        };
                                                        this.onclose = function() {
                                                        };
                                                        this.pollEndpoint = this.normalizeEndpoint(endPoint);
                                                        this.readyState = SOCKET_STATES.connecting;
                                                        setTimeout(() => this.poll(), 0);
                                                      }
                                                      normalizeEndpoint(endPoint) {
                                                        return endPoint.replace("ws://", "http://").replace("wss://", "https://").replace(new RegExp("(.*)/" + TRANSPORTS.websocket), "$1/" + TRANSPORTS.longpoll);
                                                      }
                                                      endpointURL() {
                                                        return Ajax.appendParams(this.pollEndpoint, { token: this.token });
                                                      }
                                                      closeAndRetry(code, reason, wasClean) {
                                                        this.close(code, reason, wasClean);
                                                        this.readyState = SOCKET_STATES.connecting;
                                                      }
                                                      ontimeout() {
                                                        this.onerror("timeout");
                                                        this.closeAndRetry(1005, "timeout", false);
                                                      }
                                                      isActive() {
                                                        return this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting;
                                                      }
                                                      poll() {
                                                        const headers = { "Accept": "application/json" };
                                                        if (this.authToken) {
                                                          headers["X-Phoenix-AuthToken"] = this.authToken;
                                                        }
                                                        this.ajax("GET", headers, null, () => this.ontimeout(), (resp) => {
                                                          if (resp) {
                                                            var { status, token, messages } = resp;
                                                            if (status === 410 && this.token !== null) {
                                                              this.onerror(410);
                                                              this.closeAndRetry(3410, "session_gone", false);
                                                              return;
                                                            }
                                                            this.token = token;
                                                          } else {
                                                            status = 0;
                                                          }
                                                          switch (status) {
                                                            case 200:
                                                              messages.forEach((msg) => {
                                                                setTimeout(() => this.onmessage({ data: msg }), 0);
                                                              });
                                                              this.poll();
                                                              break;
                                                            case 204:
                                                              this.poll();
                                                              break;
                                                            case 410:
                                                              this.readyState = SOCKET_STATES.open;
                                                              this.onopen({});
                                                              this.poll();
                                                              break;
                                                            case 403:
                                                              this.onerror(403);
                                                              this.close(1008, "forbidden", false);
                                                              break;
                                                            case 0:
                                                            case 500:
                                                              this.onerror(500);
                                                              this.closeAndRetry(1011, "internal server error", 500);
                                                              break;
                                                            default:
                                                              throw new Error(`unhandled poll status ${status}`);
                                                          }
                                                        });
                                                      }
                                                      // we collect all pushes within the current event loop by
                                                      // setTimeout 0, which optimizes back-to-back procedural
                                                      // pushes against an empty buffer
                                                      send(body) {
                                                        if (typeof body !== "string") {
                                                          body = arrayBufferToBase64(body);
                                                        }
                                                        if (this.currentBatch) {
                                                          this.currentBatch.push(body);
                                                        } else if (this.awaitingBatchAck) {
                                                          this.batchBuffer.push(body);
                                                        } else {
                                                          this.currentBatch = [body];
                                                          this.currentBatchTimer = setTimeout(() => {
                                                            this.batchSend(this.currentBatch);
                                                            this.currentBatch = null;
                                                          }, 0);
                                                        }
                                                      }
                                                      batchSend(messages) {
                                                        this.awaitingBatchAck = true;
                                                        this.ajax("POST", { "Content-Type": "application/x-ndjson" }, messages.join("\n"), () => this.onerror("timeout"), (resp) => {
                                                          this.awaitingBatchAck = false;
                                                          if (!resp || resp.status !== 200) {
                                                            this.onerror(resp && resp.status);
                                                            this.closeAndRetry(1011, "internal server error", false);
                                                          } else if (this.batchBuffer.length > 0) {
                                                            this.batchSend(this.batchBuffer);
                                                            this.batchBuffer = [];
                                                          }
                                                        });
                                                      }
                                                      close(code, reason, wasClean) {
                                                        for (let req of this.reqs) {
                                                          req.abort();
                                                        }
                                                        this.readyState = SOCKET_STATES.closed;
                                                        let opts = Object.assign({ code: 1e3, reason: void 0, wasClean: true }, { code, reason, wasClean });
                                                        this.batchBuffer = [];
                                                        clearTimeout(this.currentBatchTimer);
                                                        this.currentBatchTimer = null;
                                                        if (typeof CloseEvent !== "undefined") {
                                                          this.onclose(new CloseEvent("close", opts));
                                                        } else {
                                                          this.onclose(opts);
                                                        }
                                                      }
                                                      ajax(method, headers, body, onCallerTimeout, callback) {
                                                        let req;
                                                        let ontimeout = () => {
                                                          this.reqs.delete(req);
                                                          onCallerTimeout();
                                                        };
                                                        req = Ajax.request(method, this.endpointURL(), headers, body, this.timeout, ontimeout, (resp) => {
                                                          this.reqs.delete(req);
                                                          if (this.isActive()) {
                                                            callback(resp);
                                                          }
                                                        });
                                                        this.reqs.add(req);
                                                      }
                                                    };
                                                    var serializer_default = {
                                                      HEADER_LENGTH: 1,
                                                      META_LENGTH: 4,
                                                      KINDS: { push: 0, reply: 1, broadcast: 2 },
                                                      encode(msg, callback) {
                                                        if (msg.payload.constructor === ArrayBuffer) {
                                                          return callback(this.binaryEncode(msg));
                                                        } else {
                                                          let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];
                                                          return callback(JSON.stringify(payload));
                                                        }
                                                      },
                                                      decode(rawPayload, callback) {
                                                        if (rawPayload.constructor === ArrayBuffer) {
                                                          return callback(this.binaryDecode(rawPayload));
                                                        } else {
                                                          let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload);
                                                          return callback({ join_ref, ref, topic, event, payload });
                                                        }
                                                      },
                                                      // private
                                                      binaryEncode(message) {
                                                        let { join_ref, ref, event, topic, payload } = message;
                                                        let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length;
                                                        let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);
                                                        let view = new DataView(header);
                                                        let offset = 0;
                                                        view.setUint8(offset++, this.KINDS.push);
                                                        view.setUint8(offset++, join_ref.length);
                                                        view.setUint8(offset++, ref.length);
                                                        view.setUint8(offset++, topic.length);
                                                        view.setUint8(offset++, event.length);
                                                        Array.from(join_ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
                                                        Array.from(ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
                                                        Array.from(topic, (char) => view.setUint8(offset++, char.charCodeAt(0)));
                                                        Array.from(event, (char) => view.setUint8(offset++, char.charCodeAt(0)));
                                                        var combined = new Uint8Array(header.byteLength + payload.byteLength);
                                                        combined.set(new Uint8Array(header), 0);
                                                        combined.set(new Uint8Array(payload), header.byteLength);
                                                        return combined.buffer;
                                                      },
                                                      binaryDecode(buffer) {
                                                        let view = new DataView(buffer);
                                                        let kind = view.getUint8(0);
                                                        let decoder = new TextDecoder();
                                                        switch (kind) {
                                                          case this.KINDS.push:
                                                            return this.decodePush(buffer, view, decoder);
                                                          case this.KINDS.reply:
                                                            return this.decodeReply(buffer, view, decoder);
                                                          case this.KINDS.broadcast:
                                                            return this.decodeBroadcast(buffer, view, decoder);
                                                        }
                                                      },
                                                      decodePush(buffer, view, decoder) {
                                                        let joinRefSize = view.getUint8(1);
                                                        let topicSize = view.getUint8(2);
                                                        let eventSize = view.getUint8(3);
                                                        let offset = this.HEADER_LENGTH + this.META_LENGTH - 1;
                                                        let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
                                                        offset = offset + joinRefSize;
                                                        let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
                                                        offset = offset + topicSize;
                                                        let event = decoder.decode(buffer.slice(offset, offset + eventSize));
                                                        offset = offset + eventSize;
                                                        let data = buffer.slice(offset, buffer.byteLength);
                                                        return { join_ref: joinRef, ref: null, topic, event, payload: data };
                                                      },
                                                      decodeReply(buffer, view, decoder) {
                                                        let joinRefSize = view.getUint8(1);
                                                        let refSize = view.getUint8(2);
                                                        let topicSize = view.getUint8(3);
                                                        let eventSize = view.getUint8(4);
                                                        let offset = this.HEADER_LENGTH + this.META_LENGTH;
                                                        let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
                                                        offset = offset + joinRefSize;
                                                        let ref = decoder.decode(buffer.slice(offset, offset + refSize));
                                                        offset = offset + refSize;
                                                        let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
                                                        offset = offset + topicSize;
                                                        let event = decoder.decode(buffer.slice(offset, offset + eventSize));
                                                        offset = offset + eventSize;
                                                        let data = buffer.slice(offset, buffer.byteLength);
                                                        let payload = { status: event, response: data };
                                                        return { join_ref: joinRef, ref, topic, event: CHANNEL_EVENTS.reply, payload };
                                                      },
                                                      decodeBroadcast(buffer, view, decoder) {
                                                        let topicSize = view.getUint8(1);
                                                        let eventSize = view.getUint8(2);
                                                        let offset = this.HEADER_LENGTH + 2;
                                                        let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
                                                        offset = offset + topicSize;
                                                        let event = decoder.decode(buffer.slice(offset, offset + eventSize));
                                                        offset = offset + eventSize;
                                                        let data = buffer.slice(offset, buffer.byteLength);
                                                        return { join_ref: null, ref: null, topic, event, payload: data };
                                                      }
                                                    };
                                                    var Socket = class {
                                                      constructor(endPoint, opts = {}) {
                                                        this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };
                                                        this.channels = [];
                                                        this.sendBuffer = [];
                                                        this.ref = 0;
                                                        this.fallbackRef = null;
                                                        this.timeout = opts.timeout || DEFAULT_TIMEOUT;
                                                        this.transport = opts.transport || global.WebSocket || LongPoll;
                                                        this.primaryPassedHealthCheck = false;
                                                        this.longPollFallbackMs = opts.longPollFallbackMs;
                                                        this.fallbackTimer = null;
                                                        this.sessionStore = opts.sessionStorage || global && global.sessionStorage;
                                                        this.establishedConnections = 0;
                                                        this.defaultEncoder = serializer_default.encode.bind(serializer_default);
                                                        this.defaultDecoder = serializer_default.decode.bind(serializer_default);
                                                        this.closeWasClean = false;
                                                        this.disconnecting = false;
                                                        this.binaryType = opts.binaryType || "arraybuffer";
                                                        this.connectClock = 1;
                                                        this.pageHidden = false;
                                                        if (this.transport !== LongPoll) {
                                                          this.encode = opts.encode || this.defaultEncoder;
                                                          this.decode = opts.decode || this.defaultDecoder;
                                                        } else {
                                                          this.encode = this.defaultEncoder;
                                                          this.decode = this.defaultDecoder;
                                                        }
                                                        let awaitingConnectionOnPageShow = null;
                                                        if (phxWindow && phxWindow.addEventListener) {
                                                          phxWindow.addEventListener("pagehide", (_e) => {
                                                            if (this.conn) {
                                                              this.disconnect();
                                                              awaitingConnectionOnPageShow = this.connectClock;
                                                            }
                                                          });
                                                          phxWindow.addEventListener("pageshow", (_e) => {
                                                            if (awaitingConnectionOnPageShow === this.connectClock) {
                                                              awaitingConnectionOnPageShow = null;
                                                              this.connect();
                                                            }
                                                          });
                                                          phxWindow.addEventListener("visibilitychange", () => {
                                                            if (document.visibilityState === "hidden") {
                                                              this.pageHidden = true;
                                                            } else {
                                                              this.pageHidden = false;
                                                              if (!this.isConnected()) {
                                                                this.teardown(() => this.connect());
                                                              }
                                                            }
                                                          });
                                                        }
                                                        this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 3e4;
                                                        this.rejoinAfterMs = (tries) => {
                                                          if (opts.rejoinAfterMs) {
                                                            return opts.rejoinAfterMs(tries);
                                                          } else {
                                                            return [1e3, 2e3, 5e3][tries - 1] || 1e4;
                                                          }
                                                        };
                                                        this.reconnectAfterMs = (tries) => {
                                                          if (opts.reconnectAfterMs) {
                                                            return opts.reconnectAfterMs(tries);
                                                          } else {
                                                            return [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][tries - 1] || 5e3;
                                                          }
                                                        };
                                                        this.logger = opts.logger || null;
                                                        if (!this.logger && opts.debug) {
                                                          this.logger = (kind, msg, data) => {
                                                            console.log(`${kind}: ${msg}`, data);
                                                          };
                                                        }
                                                        this.longpollerTimeout = opts.longpollerTimeout || 2e4;
                                                        this.params = closure(opts.params || {});
                                                        this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;
                                                        this.vsn = opts.vsn || DEFAULT_VSN;
                                                        this.heartbeatTimeoutTimer = null;
                                                        this.heartbeatTimer = null;
                                                        this.pendingHeartbeatRef = null;
                                                        this.reconnectTimer = new Timer(() => {
                                                          if (this.pageHidden) {
                                                            this.log("Not reconnecting as page is hidden!");
                                                            this.teardown();
                                                            return;
                                                          }
                                                          this.teardown(() => this.connect());
                                                        }, this.reconnectAfterMs);
                                                        this.authToken = opts.authToken;
                                                      }
                                                      /**
                                                       * Returns the LongPoll transport reference
                                                       */
                                                      getLongPollTransport() {
                                                        return LongPoll;
                                                      }
                                                      /**
                                                       * Disconnects and replaces the active transport
                                                       *
                                                       * @param {Function} newTransport - The new transport class to instantiate
                                                       *
                                                       */
                                                      replaceTransport(newTransport) {
                                                        this.connectClock++;
                                                        this.closeWasClean = true;
                                                        clearTimeout(this.fallbackTimer);
                                                        this.reconnectTimer.reset();
                                                        if (this.conn) {
                                                          this.conn.close();
                                                          this.conn = null;
                                                        }
                                                        this.transport = newTransport;
                                                      }
                                                      /**
                                                       * Returns the socket protocol
                                                       *
                                                       * @returns {string}
                                                       */
                                                      protocol() {
                                                        return location.protocol.match(/^https/) ? "wss" : "ws";
                                                      }
                                                      /**
                                                       * The fully qualified socket url
                                                       *
                                                       * @returns {string}
                                                       */
                                                      endPointURL() {
                                                        let uri = Ajax.appendParams(
                                                          Ajax.appendParams(this.endPoint, this.params()),
                                                          { vsn: this.vsn }
                                                        );
                                                        if (uri.charAt(0) !== "/") {
                                                          return uri;
                                                        }
                                                        if (uri.charAt(1) === "/") {
                                                          return `${this.protocol()}:${uri}`;
                                                        }
                                                        return `${this.protocol()}://${location.host}${uri}`;
                                                      }
                                                      /**
                                                       * Disconnects the socket
                                                       *
                                                       * See https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes for valid status codes.
                                                       *
                                                       * @param {Function} callback - Optional callback which is called after socket is disconnected.
                                                       * @param {integer} code - A status code for disconnection (Optional).
                                                       * @param {string} reason - A textual description of the reason to disconnect. (Optional)
                                                       */
                                                      disconnect(callback, code, reason) {
                                                        this.connectClock++;
                                                        this.disconnecting = true;
                                                        this.closeWasClean = true;
                                                        clearTimeout(this.fallbackTimer);
                                                        this.reconnectTimer.reset();
                                                        this.teardown(() => {
                                                          this.disconnecting = false;
                                                          callback && callback();
                                                        }, code, reason);
                                                      }
                                                      /**
                                                       *
                                                       * @param {Object} params - The params to send when connecting, for example `{user_id: userToken}`
                                                       *
                                                       * Passing params to connect is deprecated; pass them in the Socket constructor instead:
                                                       * `new Socket("/socket", {params: {user_id: userToken}})`.
                                                       */
                                                      connect(params) {
                                                        if (params) {
                                                          console && console.log("passing params to connect is deprecated. Instead pass :params to the Socket constructor");
                                                          this.params = closure(params);
                                                        }
                                                        if (this.conn && !this.disconnecting) {
                                                          return;
                                                        }
                                                        if (this.longPollFallbackMs && this.transport !== LongPoll) {
                                                          this.connectWithFallback(LongPoll, this.longPollFallbackMs);
                                                        } else {
                                                          this.transportConnect();
                                                        }
                                                      }
                                                      /**
                                                       * Logs the message. Override `this.logger` for specialized logging. noops by default
                                                       * @param {string} kind
                                                       * @param {string} msg
                                                       * @param {Object} data
                                                       */
                                                      log(kind, msg, data) {
                                                        this.logger && this.logger(kind, msg, data);
                                                      }
                                                      /**
                                                       * Returns true if a logger has been set on this socket.
                                                       */
                                                      hasLogger() {
                                                        return this.logger !== null;
                                                      }
                                                      /**
                                                       * Registers callbacks for connection open events
                                                       *
                                                       * @example socket.onOpen(function(){ console.info("the socket was opened") })
                                                       *
                                                       * @param {Function} callback
                                                       */
                                                      onOpen(callback) {
                                                        let ref = this.makeRef();
                                                        this.stateChangeCallbacks.open.push([ref, callback]);
                                                        return ref;
                                                      }
                                                      /**
                                                       * Registers callbacks for connection close events
                                                       * @param {Function} callback
                                                       */
                                                      onClose(callback) {
                                                        let ref = this.makeRef();
                                                        this.stateChangeCallbacks.close.push([ref, callback]);
                                                        return ref;
                                                      }
                                                      /**
                                                       * Registers callbacks for connection error events
                                                       *
                                                       * @example socket.onError(function(error){ alert("An error occurred") })
                                                       *
                                                       * @param {Function} callback
                                                       */
                                                      onError(callback) {
                                                        let ref = this.makeRef();
                                                        this.stateChangeCallbacks.error.push([ref, callback]);
                                                        return ref;
                                                      }
                                                      /**
                                                       * Registers callbacks for connection message events
                                                       * @param {Function} callback
                                                       */
                                                      onMessage(callback) {
                                                        let ref = this.makeRef();
                                                        this.stateChangeCallbacks.message.push([ref, callback]);
                                                        return ref;
                                                      }
                                                      /**
                                                       * Pings the server and invokes the callback with the RTT in milliseconds
                                                       * @param {Function} callback
                                                       *
                                                       * Returns true if the ping was pushed or false if unable to be pushed.
                                                       */
                                                      ping(callback) {
                                                        if (!this.isConnected()) {
                                                          return false;
                                                        }
                                                        let ref = this.makeRef();
                                                        let startTime = Date.now();
                                                        this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref });
                                                        let onMsgRef = this.onMessage((msg) => {
                                                          if (msg.ref === ref) {
                                                            this.off([onMsgRef]);
                                                            callback(Date.now() - startTime);
                                                          }
                                                        });
                                                        return true;
                                                      }
                                                      /**
                                                       * @private
                                                       */
                                                      transportConnect() {
                                                        this.connectClock++;
                                                        this.closeWasClean = false;
                                                        let protocols = void 0;
                                                        if (this.authToken) {
                                                          protocols = ["phoenix", `${AUTH_TOKEN_PREFIX}${btoa(this.authToken).replace(/=/g, "")}`];
                                                        }
                                                        this.conn = new this.transport(this.endPointURL(), protocols);
                                                        this.conn.binaryType = this.binaryType;
                                                        this.conn.timeout = this.longpollerTimeout;
                                                        this.conn.onopen = () => this.onConnOpen();
                                                        this.conn.onerror = (error) => this.onConnError(error);
                                                        this.conn.onmessage = (event) => this.onConnMessage(event);
                                                        this.conn.onclose = (event) => this.onConnClose(event);
                                                      }
                                                      getSession(key) {
                                                        return this.sessionStore && this.sessionStore.getItem(key);
                                                      }
                                                      storeSession(key, val) {
                                                        this.sessionStore && this.sessionStore.setItem(key, val);
                                                      }
                                                      connectWithFallback(fallbackTransport, fallbackThreshold = 2500) {
                                                        clearTimeout(this.fallbackTimer);
                                                        let established = false;
                                                        let primaryTransport = true;
                                                        let openRef, errorRef;
                                                        let fallback = (reason) => {
                                                          this.log("transport", `falling back to ${fallbackTransport.name}...`, reason);
                                                          this.off([openRef, errorRef]);
                                                          primaryTransport = false;
                                                          this.replaceTransport(fallbackTransport);
                                                          this.transportConnect();
                                                        };
                                                        if (this.getSession(`phx:fallback:${fallbackTransport.name}`)) {
                                                          return fallback("memorized");
                                                        }
                                                        this.fallbackTimer = setTimeout(fallback, fallbackThreshold);
                                                        errorRef = this.onError((reason) => {
                                                          this.log("transport", "error", reason);
                                                          if (primaryTransport && !established) {
                                                            clearTimeout(this.fallbackTimer);
                                                            fallback(reason);
                                                          }
                                                        });
                                                        if (this.fallbackRef) {
                                                          this.off([this.fallbackRef]);
                                                        }
                                                        this.fallbackRef = this.onOpen(() => {
                                                          established = true;
                                                          if (!primaryTransport) {
                                                            if (!this.primaryPassedHealthCheck) {
                                                              this.storeSession(`phx:fallback:${fallbackTransport.name}`, "true");
                                                            }
                                                            return this.log("transport", `established ${fallbackTransport.name} fallback`);
                                                          }
                                                          clearTimeout(this.fallbackTimer);
                                                          this.fallbackTimer = setTimeout(fallback, fallbackThreshold);
                                                          this.ping((rtt) => {
                                                            this.log("transport", "connected to primary after", rtt);
                                                            this.primaryPassedHealthCheck = true;
                                                            clearTimeout(this.fallbackTimer);
                                                          });
                                                        });
                                                        this.transportConnect();
                                                      }
                                                      clearHeartbeats() {
                                                        clearTimeout(this.heartbeatTimer);
                                                        clearTimeout(this.heartbeatTimeoutTimer);
                                                      }
                                                      onConnOpen() {
                                                        if (this.hasLogger()) this.log("transport", `${this.transport.name} connected to ${this.endPointURL()}`);
                                                        this.closeWasClean = false;
                                                        this.disconnecting = false;
                                                        this.establishedConnections++;
                                                        this.flushSendBuffer();
                                                        this.reconnectTimer.reset();
                                                        this.resetHeartbeat();
                                                        this.stateChangeCallbacks.open.forEach(([, callback]) => callback());
                                                      }
                                                      /**
                                                       * @private
                                                       */
                                                      heartbeatTimeout() {
                                                        if (this.pendingHeartbeatRef) {
                                                          this.pendingHeartbeatRef = null;
                                                          if (this.hasLogger()) {
                                                            this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
                                                          }
                                                          this.triggerChanError();
                                                          this.closeWasClean = false;
                                                          this.teardown(() => this.reconnectTimer.scheduleTimeout(), WS_CLOSE_NORMAL, "heartbeat timeout");
                                                        }
                                                      }
                                                      resetHeartbeat() {
                                                        if (this.conn && this.conn.skipHeartbeat) {
                                                          return;
                                                        }
                                                        this.pendingHeartbeatRef = null;
                                                        this.clearHeartbeats();
                                                        this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
                                                      }
                                                      teardown(callback, code, reason) {
                                                        if (!this.conn) {
                                                          return callback && callback();
                                                        }
                                                        let connectClock = this.connectClock;
                                                        this.waitForBufferDone(() => {
                                                          if (connectClock !== this.connectClock) {
                                                            return;
                                                          }
                                                          if (this.conn) {
                                                            if (code) {
                                                              this.conn.close(code, reason || "");
                                                            } else {
                                                              this.conn.close();
                                                            }
                                                          }
                                                          this.waitForSocketClosed(() => {
                                                            if (connectClock !== this.connectClock) {
                                                              return;
                                                            }
                                                            if (this.conn) {
                                                              this.conn.onopen = function() {
                                                              };
                                                              this.conn.onerror = function() {
                                                              };
                                                              this.conn.onmessage = function() {
                                                              };
                                                              this.conn.onclose = function() {
                                                              };
                                                              this.conn = null;
                                                            }
                                                            callback && callback();
                                                          });
                                                        });
                                                      }
                                                      waitForBufferDone(callback, tries = 1) {
                                                        if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {
                                                          callback();
                                                          return;
                                                        }
                                                        setTimeout(() => {
                                                          this.waitForBufferDone(callback, tries + 1);
                                                        }, 150 * tries);
                                                      }
                                                      waitForSocketClosed(callback, tries = 1) {
                                                        if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {
                                                          callback();
                                                          return;
                                                        }
                                                        setTimeout(() => {
                                                          this.waitForSocketClosed(callback, tries + 1);
                                                        }, 150 * tries);
                                                      }
                                                      onConnClose(event) {
                                                        if (this.conn) this.conn.onclose = () => {
                                                        };
                                                        let closeCode = event && event.code;
                                                        if (this.hasLogger()) this.log("transport", "close", event);
                                                        this.triggerChanError();
                                                        this.clearHeartbeats();
                                                        if (!this.closeWasClean && closeCode !== 1e3) {
                                                          this.reconnectTimer.scheduleTimeout();
                                                        }
                                                        this.stateChangeCallbacks.close.forEach(([, callback]) => callback(event));
                                                      }
                                                      /**
                                                       * @private
                                                       */
                                                      onConnError(error) {
                                                        if (this.hasLogger()) this.log("transport", error);
                                                        let transportBefore = this.transport;
                                                        let establishedBefore = this.establishedConnections;
                                                        this.stateChangeCallbacks.error.forEach(([, callback]) => {
                                                          callback(error, transportBefore, establishedBefore);
                                                        });
                                                        if (transportBefore === this.transport || establishedBefore > 0) {
                                                          this.triggerChanError();
                                                        }
                                                      }
                                                      /**
                                                       * @private
                                                       */
                                                      triggerChanError() {
                                                        this.channels.forEach((channel) => {
                                                          if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {
                                                            channel.trigger(CHANNEL_EVENTS.error);
                                                          }
                                                        });
                                                      }
                                                      /**
                                                       * @returns {string}
                                                       */
                                                      connectionState() {
                                                        switch (this.conn && this.conn.readyState) {
                                                          case SOCKET_STATES.connecting:
                                                            return "connecting";
                                                          case SOCKET_STATES.open:
                                                            return "open";
                                                          case SOCKET_STATES.closing:
                                                            return "closing";
                                                          default:
                                                            return "closed";
                                                        }
                                                      }
                                                      /**
                                                       * @returns {boolean}
                                                       */
                                                      isConnected() {
                                                        return this.connectionState() === "open";
                                                      }
                                                      /**
                                                       * @private
                                                       *
                                                       * @param {Channel}
                                                       */
                                                      remove(channel) {
                                                        this.off(channel.stateChangeRefs);
                                                        this.channels = this.channels.filter((c) => c !== channel);
                                                      }
                                                      /**
                                                       * Removes `onOpen`, `onClose`, `onError,` and `onMessage` registrations.
                                                       *
                                                       * @param {refs} - list of refs returned by calls to
                                                       *                 `onOpen`, `onClose`, `onError,` and `onMessage`
                                                       */
                                                      off(refs) {
                                                        for (let key in this.stateChangeCallbacks) {
                                                          this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {
                                                            return refs.indexOf(ref) === -1;
                                                          });
                                                        }
                                                      }
                                                      /**
                                                       * Initiates a new channel for the given topic
                                                       *
                                                       * @param {string} topic
                                                       * @param {Object} chanParams - Parameters for the channel
                                                       * @returns {Channel}
                                                       */
                                                      channel(topic, chanParams = {}) {
                                                        let chan = new Channel(topic, chanParams, this);
                                                        this.channels.push(chan);
                                                        return chan;
                                                      }
                                                      /**
                                                       * @param {Object} data
                                                       */
                                                      push(data) {
                                                        if (this.hasLogger()) {
                                                          let { topic, event, payload, ref, join_ref } = data;
                                                          this.log("push", `${topic} ${event} (${join_ref}, ${ref})`, payload);
                                                        }
                                                        if (this.isConnected()) {
                                                          this.encode(data, (result) => this.conn.send(result));
                                                        } else {
                                                          this.sendBuffer.push(() => this.encode(data, (result) => this.conn.send(result)));
                                                        }
                                                      }
                                                      /**
                                                       * Return the next message ref, accounting for overflows
                                                       * @returns {string}
                                                       */
                                                      makeRef() {
                                                        let newRef = this.ref + 1;
                                                        if (newRef === this.ref) {
                                                          this.ref = 0;
                                                        } else {
                                                          this.ref = newRef;
                                                        }
                                                        return this.ref.toString();
                                                      }
                                                      sendHeartbeat() {
                                                        if (this.pendingHeartbeatRef && !this.isConnected()) {
                                                          return;
                                                        }
                                                        this.pendingHeartbeatRef = this.makeRef();
                                                        this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref: this.pendingHeartbeatRef });
                                                        this.heartbeatTimeoutTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs);
                                                      }
                                                      flushSendBuffer() {
                                                        if (this.isConnected() && this.sendBuffer.length > 0) {
                                                          this.sendBuffer.forEach((callback) => callback());
                                                          this.sendBuffer = [];
                                                        }
                                                      }
                                                      onConnMessage(rawMessage) {
                                                        this.decode(rawMessage.data, (msg) => {
                                                          let { topic, event, payload, ref, join_ref } = msg;
                                                          if (ref && ref === this.pendingHeartbeatRef) {
                                                            this.clearHeartbeats();
                                                            this.pendingHeartbeatRef = null;
                                                            this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
                                                          }
                                                          if (this.hasLogger()) this.log("receive", `${payload.status || ""} ${topic} ${event} ${ref && "(" + ref + ")" || ""}`, payload);
                                                          for (let i = 0; i < this.channels.length; i++) {
                                                            const channel = this.channels[i];
                                                            if (!channel.isMember(topic, event, payload, join_ref)) {
                                                              continue;
                                                            }
                                                            channel.trigger(event, payload, ref, join_ref);
                                                          }
                                                          for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {
                                                            let [, callback] = this.stateChangeCallbacks.message[i];
                                                            callback(msg);
                                                          }
                                                        });
                                                      }
                                                      leaveOpenTopic(topic) {
                                                        let dupChannel = this.channels.find((c) => c.topic === topic && (c.isJoined() || c.isJoining()));
                                                        if (dupChannel) {
                                                          if (this.hasLogger()) this.log("transport", `leaving duplicate topic "${topic}"`);
                                                          dupChannel.leave();
                                                        }
                                                      }
                                                    };
                                                    var CONSECUTIVE_RELOADS = "consecutive-reloads";
                                                    var MAX_RELOADS = 10;
                                                    var RELOAD_JITTER_MIN = 5e3;
                                                    var RELOAD_JITTER_MAX = 1e4;
                                                    var FAILSAFE_JITTER = 3e4;
                                                    var PHX_EVENT_CLASSES = [
                                                      "phx-click-loading",
                                                      "phx-change-loading",
                                                      "phx-submit-loading",
                                                      "phx-keydown-loading",
                                                      "phx-keyup-loading",
                                                      "phx-blur-loading",
                                                      "phx-focus-loading",
                                                      "phx-hook-loading"
                                                    ];
                                                    var PHX_DROP_TARGET_ACTIVE_CLASS = "phx-drop-target-active";
                                                    var PHX_COMPONENT = "data-phx-component";
                                                    var PHX_VIEW_REF = "data-phx-view";
                                                    var PHX_LIVE_LINK = "data-phx-link";
                                                    var PHX_TRACK_STATIC = "track-static";
                                                    var PHX_LINK_STATE = "data-phx-link-state";
                                                    var PHX_REF_LOADING = "data-phx-ref-loading";
                                                    var PHX_REF_SRC = "data-phx-ref-src";
                                                    var PHX_REF_LOCK = "data-phx-ref-lock";
                                                    var PHX_PENDING_REFS = "phx-pending-refs";
                                                    var PHX_TRACK_UPLOADS = "track-uploads";
                                                    var PHX_UPLOAD_REF = "data-phx-upload-ref";
                                                    var PHX_PREFLIGHTED_REFS = "data-phx-preflighted-refs";
                                                    var PHX_DONE_REFS = "data-phx-done-refs";
                                                    var PHX_DROP_TARGET = "drop-target";
                                                    var PHX_ACTIVE_ENTRY_REFS = "data-phx-active-refs";
                                                    var PHX_LIVE_FILE_UPDATED = "phx:live-file:updated";
                                                    var PHX_SKIP = "data-phx-skip";
                                                    var PHX_MAGIC_ID = "data-phx-id";
                                                    var PHX_PRUNE = "data-phx-prune";
                                                    var PHX_CONNECTED_CLASS = "phx-connected";
                                                    var PHX_LOADING_CLASS = "phx-loading";
                                                    var PHX_ERROR_CLASS = "phx-error";
                                                    var PHX_CLIENT_ERROR_CLASS = "phx-client-error";
                                                    var PHX_SERVER_ERROR_CLASS = "phx-server-error";
                                                    var PHX_PARENT_ID = "data-phx-parent-id";
                                                    var PHX_MAIN = "data-phx-main";
                                                    var PHX_ROOT_ID = "data-phx-root-id";
                                                    var PHX_VIEWPORT_TOP = "viewport-top";
                                                    var PHX_VIEWPORT_BOTTOM = "viewport-bottom";
                                                    var PHX_VIEWPORT_OVERRUN_TARGET = "viewport-overrun-target";
                                                    var PHX_TRIGGER_ACTION = "trigger-action";
                                                    var PHX_HAS_FOCUSED = "phx-has-focused";
                                                    var FOCUSABLE_INPUTS = [
                                                      "text",
                                                      "textarea",
                                                      "number",
                                                      "email",
                                                      "password",
                                                      "search",
                                                      "tel",
                                                      "url",
                                                      "date",
                                                      "time",
                                                      "datetime-local",
                                                      "color",
                                                      "range"
                                                    ];
                                                    var CHECKABLE_INPUTS = ["checkbox", "radio"];
                                                    var PHX_HAS_SUBMITTED = "phx-has-submitted";
                                                    var PHX_SESSION = "data-phx-session";
                                                    var PHX_VIEW_SELECTOR = `[${PHX_SESSION}]`;
                                                    var PHX_STICKY = "data-phx-sticky";
                                                    var PHX_STATIC = "data-phx-static";
                                                    var PHX_READONLY = "data-phx-readonly";
                                                    var PHX_DISABLED = "data-phx-disabled";
                                                    var PHX_DISABLE_WITH = "disable-with";
                                                    var PHX_DISABLE_WITH_RESTORE = "data-phx-disable-with-restore";
                                                    var PHX_HOOK = "hook";
                                                    var PHX_DEBOUNCE = "debounce";
                                                    var PHX_THROTTLE = "throttle";
                                                    var PHX_UPDATE = "update";
                                                    var PHX_STREAM = "stream";
                                                    var PHX_STREAM_REF = "data-phx-stream";
                                                    var PHX_PORTAL = "data-phx-portal";
                                                    var PHX_TELEPORTED_REF = "data-phx-teleported";
                                                    var PHX_TELEPORTED_SRC = "data-phx-teleported-src";
                                                    var PHX_RUNTIME_HOOK = "data-phx-runtime-hook";
                                                    var PHX_LV_PID = "data-phx-pid";
                                                    var PHX_KEY = "key";
                                                    var PHX_PRIVATE = "phxPrivate";
                                                    var PHX_AUTO_RECOVER = "auto-recover";
                                                    var PHX_LV_DEBUG = "phx:live-socket:debug";
                                                    var PHX_LV_PROFILE = "phx:live-socket:profiling";
                                                    var PHX_LV_LATENCY_SIM = "phx:live-socket:latency-sim";
                                                    var PHX_LV_HISTORY_POSITION = "phx:nav-history-position";
                                                    var PHX_PROGRESS = "progress";
                                                    var PHX_MOUNTED = "mounted";
                                                    var PHX_RELOAD_STATUS = "__phoenix_reload_status__";
                                                    var LOADER_TIMEOUT = 1;
                                                    var MAX_CHILD_JOIN_ATTEMPTS = 3;
                                                    var BEFORE_UNLOAD_LOADER_TIMEOUT = 200;
                                                    var DISCONNECTED_TIMEOUT = 500;
                                                    var BINDING_PREFIX = "phx-";
                                                    var PUSH_TIMEOUT = 3e4;
                                                    var DEBOUNCE_TRIGGER = "debounce-trigger";
                                                    var THROTTLED = "throttled";
                                                    var DEBOUNCE_PREV_KEY = "debounce-prev-key";
                                                    var DEFAULTS = {
                                                      debounce: 300,
                                                      throttle: 300
                                                    };
                                                    var PHX_PENDING_ATTRS = [PHX_REF_LOADING, PHX_REF_SRC, PHX_REF_LOCK];
                                                    var STATIC = "s";
                                                    var ROOT = "r";
                                                    var COMPONENTS = "c";
                                                    var KEYED = "k";
                                                    var KEYED_COUNT = "kc";
                                                    var EVENTS = "e";
                                                    var REPLY = "r";
                                                    var TITLE = "t";
                                                    var TEMPLATES = "p";
                                                    var STREAM = "stream";
                                                    var EntryUploader = class {
                                                      constructor(entry, config, liveSocket2) {
                                                        const { chunk_size, chunk_timeout } = config;
                                                        this.liveSocket = liveSocket2;
                                                        this.entry = entry;
                                                        this.offset = 0;
                                                        this.chunkSize = chunk_size;
                                                        this.chunkTimeout = chunk_timeout;
                                                        this.chunkTimer = null;
                                                        this.errored = false;
                                                        this.uploadChannel = liveSocket2.channel(`lvu:${entry.ref}`, {
                                                          token: entry.metadata()
                                                        });
                                                      }
                                                      error(reason) {
                                                        if (this.errored) {
                                                          return;
                                                        }
                                                        this.uploadChannel.leave();
                                                        this.errored = true;
                                                        clearTimeout(this.chunkTimer);
                                                        this.entry.error(reason);
                                                      }
                                                      upload() {
                                                        this.uploadChannel.onError((reason) => this.error(reason));
                                                        this.uploadChannel.join().receive("ok", (_data) => this.readNextChunk()).receive("error", (reason) => this.error(reason));
                                                      }
                                                      isDone() {
                                                        return this.offset >= this.entry.file.size;
                                                      }
                                                      readNextChunk() {
                                                        const reader = new window.FileReader();
                                                        const blob = this.entry.file.slice(
                                                          this.offset,
                                                          this.chunkSize + this.offset
                                                        );
                                                        reader.onload = (e) => {
                                                          if (e.target.error === null) {
                                                            this.offset += /** @type {ArrayBuffer} */
                                                            e.target.result.byteLength;
                                                            this.pushChunk(
                                                              /** @type {ArrayBuffer} */
                                                              e.target.result
                                                            );
                                                          } else {
                                                            return logError("Read error: " + e.target.error);
                                                          }
                                                        };
                                                        reader.readAsArrayBuffer(blob);
                                                      }
                                                      pushChunk(chunk) {
                                                        if (!this.uploadChannel.isJoined()) {
                                                          return;
                                                        }
                                                        this.uploadChannel.push("chunk", chunk, this.chunkTimeout).receive("ok", () => {
                                                          this.entry.progress(this.offset / this.entry.file.size * 100);
                                                          if (!this.isDone()) {
                                                            this.chunkTimer = setTimeout(
                                                              () => this.readNextChunk(),
                                                              this.liveSocket.getLatencySim() || 0
                                                            );
                                                          }
                                                        }).receive("error", ({ reason }) => this.error(reason));
                                                      }
                                                    };
                                                    var logError = (msg, obj) => console.error && console.error(msg, obj);
                                                    var isCid = (cid) => {
                                                      const type = typeof cid;
                                                      return type === "number" || type === "string" && /^(0|[1-9]\d*)$/.test(cid);
                                                    };
                                                    function detectDuplicateIds() {
                                                      const ids = /* @__PURE__ */ new Set();
                                                      const elems = document.querySelectorAll("*[id]");
                                                      for (let i = 0, len = elems.length; i < len; i++) {
                                                        if (ids.has(elems[i].id)) {
                                                          console.error(
                                                            `Multiple IDs detected: ${elems[i].id}. Ensure unique element ids.`
                                                          );
                                                        } else {
                                                          ids.add(elems[i].id);
                                                        }
                                                      }
                                                    }
                                                    function detectInvalidStreamInserts(inserts) {
                                                      const errors = /* @__PURE__ */ new Set();
                                                      Object.keys(inserts).forEach((id) => {
                                                        const streamEl = document.getElementById(id);
                                                        if (streamEl && streamEl.parentElement && streamEl.parentElement.getAttribute("phx-update") !== "stream") {
                                                          errors.add(
                                                            `The stream container with id "${streamEl.parentElement.id}" is missing the phx-update="stream" attribute. Ensure it is set for streams to work properly.`
                                                          );
                                                        }
                                                      });
                                                      errors.forEach((error) => console.error(error));
                                                    }
                                                    var debug = (view, kind, msg, obj) => {
                                                      if (view.liveSocket.isDebugEnabled()) {
                                                        console.log(`${view.id} ${kind}: ${msg} - `, obj);
                                                      }
                                                    };
                                                    var closure2 = (val) => typeof val === "function" ? val : function() {
                                                      return val;
                                                    };
                                                    var clone = (obj) => {
                                                      return JSON.parse(JSON.stringify(obj));
                                                    };
                                                    var closestPhxBinding = (el, binding, borderEl) => {
                                                      do {
                                                        if (el.matches(`[${binding}]`) && !el.disabled) {
                                                          return el;
                                                        }
                                                        el = el.parentElement || el.parentNode;
                                                      } while (el !== null && el.nodeType === 1 && !(borderEl && borderEl.isSameNode(el) || el.matches(PHX_VIEW_SELECTOR)));
                                                      return null;
                                                    };
                                                    var isObject = (obj) => {
                                                      return obj !== null && typeof obj === "object" && !(obj instanceof Array);
                                                    };
                                                    var isEqualObj = (obj1, obj2) => JSON.stringify(obj1) === JSON.stringify(obj2);
                                                    var isEmpty = (obj) => {
                                                      for (const x in obj) {
                                                        return false;
                                                      }
                                                      return true;
                                                    };
                                                    var maybe = (el, callback) => el && callback(el);
                                                    var channelUploader = function(entries, onError, resp, liveSocket2) {
                                                      entries.forEach((entry) => {
                                                        const entryUploader = new EntryUploader(entry, resp.config, liveSocket2);
                                                        entryUploader.upload();
                                                      });
                                                    };
                                                    var eventContainsFiles = (e) => {
                                                      if (e.dataTransfer.types) {
                                                        for (let i = 0; i < e.dataTransfer.types.length; i++) {
                                                          if (e.dataTransfer.types[i] === "Files") {
                                                            return true;
                                                          }
                                                        }
                                                      }
                                                      return false;
                                                    };
                                                    var Browser = {
                                                      canPushState() {
                                                        return typeof history.pushState !== "undefined";
                                                      },
                                                      dropLocal(localStorage, namespace, subkey) {
                                                        return localStorage.removeItem(this.localKey(namespace, subkey));
                                                      },
                                                      updateLocal(localStorage, namespace, subkey, initial, func) {
                                                        const current = this.getLocal(localStorage, namespace, subkey);
                                                        const key = this.localKey(namespace, subkey);
                                                        const newVal = current === null ? initial : func(current);
                                                        localStorage.setItem(key, JSON.stringify(newVal));
                                                        return newVal;
                                                      },
                                                      getLocal(localStorage, namespace, subkey) {
                                                        return JSON.parse(localStorage.getItem(this.localKey(namespace, subkey)));
                                                      },
                                                      updateCurrentState(callback) {
                                                        if (!this.canPushState()) {
                                                          return;
                                                        }
                                                        history.replaceState(
                                                          callback(history.state || {}),
                                                          "",
                                                          window.location.href
                                                        );
                                                      },
                                                      pushState(kind, meta, to) {
                                                        if (this.canPushState()) {
                                                          if (to !== window.location.href) {
                                                            if (meta.type == "redirect" && meta.scroll) {
                                                              const currentState = history.state || {};
                                                              currentState.scroll = meta.scroll;
                                                              history.replaceState(currentState, "", window.location.href);
                                                            }
                                                            delete meta.scroll;
                                                            history[kind + "State"](meta, "", to || null);
                                                            window.requestAnimationFrame(() => {
                                                              const hashEl = this.getHashTargetEl(window.location.hash);
                                                              if (hashEl) {
                                                                hashEl.scrollIntoView();
                                                              } else if (meta.type === "redirect") {
                                                                window.scroll(0, 0);
                                                              }
                                                            });
                                                          }
                                                        } else {
                                                          this.redirect(to);
                                                        }
                                                      },
                                                      setCookie(name, value, maxAgeSeconds) {
                                                        const expires = typeof maxAgeSeconds === "number" ? ` max-age=${maxAgeSeconds};` : "";
                                                        document.cookie = `${name}=${value};${expires} path=/`;
                                                      },
                                                      getCookie(name) {
                                                        return document.cookie.replace(
                                                          new RegExp(`(?:(?:^|.*;s*)${name}s*=s*([^;]*).*$)|^.*$`),
                                                          "$1"
                                                        );
                                                      },
                                                      deleteCookie(name) {
                                                        document.cookie = `${name}=; max-age=-1; path=/`;
                                                      },
                                                      redirect(toURL, flash, navigate = (url) => {
                                                        window.location.href = url;
                                                      }) {
                                                        if (flash) {
                                                          this.setCookie("__phoenix_flash__", flash, 60);
                                                        }
                                                        navigate(toURL);
                                                      },
                                                      localKey(namespace, subkey) {
                                                        return `${namespace}-${subkey}`;
                                                      },
                                                      getHashTargetEl(maybeHash) {
                                                        const hash = maybeHash.toString().substring(1);
                                                        if (hash === "") {
                                                          return;
                                                        }
                                                        return document.getElementById(hash) || document.querySelector(`a[name="${hash}"]`);
                                                      }
                                                    };
                                                    var browser_default = Browser;
                                                    var DOM = {
                                                      byId(id) {
                                                        return document.getElementById(id) || logError(`no id found for ${id}`);
                                                      },
                                                      removeClass(el, className) {
                                                        el.classList.remove(className);
                                                        if (el.classList.length === 0) {
                                                          el.removeAttribute("class");
                                                        }
                                                      },
                                                      all(node, query, callback) {
                                                        if (!node) {
                                                          return [];
                                                        }
                                                        const array = Array.from(node.querySelectorAll(query));
                                                        if (callback) {
                                                          array.forEach(callback);
                                                        }
                                                        return array;
                                                      },
                                                      childNodeLength(html) {
                                                        const template = document.createElement("template");
                                                        template.innerHTML = html;
                                                        return template.content.childElementCount;
                                                      },
                                                      isUploadInput(el) {
                                                        return el.type === "file" && el.getAttribute(PHX_UPLOAD_REF) !== null;
                                                      },
                                                      isAutoUpload(inputEl) {
                                                        return inputEl.hasAttribute("data-phx-auto-upload");
                                                      },
                                                      findUploadInputs(node) {
                                                        const formId = node.id;
                                                        const inputsOutsideForm = this.all(
                                                          document,
                                                          `input[type="file"][${PHX_UPLOAD_REF}][form="${formId}"]`
                                                        );
                                                        return this.all(node, `input[type="file"][${PHX_UPLOAD_REF}]`).concat(
                                                          inputsOutsideForm
                                                        );
                                                      },
                                                      findComponentNodeList(viewId, cid, doc2 = document) {
                                                        return this.all(
                                                          doc2,
                                                          `[${PHX_VIEW_REF}="${viewId}"][${PHX_COMPONENT}="${cid}"]`
                                                        );
                                                      },
                                                      isPhxDestroyed(node) {
                                                        return node.id && DOM.private(node, "destroyed") ? true : false;
                                                      },
                                                      wantsNewTab(e) {
                                                        const wantsNewTab = e.ctrlKey || e.shiftKey || e.metaKey || e.button && e.button === 1;
                                                        const isDownload = e.target instanceof HTMLAnchorElement && e.target.hasAttribute("download");
                                                        const isTargetBlank = e.target.hasAttribute("target") && e.target.getAttribute("target").toLowerCase() === "_blank";
                                                        const isTargetNamedTab = e.target.hasAttribute("target") && !e.target.getAttribute("target").startsWith("_");
                                                        return wantsNewTab || isTargetBlank || isDownload || isTargetNamedTab;
                                                      },
                                                      isUnloadableFormSubmit(e) {
                                                        const isDialogSubmit = e.target && e.target.getAttribute("method") === "dialog" || e.submitter && e.submitter.getAttribute("formmethod") === "dialog";
                                                        if (isDialogSubmit) {
                                                          return false;
                                                        } else {
                                                          return !e.defaultPrevented && !this.wantsNewTab(e);
                                                        }
                                                      },
                                                      isNewPageClick(e, currentLocation) {
                                                        const href = e.target instanceof HTMLAnchorElement ? e.target.getAttribute("href") : null;
                                                        let url;
                                                        if (e.defaultPrevented || href === null || this.wantsNewTab(e)) {
                                                          return false;
                                                        }
                                                        if (href.startsWith("mailto:") || href.startsWith("tel:")) {
                                                          return false;
                                                        }
                                                        if (e.target.isContentEditable) {
                                                          return false;
                                                        }
                                                        try {
                                                          url = new URL(href);
                                                        } catch {
                                                          try {
                                                            url = new URL(href, currentLocation);
                                                          } catch {
                                                            return true;
                                                          }
                                                        }
                                                        if (url.host === currentLocation.host && url.protocol === currentLocation.protocol) {
                                                          if (url.pathname === currentLocation.pathname && url.search === currentLocation.search) {
                                                            return url.hash === "" && !url.href.endsWith("#");
                                                          }
                                                        }
                                                        return url.protocol.startsWith("http");
                                                      },
                                                      markPhxChildDestroyed(el) {
                                                        if (this.isPhxChild(el)) {
                                                          el.setAttribute(PHX_SESSION, "");
                                                        }
                                                        this.putPrivate(el, "destroyed", true);
                                                      },
                                                      findPhxChildrenInFragment(html, parentId) {
                                                        const template = document.createElement("template");
                                                        template.innerHTML = html;
                                                        return this.findPhxChildren(template.content, parentId);
                                                      },
                                                      isIgnored(el, phxUpdate) {
                                                        return (el.getAttribute(phxUpdate) || el.getAttribute("data-phx-update")) === "ignore";
                                                      },
                                                      isPhxUpdate(el, phxUpdate, updateTypes) {
                                                        return el.getAttribute && updateTypes.indexOf(el.getAttribute(phxUpdate)) >= 0;
                                                      },
                                                      findPhxSticky(el) {
                                                        return this.all(el, `[${PHX_STICKY}]`);
                                                      },
                                                      findPhxChildren(el, parentId) {
                                                        return this.all(el, `${PHX_VIEW_SELECTOR}[${PHX_PARENT_ID}="${parentId}"]`);
                                                      },
                                                      findExistingParentCIDs(viewId, cids) {
                                                        const parentCids = /* @__PURE__ */ new Set();
                                                        const childrenCids = /* @__PURE__ */ new Set();
                                                        cids.forEach((cid) => {
                                                          this.all(
                                                            document,
                                                            `[${PHX_VIEW_REF}="${viewId}"][${PHX_COMPONENT}="${cid}"]`
                                                          ).forEach((parent) => {
                                                            parentCids.add(cid);
                                                            this.all(parent, `[${PHX_VIEW_REF}="${viewId}"][${PHX_COMPONENT}]`).map((el) => parseInt(el.getAttribute(PHX_COMPONENT))).forEach((childCID) => childrenCids.add(childCID));
                                                          });
                                                        });
                                                        childrenCids.forEach((childCid) => parentCids.delete(childCid));
                                                        return parentCids;
                                                      },
                                                      private(el, key) {
                                                        return el[PHX_PRIVATE] && el[PHX_PRIVATE][key];
                                                      },
                                                      deletePrivate(el, key) {
                                                        el[PHX_PRIVATE] && delete el[PHX_PRIVATE][key];
                                                      },
                                                      putPrivate(el, key, value) {
                                                        if (!el[PHX_PRIVATE]) {
                                                          el[PHX_PRIVATE] = {};
                                                        }
                                                        el[PHX_PRIVATE][key] = value;
                                                      },
                                                      updatePrivate(el, key, defaultVal, updateFunc) {
                                                        const existing = this.private(el, key);
                                                        if (existing === void 0) {
                                                          this.putPrivate(el, key, updateFunc(defaultVal));
                                                        } else {
                                                          this.putPrivate(el, key, updateFunc(existing));
                                                        }
                                                      },
                                                      syncPendingAttrs(fromEl, toEl) {
                                                        if (!fromEl.hasAttribute(PHX_REF_SRC)) {
                                                          return;
                                                        }
                                                        PHX_EVENT_CLASSES.forEach((className) => {
                                                          fromEl.classList.contains(className) && toEl.classList.add(className);
                                                        });
                                                        PHX_PENDING_ATTRS.filter((attr) => fromEl.hasAttribute(attr)).forEach(
                                                          (attr) => {
                                                            toEl.setAttribute(attr, fromEl.getAttribute(attr));
                                                          }
                                                        );
                                                      },
                                                      copyPrivates(target, source) {
                                                        if (source[PHX_PRIVATE]) {
                                                          target[PHX_PRIVATE] = source[PHX_PRIVATE];
                                                        }
                                                      },
                                                      putTitle(str) {
                                                        const titleEl = document.querySelector("title");
                                                        if (titleEl) {
                                                          const { prefix, suffix, default: defaultTitle } = titleEl.dataset;
                                                          const isEmpty2 = typeof str !== "string" || str.trim() === "";
                                                          if (isEmpty2 && typeof defaultTitle !== "string") {
                                                            return;
                                                          }
                                                          const inner = isEmpty2 ? defaultTitle : str;
                                                          document.title = `${prefix || ""}${inner || ""}${suffix || ""}`;
                                                        } else {
                                                          document.title = str;
                                                        }
                                                      },
                                                      debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, asyncFilter, callback) {
                                                        let debounce = el.getAttribute(phxDebounce);
                                                        let throttle = el.getAttribute(phxThrottle);
                                                        if (debounce === "") {
                                                          debounce = defaultDebounce;
                                                        }
                                                        if (throttle === "") {
                                                          throttle = defaultThrottle;
                                                        }
                                                        const value = debounce || throttle;
                                                        switch (value) {
                                                          case null:
                                                            return callback();
                                                          case "blur":
                                                            this.incCycle(el, "debounce-blur-cycle", () => {
                                                              if (asyncFilter()) {
                                                                callback();
                                                              }
                                                            });
                                                            if (this.once(el, "debounce-blur")) {
                                                              el.addEventListener(
                                                                "blur",
                                                                () => this.triggerCycle(el, "debounce-blur-cycle")
                                                              );
                                                            }
                                                            return;
                                                          default:
                                                            const timeout = parseInt(value);
                                                            const trigger = () => throttle ? this.deletePrivate(el, THROTTLED) : callback();
                                                            const currentCycle = this.incCycle(el, DEBOUNCE_TRIGGER, trigger);
                                                            if (isNaN(timeout)) {
                                                              return logError(`invalid throttle/debounce value: ${value}`);
                                                            }
                                                            if (throttle) {
                                                              let newKeyDown = false;
                                                              if (event.type === "keydown") {
                                                                const prevKey = this.private(el, DEBOUNCE_PREV_KEY);
                                                                this.putPrivate(el, DEBOUNCE_PREV_KEY, event.key);
                                                                newKeyDown = prevKey !== event.key;
                                                              }
                                                              if (!newKeyDown && this.private(el, THROTTLED)) {
                                                                return false;
                                                              } else {
                                                                callback();
                                                                const t = setTimeout(() => {
                                                                  if (asyncFilter()) {
                                                                    this.triggerCycle(el, DEBOUNCE_TRIGGER);
                                                                  }
                                                                }, timeout);
                                                                this.putPrivate(el, THROTTLED, t);
                                                              }
                                                            } else {
                                                              setTimeout(() => {
                                                                if (asyncFilter()) {
                                                                  this.triggerCycle(el, DEBOUNCE_TRIGGER, currentCycle);
                                                                }
                                                              }, timeout);
                                                            }
                                                            const form = el.form;
                                                            if (form && this.once(form, "bind-debounce")) {
                                                              form.addEventListener("submit", () => {
                                                                Array.from(new FormData(form).entries(), ([name]) => {
                                                                  const namedItem = form.elements.namedItem(name);
                                                                  const input = namedItem instanceof RadioNodeList ? namedItem[0] : namedItem;
                                                                  if (input) {
                                                                    this.incCycle(input, DEBOUNCE_TRIGGER);
                                                                    this.deletePrivate(input, THROTTLED);
                                                                  }
                                                                });
                                                              });
                                                            }
                                                            if (this.once(el, "bind-debounce")) {
                                                              el.addEventListener("blur", () => {
                                                                clearTimeout(this.private(el, THROTTLED));
                                                                this.triggerCycle(el, DEBOUNCE_TRIGGER);
                                                              });
                                                            }
                                                        }
                                                      },
                                                      triggerCycle(el, key, currentCycle) {
                                                        const [cycle, trigger] = this.private(el, key);
                                                        if (!currentCycle) {
                                                          currentCycle = cycle;
                                                        }
                                                        if (currentCycle === cycle) {
                                                          this.incCycle(el, key);
                                                          trigger();
                                                        }
                                                      },
                                                      once(el, key) {
                                                        if (this.private(el, key) === true) {
                                                          return false;
                                                        }
                                                        this.putPrivate(el, key, true);
                                                        return true;
                                                      },
                                                      incCycle(el, key, trigger = function() {
                                                      }) {
                                                        let [currentCycle] = this.private(el, key) || [0, trigger];
                                                        currentCycle++;
                                                        this.putPrivate(el, key, [currentCycle, trigger]);
                                                        return currentCycle;
                                                      },
                                                      // maintains or adds privately used hook information
                                                      // fromEl and toEl can be the same element in the case of a newly added node
                                                      // fromEl and toEl can be any HTML node type, so we need to check if it's an element node
                                                      maintainPrivateHooks(fromEl, toEl, phxViewportTop, phxViewportBottom) {
                                                        if (fromEl.hasAttribute && fromEl.hasAttribute("data-phx-hook") && !toEl.hasAttribute("data-phx-hook")) {
                                                          toEl.setAttribute("data-phx-hook", fromEl.getAttribute("data-phx-hook"));
                                                        }
                                                        if (toEl.hasAttribute && (toEl.hasAttribute(phxViewportTop) || toEl.hasAttribute(phxViewportBottom))) {
                                                          toEl.setAttribute("data-phx-hook", "Phoenix.InfiniteScroll");
                                                        }
                                                      },
                                                      putCustomElHook(el, hook) {
                                                        if (el.isConnected) {
                                                          el.setAttribute("data-phx-hook", "");
                                                        } else {
                                                          console.error(`
        hook attached to non-connected DOM element
        ensure you are calling createHook within your connectedCallback. ${el.outerHTML}
      `);
                                                        }
                                                        this.putPrivate(el, "custom-el-hook", hook);
                                                      },
                                                      getCustomElHook(el) {
                                                        return this.private(el, "custom-el-hook");
                                                      },
                                                      isUsedInput(el) {
                                                        return el.nodeType === Node.ELEMENT_NODE && (this.private(el, PHX_HAS_FOCUSED) || this.private(el, PHX_HAS_SUBMITTED));
                                                      },
                                                      resetForm(form) {
                                                        Array.from(form.elements).forEach((input) => {
                                                          this.deletePrivate(input, PHX_HAS_FOCUSED);
                                                          this.deletePrivate(input, PHX_HAS_SUBMITTED);
                                                        });
                                                      },
                                                      isPhxChild(node) {
                                                        return node.getAttribute && node.getAttribute(PHX_PARENT_ID);
                                                      },
                                                      isPhxSticky(node) {
                                                        return node.getAttribute && node.getAttribute(PHX_STICKY) !== null;
                                                      },
                                                      isChildOfAny(el, parents) {
                                                        return !!parents.find((parent) => parent.contains(el));
                                                      },
                                                      firstPhxChild(el) {
                                                        return this.isPhxChild(el) ? el : this.all(el, `[${PHX_PARENT_ID}]`)[0];
                                                      },
                                                      isPortalTemplate(el) {
                                                        return el.tagName === "TEMPLATE" && el.hasAttribute(PHX_PORTAL);
                                                      },
                                                      closestViewEl(el) {
                                                        const portalOrViewEl = el.closest(
                                                          `[${PHX_TELEPORTED_REF}],${PHX_VIEW_SELECTOR}`
                                                        );
                                                        if (!portalOrViewEl) {
                                                          return null;
                                                        }
                                                        if (portalOrViewEl.hasAttribute(PHX_TELEPORTED_REF)) {
                                                          return this.byId(portalOrViewEl.getAttribute(PHX_TELEPORTED_REF));
                                                        } else if (portalOrViewEl.hasAttribute(PHX_SESSION)) {
                                                          return portalOrViewEl;
                                                        }
                                                        return null;
                                                      },
                                                      dispatchEvent(target, name, opts = {}) {
                                                        let defaultBubble = true;
                                                        const isUploadTarget = target.nodeName === "INPUT" && target.type === "file";
                                                        if (isUploadTarget && name === "click") {
                                                          defaultBubble = false;
                                                        }
                                                        const bubbles = opts.bubbles === void 0 ? defaultBubble : !!opts.bubbles;
                                                        const eventOpts = {
                                                          bubbles,
                                                          cancelable: true,
                                                          detail: opts.detail || {}
                                                        };
                                                        const event = name === "click" ? new MouseEvent("click", eventOpts) : new CustomEvent(name, eventOpts);
                                                        target.dispatchEvent(event);
                                                      },
                                                      cloneNode(node, html) {
                                                        if (typeof html === "undefined") {
                                                          return node.cloneNode(true);
                                                        } else {
                                                          const cloned = node.cloneNode(false);
                                                          cloned.innerHTML = html;
                                                          return cloned;
                                                        }
                                                      },
                                                      // merge attributes from source to target
                                                      // if an element is ignored, we only merge data attributes
                                                      // including removing data attributes that are no longer in the source
                                                      mergeAttrs(target, source, opts = {}) {
                                                        const exclude = new Set(opts.exclude || []);
                                                        const isIgnored = opts.isIgnored;
                                                        const sourceAttrs = source.attributes;
                                                        for (let i = sourceAttrs.length - 1; i >= 0; i--) {
                                                          const name = sourceAttrs[i].name;
                                                          if (!exclude.has(name)) {
                                                            const sourceValue = source.getAttribute(name);
                                                            if (target.getAttribute(name) !== sourceValue && (!isIgnored || isIgnored && name.startsWith("data-"))) {
                                                              target.setAttribute(name, sourceValue);
                                                            }
                                                          } else {
                                                            if (name === "value") {
                                                              const sourceValue = source.value ?? source.getAttribute(name);
                                                              if (target.value === sourceValue) {
                                                                target.setAttribute("value", source.getAttribute(name));
                                                              }
                                                            }
                                                          }
                                                        }
                                                        const targetAttrs = target.attributes;
                                                        for (let i = targetAttrs.length - 1; i >= 0; i--) {
                                                          const name = targetAttrs[i].name;
                                                          if (isIgnored) {
                                                            if (name.startsWith("data-") && !source.hasAttribute(name) && !PHX_PENDING_ATTRS.includes(name)) {
                                                              target.removeAttribute(name);
                                                            }
                                                          } else {
                                                            if (!source.hasAttribute(name)) {
                                                              target.removeAttribute(name);
                                                            }
                                                          }
                                                        }
                                                      },
                                                      mergeFocusedInput(target, source) {
                                                        if (!(target instanceof HTMLSelectElement)) {
                                                          DOM.mergeAttrs(target, source, { exclude: ["value"] });
                                                        }
                                                        if (source.readOnly) {
                                                          target.setAttribute("readonly", true);
                                                        } else {
                                                          target.removeAttribute("readonly");
                                                        }
                                                      },
                                                      hasSelectionRange(el) {
                                                        return el.setSelectionRange && (el.type === "text" || el.type === "textarea");
                                                      },
                                                      restoreFocus(focused, selectionStart, selectionEnd) {
                                                        if (focused instanceof HTMLSelectElement) {
                                                          focused.focus();
                                                        }
                                                        if (!DOM.isTextualInput(focused)) {
                                                          return;
                                                        }
                                                        const wasFocused = focused.matches(":focus");
                                                        if (!wasFocused) {
                                                          focused.focus();
                                                        }
                                                        if (this.hasSelectionRange(focused)) {
                                                          focused.setSelectionRange(selectionStart, selectionEnd);
                                                        }
                                                      },
                                                      isFormInput(el) {
                                                        if (el.localName && customElements.get(el.localName)) {
                                                          return customElements.get(el.localName)[`formAssociated`];
                                                        }
                                                        return /^(?:input|select|textarea)$/i.test(el.tagName) && el.type !== "button";
                                                      },
                                                      syncAttrsToProps(el) {
                                                        if (el instanceof HTMLInputElement && CHECKABLE_INPUTS.indexOf(el.type.toLocaleLowerCase()) >= 0) {
                                                          el.checked = el.getAttribute("checked") !== null;
                                                        }
                                                      },
                                                      isTextualInput(el) {
                                                        return FOCUSABLE_INPUTS.indexOf(el.type) >= 0;
                                                      },
                                                      isNowTriggerFormExternal(el, phxTriggerExternal) {
                                                        return el.getAttribute && el.getAttribute(phxTriggerExternal) !== null && document.body.contains(el);
                                                      },
                                                      cleanChildNodes(container, phxUpdate) {
                                                        if (DOM.isPhxUpdate(container, phxUpdate, ["append", "prepend", PHX_STREAM])) {
                                                          const toRemove = [];
                                                          container.childNodes.forEach((childNode) => {
                                                            if (!childNode.id) {
                                                              const isEmptyTextNode = childNode.nodeType === Node.TEXT_NODE && childNode.nodeValue.trim() === "";
                                                              if (!isEmptyTextNode && childNode.nodeType !== Node.COMMENT_NODE) {
                                                                logError(
                                                                  `only HTML element tags with an id are allowed inside containers with phx-update.

removing illegal node: "${(childNode.outerHTML || childNode.nodeValue).trim()}"

`
                                                                );
                                                              }
                                                              toRemove.push(childNode);
                                                            }
                                                          });
                                                          toRemove.forEach((childNode) => childNode.remove());
                                                        }
                                                      },
                                                      replaceRootContainer(container, tagName, attrs) {
                                                        const retainedAttrs = /* @__PURE__ */ new Set([
                                                          "id",
                                                          PHX_SESSION,
                                                          PHX_STATIC,
                                                          PHX_MAIN,
                                                          PHX_ROOT_ID
                                                        ]);
                                                        if (container.tagName.toLowerCase() === tagName.toLowerCase()) {
                                                          Array.from(container.attributes).filter((attr) => !retainedAttrs.has(attr.name.toLowerCase())).forEach((attr) => container.removeAttribute(attr.name));
                                                          Object.keys(attrs).filter((name) => !retainedAttrs.has(name.toLowerCase())).forEach((attr) => container.setAttribute(attr, attrs[attr]));
                                                          return container;
                                                        } else {
                                                          const newContainer = document.createElement(tagName);
                                                          Object.keys(attrs).forEach(
                                                            (attr) => newContainer.setAttribute(attr, attrs[attr])
                                                          );
                                                          retainedAttrs.forEach(
                                                            (attr) => newContainer.setAttribute(attr, container.getAttribute(attr))
                                                          );
                                                          newContainer.innerHTML = container.innerHTML;
                                                          container.replaceWith(newContainer);
                                                          return newContainer;
                                                        }
                                                      },
                                                      getSticky(el, name, defaultVal) {
                                                        const op = (DOM.private(el, "sticky") || []).find(
                                                          ([existingName]) => name === existingName
                                                        );
                                                        if (op) {
                                                          const [_name, _op, stashedResult] = op;
                                                          return stashedResult;
                                                        } else {
                                                          return typeof defaultVal === "function" ? defaultVal() : defaultVal;
                                                        }
                                                      },
                                                      deleteSticky(el, name) {
                                                        this.updatePrivate(el, "sticky", [], (ops) => {
                                                          return ops.filter(([existingName, _]) => existingName !== name);
                                                        });
                                                      },
                                                      putSticky(el, name, op) {
                                                        const stashedResult = op(el);
                                                        this.updatePrivate(el, "sticky", [], (ops) => {
                                                          const existingIndex = ops.findIndex(
                                                            ([existingName]) => name === existingName
                                                          );
                                                          if (existingIndex >= 0) {
                                                            ops[existingIndex] = [name, op, stashedResult];
                                                          } else {
                                                            ops.push([name, op, stashedResult]);
                                                          }
                                                          return ops;
                                                        });
                                                      },
                                                      applyStickyOperations(el) {
                                                        const ops = DOM.private(el, "sticky");
                                                        if (!ops) {
                                                          return;
                                                        }
                                                        ops.forEach(([name, op, _stashed]) => this.putSticky(el, name, op));
                                                      },
                                                      isLocked(el) {
                                                        return el.hasAttribute && el.hasAttribute(PHX_REF_LOCK);
                                                      },
                                                      attributeIgnored(attribute, ignoredAttributes) {
                                                        return ignoredAttributes.some(
                                                          (toIgnore) => attribute.name == toIgnore || toIgnore === "*" || toIgnore.includes("*") && attribute.name.match(toIgnore) != null
                                                        );
                                                      }
                                                    };
                                                    var dom_default = DOM;
                                                    var UploadEntry = class {
                                                      static isActive(fileEl, file) {
                                                        const isNew = file._phxRef === void 0;
                                                        const activeRefs = fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(",");
                                                        const isActive = activeRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;
                                                        return file.size > 0 && (isNew || isActive);
                                                      }
                                                      static isPreflighted(fileEl, file) {
                                                        const preflightedRefs = fileEl.getAttribute(PHX_PREFLIGHTED_REFS).split(",");
                                                        const isPreflighted = preflightedRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;
                                                        return isPreflighted && this.isActive(fileEl, file);
                                                      }
                                                      static isPreflightInProgress(file) {
                                                        return file._preflightInProgress === true;
                                                      }
                                                      static markPreflightInProgress(file) {
                                                        file._preflightInProgress = true;
                                                      }
                                                      constructor(fileEl, file, view, autoUpload) {
                                                        this.ref = LiveUploader.genFileRef(file);
                                                        this.fileEl = fileEl;
                                                        this.file = file;
                                                        this.view = view;
                                                        this.meta = null;
                                                        this._isCancelled = false;
                                                        this._isDone = false;
                                                        this._progress = 0;
                                                        this._lastProgressSent = -1;
                                                        this._onDone = function() {
                                                        };
                                                        this._onElUpdated = this.onElUpdated.bind(this);
                                                        this.fileEl.addEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
                                                        this.autoUpload = autoUpload;
                                                      }
                                                      metadata() {
                                                        return this.meta;
                                                      }
                                                      progress(progress) {
                                                        this._progress = Math.floor(progress);
                                                        if (this._progress > this._lastProgressSent) {
                                                          if (this._progress >= 100) {
                                                            this._progress = 100;
                                                            this._lastProgressSent = 100;
                                                            this._isDone = true;
                                                            this.view.pushFileProgress(this.fileEl, this.ref, 100, () => {
                                                              LiveUploader.untrackFile(this.fileEl, this.file);
                                                              this._onDone();
                                                            });
                                                          } else {
                                                            this._lastProgressSent = this._progress;
                                                            this.view.pushFileProgress(this.fileEl, this.ref, this._progress);
                                                          }
                                                        }
                                                      }
                                                      isCancelled() {
                                                        return this._isCancelled;
                                                      }
                                                      cancel() {
                                                        this.file._preflightInProgress = false;
                                                        this._isCancelled = true;
                                                        this._isDone = true;
                                                        this._onDone();
                                                      }
                                                      isDone() {
                                                        return this._isDone;
                                                      }
                                                      error(reason = "failed") {
                                                        this.fileEl.removeEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
                                                        this.view.pushFileProgress(this.fileEl, this.ref, { error: reason });
                                                        if (!this.isAutoUpload()) {
                                                          LiveUploader.clearFiles(this.fileEl);
                                                        }
                                                      }
                                                      isAutoUpload() {
                                                        return this.autoUpload;
                                                      }
                                                      //private
                                                      onDone(callback) {
                                                        this._onDone = () => {
                                                          this.fileEl.removeEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
                                                          callback();
                                                        };
                                                      }
                                                      onElUpdated() {
                                                        const activeRefs = this.fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(",");
                                                        if (activeRefs.indexOf(this.ref) === -1) {
                                                          LiveUploader.untrackFile(this.fileEl, this.file);
                                                          this.cancel();
                                                        }
                                                      }
                                                      toPreflightPayload() {
                                                        return {
                                                          last_modified: this.file.lastModified,
                                                          name: this.file.name,
                                                          relative_path: this.file.webkitRelativePath,
                                                          size: this.file.size,
                                                          type: this.file.type,
                                                          ref: this.ref,
                                                          meta: typeof this.file.meta === "function" ? this.file.meta() : void 0
                                                        };
                                                      }
                                                      uploader(uploaders) {
                                                        if (this.meta.uploader) {
                                                          const callback = uploaders[this.meta.uploader] || logError(`no uploader configured for ${this.meta.uploader}`);
                                                          return { name: this.meta.uploader, callback };
                                                        } else {
                                                          return { name: "channel", callback: channelUploader };
                                                        }
                                                      }
                                                      zipPostFlight(resp) {
                                                        this.meta = resp.entries[this.ref];
                                                        if (!this.meta) {
                                                          logError(`no preflight upload response returned with ref ${this.ref}`, {
                                                            input: this.fileEl,
                                                            response: resp
                                                          });
                                                        }
                                                      }
                                                    };
                                                    var liveUploaderFileRef = 0;
                                                    var LiveUploader = class _LiveUploader {
                                                      static genFileRef(file) {
                                                        const ref = file._phxRef;
                                                        if (ref !== void 0) {
                                                          return ref;
                                                        } else {
                                                          file._phxRef = (liveUploaderFileRef++).toString();
                                                          return file._phxRef;
                                                        }
                                                      }
                                                      static getEntryDataURL(inputEl, ref, callback) {
                                                        const file = this.activeFiles(inputEl).find(
                                                          (file2) => this.genFileRef(file2) === ref
                                                        );
                                                        callback(URL.createObjectURL(file));
                                                      }
                                                      static hasUploadsInProgress(formEl) {
                                                        let active = 0;
                                                        dom_default.findUploadInputs(formEl).forEach((input) => {
                                                          if (input.getAttribute(PHX_PREFLIGHTED_REFS) !== input.getAttribute(PHX_DONE_REFS)) {
                                                            active++;
                                                          }
                                                        });
                                                        return active > 0;
                                                      }
                                                      static serializeUploads(inputEl) {
                                                        const files = this.activeFiles(inputEl);
                                                        const fileData = {};
                                                        files.forEach((file) => {
                                                          const entry = { path: inputEl.name };
                                                          const uploadRef = inputEl.getAttribute(PHX_UPLOAD_REF);
                                                          fileData[uploadRef] = fileData[uploadRef] || [];
                                                          entry.ref = this.genFileRef(file);
                                                          entry.last_modified = file.lastModified;
                                                          entry.name = file.name || entry.ref;
                                                          entry.relative_path = file.webkitRelativePath;
                                                          entry.type = file.type;
                                                          entry.size = file.size;
                                                          if (typeof file.meta === "function") {
                                                            entry.meta = file.meta();
                                                          }
                                                          fileData[uploadRef].push(entry);
                                                        });
                                                        return fileData;
                                                      }
                                                      static clearFiles(inputEl) {
                                                        inputEl.value = null;
                                                        inputEl.removeAttribute(PHX_UPLOAD_REF);
                                                        dom_default.putPrivate(inputEl, "files", []);
                                                      }
                                                      static untrackFile(inputEl, file) {
                                                        dom_default.putPrivate(
                                                          inputEl,
                                                          "files",
                                                          dom_default.private(inputEl, "files").filter((f) => !Object.is(f, file))
                                                        );
                                                      }
                                                      /**
                                                       * @param {HTMLInputElement} inputEl
                                                       * @param {Array<File|Blob>} files
                                                       * @param {DataTransfer} [dataTransfer]
                                                       */
                                                      static trackFiles(inputEl, files, dataTransfer) {
                                                        if (inputEl.getAttribute("multiple") !== null) {
                                                          const newFiles = files.filter(
                                                            (file) => !this.activeFiles(inputEl).find((f) => Object.is(f, file))
                                                          );
                                                          dom_default.updatePrivate(
                                                            inputEl,
                                                            "files",
                                                            [],
                                                            (existing) => existing.concat(newFiles)
                                                          );
                                                          inputEl.value = null;
                                                        } else {
                                                          if (dataTransfer && dataTransfer.files.length > 0) {
                                                            inputEl.files = dataTransfer.files;
                                                          }
                                                          dom_default.putPrivate(inputEl, "files", files);
                                                        }
                                                      }
                                                      static activeFileInputs(formEl) {
                                                        const fileInputs = dom_default.findUploadInputs(formEl);
                                                        return Array.from(fileInputs).filter(
                                                          (el) => el.files && this.activeFiles(el).length > 0
                                                        );
                                                      }
                                                      static activeFiles(input) {
                                                        return (dom_default.private(input, "files") || []).filter(
                                                          (f) => UploadEntry.isActive(input, f)
                                                        );
                                                      }
                                                      static inputsAwaitingPreflight(formEl) {
                                                        const fileInputs = dom_default.findUploadInputs(formEl);
                                                        return Array.from(fileInputs).filter(
                                                          (input) => this.filesAwaitingPreflight(input).length > 0
                                                        );
                                                      }
                                                      static filesAwaitingPreflight(input) {
                                                        return this.activeFiles(input).filter(
                                                          (f) => !UploadEntry.isPreflighted(input, f) && !UploadEntry.isPreflightInProgress(f)
                                                        );
                                                      }
                                                      static markPreflightInProgress(entries) {
                                                        entries.forEach((entry) => UploadEntry.markPreflightInProgress(entry.file));
                                                      }
                                                      constructor(inputEl, view, onComplete) {
                                                        this.autoUpload = dom_default.isAutoUpload(inputEl);
                                                        this.view = view;
                                                        this.onComplete = onComplete;
                                                        this._entries = Array.from(
                                                          _LiveUploader.filesAwaitingPreflight(inputEl) || []
                                                        ).map((file) => new UploadEntry(inputEl, file, view, this.autoUpload));
                                                        _LiveUploader.markPreflightInProgress(this._entries);
                                                        this.numEntriesInProgress = this._entries.length;
                                                      }
                                                      isAutoUpload() {
                                                        return this.autoUpload;
                                                      }
                                                      entries() {
                                                        return this._entries;
                                                      }
                                                      initAdapterUpload(resp, onError, liveSocket2) {
                                                        this._entries = this._entries.map((entry) => {
                                                          if (entry.isCancelled()) {
                                                            this.numEntriesInProgress--;
                                                            if (this.numEntriesInProgress === 0) {
                                                              this.onComplete();
                                                            }
                                                          } else {
                                                            entry.zipPostFlight(resp);
                                                            entry.onDone(() => {
                                                              this.numEntriesInProgress--;
                                                              if (this.numEntriesInProgress === 0) {
                                                                this.onComplete();
                                                              }
                                                            });
                                                          }
                                                          return entry;
                                                        });
                                                        const groupedEntries = this._entries.reduce((acc, entry) => {
                                                          if (!entry.meta) {
                                                            return acc;
                                                          }
                                                          const { name, callback } = entry.uploader(liveSocket2.uploaders);
                                                          acc[name] = acc[name] || { callback, entries: [] };
                                                          acc[name].entries.push(entry);
                                                          return acc;
                                                        }, {});
                                                        for (const name in groupedEntries) {
                                                          const { callback, entries } = groupedEntries[name];
                                                          callback(entries, onError, resp, liveSocket2);
                                                        }
                                                      }
                                                    };
                                                    var ARIA = {
                                                      anyOf(instance, classes) {
                                                        return classes.find((name) => instance instanceof name);
                                                      },
                                                      isFocusable(el, interactiveOnly) {
                                                        return el instanceof HTMLAnchorElement && el.rel !== "ignore" || el instanceof HTMLAreaElement && el.href !== void 0 || !el.disabled && this.anyOf(el, [
                                                          HTMLInputElement,
                                                          HTMLSelectElement,
                                                          HTMLTextAreaElement,
                                                          HTMLButtonElement
                                                        ]) || el instanceof HTMLIFrameElement || el.tabIndex >= 0 && el.getAttribute("aria-hidden") !== "true" || !interactiveOnly && el.getAttribute("tabindex") !== null && el.getAttribute("aria-hidden") !== "true";
                                                      },
                                                      attemptFocus(el, interactiveOnly) {
                                                        if (this.isFocusable(el, interactiveOnly)) {
                                                          try {
                                                            el.focus();
                                                          } catch {
                                                          }
                                                        }
                                                        return !!document.activeElement && document.activeElement.isSameNode(el);
                                                      },
                                                      focusFirstInteractive(el) {
                                                        let child = el.firstElementChild;
                                                        while (child) {
                                                          if (this.attemptFocus(child, true) || this.focusFirstInteractive(child)) {
                                                            return true;
                                                          }
                                                          child = child.nextElementSibling;
                                                        }
                                                      },
                                                      focusFirst(el) {
                                                        let child = el.firstElementChild;
                                                        while (child) {
                                                          if (this.attemptFocus(child) || this.focusFirst(child)) {
                                                            return true;
                                                          }
                                                          child = child.nextElementSibling;
                                                        }
                                                      },
                                                      focusLast(el) {
                                                        let child = el.lastElementChild;
                                                        while (child) {
                                                          if (this.attemptFocus(child) || this.focusLast(child)) {
                                                            return true;
                                                          }
                                                          child = child.previousElementSibling;
                                                        }
                                                      }
                                                    };
                                                    var aria_default = ARIA;
                                                    var Hooks = {
                                                      LiveFileUpload: {
                                                        activeRefs() {
                                                          return this.el.getAttribute(PHX_ACTIVE_ENTRY_REFS);
                                                        },
                                                        preflightedRefs() {
                                                          return this.el.getAttribute(PHX_PREFLIGHTED_REFS);
                                                        },
                                                        mounted() {
                                                          this.js().ignoreAttributes(this.el, ["value"]);
                                                          this.preflightedWas = this.preflightedRefs();
                                                        },
                                                        updated() {
                                                          const newPreflights = this.preflightedRefs();
                                                          if (this.preflightedWas !== newPreflights) {
                                                            this.preflightedWas = newPreflights;
                                                            if (newPreflights === "") {
                                                              this.__view().cancelSubmit(this.el.form);
                                                            }
                                                          }
                                                          if (this.activeRefs() === "") {
                                                            this.el.value = null;
                                                          }
                                                          this.el.dispatchEvent(new CustomEvent(PHX_LIVE_FILE_UPDATED));
                                                        }
                                                      },
                                                      LiveImgPreview: {
                                                        mounted() {
                                                          this.ref = this.el.getAttribute("data-phx-entry-ref");
                                                          this.inputEl = document.getElementById(
                                                            this.el.getAttribute(PHX_UPLOAD_REF)
                                                          );
                                                          LiveUploader.getEntryDataURL(this.inputEl, this.ref, (url) => {
                                                            this.url = url;
                                                            this.el.src = url;
                                                          });
                                                        },
                                                        destroyed() {
                                                          URL.revokeObjectURL(this.url);
                                                        }
                                                      },
                                                      FocusWrap: {
                                                        mounted() {
                                                          this.focusStart = this.el.firstElementChild;
                                                          this.focusEnd = this.el.lastElementChild;
                                                          this.focusStart.addEventListener("focus", (e) => {
                                                            if (!e.relatedTarget || !this.el.contains(e.relatedTarget)) {
                                                              const nextFocus = e.target.nextElementSibling;
                                                              aria_default.attemptFocus(nextFocus) || aria_default.focusFirst(nextFocus);
                                                            } else {
                                                              aria_default.focusLast(this.el);
                                                            }
                                                          });
                                                          this.focusEnd.addEventListener("focus", (e) => {
                                                            if (!e.relatedTarget || !this.el.contains(e.relatedTarget)) {
                                                              const nextFocus = e.target.previousElementSibling;
                                                              aria_default.attemptFocus(nextFocus) || aria_default.focusLast(nextFocus);
                                                            } else {
                                                              aria_default.focusFirst(this.el);
                                                            }
                                                          });
                                                          if (!this.el.contains(document.activeElement)) {
                                                            this.el.addEventListener("phx:show-end", () => this.el.focus());
                                                            if (window.getComputedStyle(this.el).display !== "none") {
                                                              aria_default.focusFirst(this.el);
                                                            }
                                                          }
                                                        }
                                                      }
                                                    };
                                                    var findScrollContainer = (el) => {
                                                      if (["HTML", "BODY"].indexOf(el.nodeName.toUpperCase()) >= 0)
                                                        return null;
                                                      if (["scroll", "auto"].indexOf(getComputedStyle(el).overflowY) >= 0)
                                                        return el;
                                                      return findScrollContainer(el.parentElement);
                                                    };
                                                    var scrollTop = (scrollContainer) => {
                                                      if (scrollContainer) {
                                                        return scrollContainer.scrollTop;
                                                      } else {
                                                        return document.documentElement.scrollTop || document.body.scrollTop;
                                                      }
                                                    };
                                                    var bottom = (scrollContainer) => {
                                                      if (scrollContainer) {
                                                        return scrollContainer.getBoundingClientRect().bottom;
                                                      } else {
                                                        return window.innerHeight || document.documentElement.clientHeight;
                                                      }
                                                    };
                                                    var top = (scrollContainer) => {
                                                      if (scrollContainer) {
                                                        return scrollContainer.getBoundingClientRect().top;
                                                      } else {
                                                        return 0;
                                                      }
                                                    };
                                                    var isAtViewportTop = (el, scrollContainer) => {
                                                      const rect = el.getBoundingClientRect();
                                                      return Math.ceil(rect.top) >= top(scrollContainer) && Math.ceil(rect.left) >= 0 && Math.floor(rect.top) <= bottom(scrollContainer);
                                                    };
                                                    var isAtViewportBottom = (el, scrollContainer) => {
                                                      const rect = el.getBoundingClientRect();
                                                      return Math.ceil(rect.bottom) >= top(scrollContainer) && Math.ceil(rect.left) >= 0 && Math.floor(rect.bottom) <= bottom(scrollContainer);
                                                    };
                                                    var isWithinViewport = (el, scrollContainer) => {
                                                      const rect = el.getBoundingClientRect();
                                                      return Math.ceil(rect.top) >= top(scrollContainer) && Math.ceil(rect.left) >= 0 && Math.floor(rect.top) <= bottom(scrollContainer);
                                                    };
                                                    Hooks.InfiniteScroll = {
                                                      mounted() {
                                                        this.scrollContainer = findScrollContainer(this.el);
                                                        let scrollBefore = scrollTop(this.scrollContainer);
                                                        let topOverran = false;
                                                        const throttleInterval = 500;
                                                        let pendingOp = null;
                                                        const onTopOverrun = this.throttle(
                                                          throttleInterval,
                                                          (topEvent, firstChild) => {
                                                            pendingOp = () => true;
                                                            this.liveSocket.js().push(this.el, topEvent, {
                                                              value: { id: firstChild.id, _overran: true },
                                                              callback: () => {
                                                                pendingOp = null;
                                                              }
                                                            });
                                                          }
                                                        );
                                                        const onFirstChildAtTop = this.throttle(
                                                          throttleInterval,
                                                          (topEvent, firstChild) => {
                                                            pendingOp = () => firstChild.scrollIntoView({ block: "start" });
                                                            this.liveSocket.js().push(this.el, topEvent, {
                                                              value: { id: firstChild.id },
                                                              callback: () => {
                                                                pendingOp = null;
                                                                window.requestAnimationFrame(() => {
                                                                  if (!isWithinViewport(firstChild, this.scrollContainer)) {
                                                                    firstChild.scrollIntoView({ block: "start" });
                                                                  }
                                                                });
                                                              }
                                                            });
                                                          }
                                                        );
                                                        const onLastChildAtBottom = this.throttle(
                                                          throttleInterval,
                                                          (bottomEvent, lastChild) => {
                                                            pendingOp = () => lastChild.scrollIntoView({ block: "end" });
                                                            this.liveSocket.js().push(this.el, bottomEvent, {
                                                              value: { id: lastChild.id },
                                                              callback: () => {
                                                                pendingOp = null;
                                                                window.requestAnimationFrame(() => {
                                                                  if (!isWithinViewport(lastChild, this.scrollContainer)) {
                                                                    lastChild.scrollIntoView({ block: "end" });
                                                                  }
                                                                });
                                                              }
                                                            });
                                                          }
                                                        );
                                                        this.onScroll = (_e) => {
                                                          const scrollNow = scrollTop(this.scrollContainer);
                                                          if (pendingOp) {
                                                            scrollBefore = scrollNow;
                                                            return pendingOp();
                                                          }
                                                          const rect = this.findOverrunTarget();
                                                          const topEvent = this.el.getAttribute(
                                                            this.liveSocket.binding("viewport-top")
                                                          );
                                                          const bottomEvent = this.el.getAttribute(
                                                            this.liveSocket.binding("viewport-bottom")
                                                          );
                                                          const lastChild = this.el.lastElementChild;
                                                          const firstChild = this.el.firstElementChild;
                                                          const isScrollingUp = scrollNow < scrollBefore;
                                                          const isScrollingDown = scrollNow > scrollBefore;
                                                          if (isScrollingUp && topEvent && !topOverran && rect.top >= 0) {
                                                            topOverran = true;
                                                            onTopOverrun(topEvent, firstChild);
                                                          } else if (isScrollingDown && topOverran && rect.top <= 0) {
                                                            topOverran = false;
                                                          }
                                                          if (topEvent && isScrollingUp && isAtViewportTop(firstChild, this.scrollContainer)) {
                                                            onFirstChildAtTop(topEvent, firstChild);
                                                          } else if (bottomEvent && isScrollingDown && isAtViewportBottom(lastChild, this.scrollContainer)) {
                                                            onLastChildAtBottom(bottomEvent, lastChild);
                                                          }
                                                          scrollBefore = scrollNow;
                                                        };
                                                        if (this.scrollContainer) {
                                                          this.scrollContainer.addEventListener("scroll", this.onScroll);
                                                        } else {
                                                          window.addEventListener("scroll", this.onScroll);
                                                        }
                                                      },
                                                      destroyed() {
                                                        if (this.scrollContainer) {
                                                          this.scrollContainer.removeEventListener("scroll", this.onScroll);
                                                        } else {
                                                          window.removeEventListener("scroll", this.onScroll);
                                                        }
                                                      },
                                                      throttle(interval, callback) {
                                                        let lastCallAt = 0;
                                                        let timer;
                                                        return (...args) => {
                                                          const now = Date.now();
                                                          const remainingTime = interval - (now - lastCallAt);
                                                          if (remainingTime <= 0 || remainingTime > interval) {
                                                            if (timer) {
                                                              clearTimeout(timer);
                                                              timer = null;
                                                            }
                                                            lastCallAt = now;
                                                            callback(...args);
                                                          } else if (!timer) {
                                                            timer = setTimeout(() => {
                                                              lastCallAt = Date.now();
                                                              timer = null;
                                                              callback(...args);
                                                            }, remainingTime);
                                                          }
                                                        };
                                                      },
                                                      findOverrunTarget() {
                                                        let rect;
                                                        const overrunTarget = this.el.getAttribute(
                                                          this.liveSocket.binding(PHX_VIEWPORT_OVERRUN_TARGET)
                                                        );
                                                        if (overrunTarget) {
                                                          const overrunEl = document.getElementById(overrunTarget);
                                                          if (overrunEl) {
                                                            rect = overrunEl.getBoundingClientRect();
                                                          } else {
                                                            throw new Error("did not find element with id " + overrunTarget);
                                                          }
                                                        } else {
                                                          rect = this.el.getBoundingClientRect();
                                                        }
                                                        return rect;
                                                      }
                                                    };
                                                    var hooks_default = Hooks;
                                                    var ElementRef = class {
                                                      static onUnlock(el, callback) {
                                                        if (!dom_default.isLocked(el) && !el.closest(`[${PHX_REF_LOCK}]`)) {
                                                          return callback();
                                                        }
                                                        const closestLock = el.closest(`[${PHX_REF_LOCK}]`);
                                                        const ref = closestLock.closest(`[${PHX_REF_LOCK}]`).getAttribute(PHX_REF_LOCK);
                                                        closestLock.addEventListener(
                                                          `phx:undo-lock:${ref}`,
                                                          () => {
                                                            callback();
                                                          },
                                                          { once: true }
                                                        );
                                                      }
                                                      constructor(el) {
                                                        this.el = el;
                                                        this.loadingRef = el.hasAttribute(PHX_REF_LOADING) ? parseInt(el.getAttribute(PHX_REF_LOADING), 10) : null;
                                                        this.lockRef = el.hasAttribute(PHX_REF_LOCK) ? parseInt(el.getAttribute(PHX_REF_LOCK), 10) : null;
                                                      }
                                                      // public
                                                      maybeUndo(ref, phxEvent, eachCloneCallback) {
                                                        if (!this.isWithin(ref)) {
                                                          dom_default.updatePrivate(this.el, PHX_PENDING_REFS, [], (pendingRefs) => {
                                                            pendingRefs.push(ref);
                                                            return pendingRefs;
                                                          });
                                                          return;
                                                        }
                                                        this.undoLocks(ref, phxEvent, eachCloneCallback);
                                                        this.undoLoading(ref, phxEvent);
                                                        dom_default.updatePrivate(this.el, PHX_PENDING_REFS, [], (pendingRefs) => {
                                                          return pendingRefs.filter((pendingRef) => {
                                                            let opts = {
                                                              detail: { ref: pendingRef, event: phxEvent },
                                                              bubbles: true,
                                                              cancelable: false
                                                            };
                                                            if (this.loadingRef && this.loadingRef > pendingRef) {
                                                              this.el.dispatchEvent(
                                                                new CustomEvent(`phx:undo-loading:${pendingRef}`, opts)
                                                              );
                                                            }
                                                            if (this.lockRef && this.lockRef > pendingRef) {
                                                              this.el.dispatchEvent(
                                                                new CustomEvent(`phx:undo-lock:${pendingRef}`, opts)
                                                              );
                                                            }
                                                            return pendingRef > ref;
                                                          });
                                                        });
                                                        if (this.isFullyResolvedBy(ref)) {
                                                          this.el.removeAttribute(PHX_REF_SRC);
                                                        }
                                                      }
                                                      // private
                                                      isWithin(ref) {
                                                        return !(this.loadingRef !== null && this.loadingRef > ref && this.lockRef !== null && this.lockRef > ref);
                                                      }
                                                      // Check for cloned PHX_REF_LOCK element that has been morphed behind
                                                      // the scenes while this element was locked in the DOM.
                                                      // When we apply the cloned tree to the active DOM element, we must
                                                      //
                                                      //   1. execute pending mounted hooks for nodes now in the DOM
                                                      //   2. undo any ref inside the cloned tree that has since been ack'd
                                                      undoLocks(ref, phxEvent, eachCloneCallback) {
                                                        if (!this.isLockUndoneBy(ref)) {
                                                          return;
                                                        }
                                                        const clonedTree = dom_default.private(this.el, PHX_REF_LOCK);
                                                        if (clonedTree) {
                                                          eachCloneCallback(clonedTree);
                                                          dom_default.deletePrivate(this.el, PHX_REF_LOCK);
                                                        }
                                                        this.el.removeAttribute(PHX_REF_LOCK);
                                                        const opts = {
                                                          detail: { ref, event: phxEvent },
                                                          bubbles: true,
                                                          cancelable: false
                                                        };
                                                        this.el.dispatchEvent(
                                                          new CustomEvent(`phx:undo-lock:${this.lockRef}`, opts)
                                                        );
                                                      }
                                                      undoLoading(ref, phxEvent) {
                                                        if (!this.isLoadingUndoneBy(ref)) {
                                                          if (this.canUndoLoading(ref) && this.el.classList.contains("phx-submit-loading")) {
                                                            this.el.classList.remove("phx-change-loading");
                                                          }
                                                          return;
                                                        }
                                                        if (this.canUndoLoading(ref)) {
                                                          this.el.removeAttribute(PHX_REF_LOADING);
                                                          const disabledVal = this.el.getAttribute(PHX_DISABLED);
                                                          const readOnlyVal = this.el.getAttribute(PHX_READONLY);
                                                          if (readOnlyVal !== null) {
                                                            this.el.readOnly = readOnlyVal === "true" ? true : false;
                                                            this.el.removeAttribute(PHX_READONLY);
                                                          }
                                                          if (disabledVal !== null) {
                                                            this.el.disabled = disabledVal === "true" ? true : false;
                                                            this.el.removeAttribute(PHX_DISABLED);
                                                          }
                                                          const disableRestore = this.el.getAttribute(PHX_DISABLE_WITH_RESTORE);
                                                          if (disableRestore !== null) {
                                                            this.el.textContent = disableRestore;
                                                            this.el.removeAttribute(PHX_DISABLE_WITH_RESTORE);
                                                          }
                                                          const opts = {
                                                            detail: { ref, event: phxEvent },
                                                            bubbles: true,
                                                            cancelable: false
                                                          };
                                                          this.el.dispatchEvent(
                                                            new CustomEvent(`phx:undo-loading:${this.loadingRef}`, opts)
                                                          );
                                                        }
                                                        PHX_EVENT_CLASSES.forEach((name) => {
                                                          if (name !== "phx-submit-loading" || this.canUndoLoading(ref)) {
                                                            dom_default.removeClass(this.el, name);
                                                          }
                                                        });
                                                      }
                                                      isLoadingUndoneBy(ref) {
                                                        return this.loadingRef === null ? false : this.loadingRef <= ref;
                                                      }
                                                      isLockUndoneBy(ref) {
                                                        return this.lockRef === null ? false : this.lockRef <= ref;
                                                      }
                                                      isFullyResolvedBy(ref) {
                                                        return (this.loadingRef === null || this.loadingRef <= ref) && (this.lockRef === null || this.lockRef <= ref);
                                                      }
                                                      // only remove the phx-submit-loading class if we are not locked
                                                      canUndoLoading(ref) {
                                                        return this.lockRef === null || this.lockRef <= ref;
                                                      }
                                                    };
                                                    var DOMPostMorphRestorer = class {
                                                      constructor(containerBefore, containerAfter, updateType) {
                                                        const idsBefore = /* @__PURE__ */ new Set();
                                                        const idsAfter = new Set(
                                                          [...containerAfter.children].map((child) => child.id)
                                                        );
                                                        const elementsToModify = [];
                                                        Array.from(containerBefore.children).forEach((child) => {
                                                          if (child.id) {
                                                            idsBefore.add(child.id);
                                                            if (idsAfter.has(child.id)) {
                                                              const previousElementId = child.previousElementSibling && child.previousElementSibling.id;
                                                              elementsToModify.push({
                                                                elementId: child.id,
                                                                previousElementId
                                                              });
                                                            }
                                                          }
                                                        });
                                                        this.containerId = containerAfter.id;
                                                        this.updateType = updateType;
                                                        this.elementsToModify = elementsToModify;
                                                        this.elementIdsToAdd = [...idsAfter].filter((id) => !idsBefore.has(id));
                                                      }
                                                      // We do the following to optimize append/prepend operations:
                                                      //   1) Track ids of modified elements & of new elements
                                                      //   2) All the modified elements are put back in the correct position in the DOM tree
                                                      //      by storing the id of their previous sibling
                                                      //   3) New elements are going to be put in the right place by morphdom during append.
                                                      //      For prepend, we move them to the first position in the container
                                                      perform() {
                                                        const container = dom_default.byId(this.containerId);
                                                        if (!container) {
                                                          return;
                                                        }
                                                        this.elementsToModify.forEach((elementToModify) => {
                                                          if (elementToModify.previousElementId) {
                                                            maybe(
                                                              document.getElementById(elementToModify.previousElementId),
                                                              (previousElem) => {
                                                                maybe(
                                                                  document.getElementById(elementToModify.elementId),
                                                                  (elem) => {
                                                                    const isInRightPlace = elem.previousElementSibling && elem.previousElementSibling.id == previousElem.id;
                                                                    if (!isInRightPlace) {
                                                                      previousElem.insertAdjacentElement("afterend", elem);
                                                                    }
                                                                  }
                                                                );
                                                              }
                                                            );
                                                          } else {
                                                            maybe(document.getElementById(elementToModify.elementId), (elem) => {
                                                              const isInRightPlace = elem.previousElementSibling == null;
                                                              if (!isInRightPlace) {
                                                                container.insertAdjacentElement("afterbegin", elem);
                                                              }
                                                            });
                                                          }
                                                        });
                                                        if (this.updateType == "prepend") {
                                                          this.elementIdsToAdd.reverse().forEach((elemId) => {
                                                            maybe(
                                                              document.getElementById(elemId),
                                                              (elem) => container.insertAdjacentElement("afterbegin", elem)
                                                            );
                                                          });
                                                        }
                                                      }
                                                    };
                                                    var DOCUMENT_FRAGMENT_NODE = 11;
                                                    function morphAttrs(fromNode, toNode) {
                                                      var toNodeAttrs = toNode.attributes;
                                                      var attr;
                                                      var attrName;
                                                      var attrNamespaceURI;
                                                      var attrValue;
                                                      var fromValue;
                                                      if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {
                                                        return;
                                                      }
                                                      for (var i = toNodeAttrs.length - 1; i >= 0; i--) {
                                                        attr = toNodeAttrs[i];
                                                        attrName = attr.name;
                                                        attrNamespaceURI = attr.namespaceURI;
                                                        attrValue = attr.value;
                                                        if (attrNamespaceURI) {
                                                          attrName = attr.localName || attrName;
                                                          fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);
                                                          if (fromValue !== attrValue) {
                                                            if (attr.prefix === "xmlns") {
                                                              attrName = attr.name;
                                                            }
                                                            fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);
                                                          }
                                                        } else {
                                                          fromValue = fromNode.getAttribute(attrName);
                                                          if (fromValue !== attrValue) {
                                                            fromNode.setAttribute(attrName, attrValue);
                                                          }
                                                        }
                                                      }
                                                      var fromNodeAttrs = fromNode.attributes;
                                                      for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {
                                                        attr = fromNodeAttrs[d];
                                                        attrName = attr.name;
                                                        attrNamespaceURI = attr.namespaceURI;
                                                        if (attrNamespaceURI) {
                                                          attrName = attr.localName || attrName;
                                                          if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {
                                                            fromNode.removeAttributeNS(attrNamespaceURI, attrName);
                                                          }
                                                        } else {
                                                          if (!toNode.hasAttribute(attrName)) {
                                                            fromNode.removeAttribute(attrName);
                                                          }
                                                        }
                                                      }
                                                    }
                                                    var range;
                                                    var NS_XHTML = "http://www.w3.org/1999/xhtml";
                                                    var doc = typeof document === "undefined" ? void 0 : document;
                                                    var HAS_TEMPLATE_SUPPORT = !!doc && "content" in doc.createElement("template");
                                                    var HAS_RANGE_SUPPORT = !!doc && doc.createRange && "createContextualFragment" in doc.createRange();
                                                    function createFragmentFromTemplate(str) {
                                                      var template = doc.createElement("template");
                                                      template.innerHTML = str;
                                                      return template.content.childNodes[0];
                                                    }
                                                    function createFragmentFromRange(str) {
                                                      if (!range) {
                                                        range = doc.createRange();
                                                        range.selectNode(doc.body);
                                                      }
                                                      var fragment = range.createContextualFragment(str);
                                                      return fragment.childNodes[0];
                                                    }
                                                    function createFragmentFromWrap(str) {
                                                      var fragment = doc.createElement("body");
                                                      fragment.innerHTML = str;
                                                      return fragment.childNodes[0];
                                                    }
                                                    function toElement(str) {
                                                      str = str.trim();
                                                      if (HAS_TEMPLATE_SUPPORT) {
                                                        return createFragmentFromTemplate(str);
                                                      } else if (HAS_RANGE_SUPPORT) {
                                                        return createFragmentFromRange(str);
                                                      }
                                                      return createFragmentFromWrap(str);
                                                    }
                                                    function compareNodeNames(fromEl, toEl) {
                                                      var fromNodeName = fromEl.nodeName;
                                                      var toNodeName = toEl.nodeName;
                                                      var fromCodeStart, toCodeStart;
                                                      if (fromNodeName === toNodeName) {
                                                        return true;
                                                      }
                                                      fromCodeStart = fromNodeName.charCodeAt(0);
                                                      toCodeStart = toNodeName.charCodeAt(0);
                                                      if (fromCodeStart <= 90 && toCodeStart >= 97) {
                                                        return fromNodeName === toNodeName.toUpperCase();
                                                      } else if (toCodeStart <= 90 && fromCodeStart >= 97) {
                                                        return toNodeName === fromNodeName.toUpperCase();
                                                      } else {
                                                        return false;
                                                      }
                                                    }
                                                    function createElementNS(name, namespaceURI) {
                                                      return !namespaceURI || namespaceURI === NS_XHTML ? doc.createElement(name) : doc.createElementNS(namespaceURI, name);
                                                    }
                                                    function moveChildren(fromEl, toEl) {
                                                      var curChild = fromEl.firstChild;
                                                      while (curChild) {
                                                        var nextChild = curChild.nextSibling;
                                                        toEl.appendChild(curChild);
                                                        curChild = nextChild;
                                                      }
                                                      return toEl;
                                                    }
                                                    function syncBooleanAttrProp(fromEl, toEl, name) {
                                                      if (fromEl[name] !== toEl[name]) {
                                                        fromEl[name] = toEl[name];
                                                        if (fromEl[name]) {
                                                          fromEl.setAttribute(name, "");
                                                        } else {
                                                          fromEl.removeAttribute(name);
                                                        }
                                                      }
                                                    }
                                                    var specialElHandlers = {
                                                      OPTION: function(fromEl, toEl) {
                                                        var parentNode = fromEl.parentNode;
                                                        if (parentNode) {
                                                          var parentName = parentNode.nodeName.toUpperCase();
                                                          if (parentName === "OPTGROUP") {
                                                            parentNode = parentNode.parentNode;
                                                            parentName = parentNode && parentNode.nodeName.toUpperCase();
                                                          }
                                                          if (parentName === "SELECT" && !parentNode.hasAttribute("multiple")) {
                                                            if (fromEl.hasAttribute("selected") && !toEl.selected) {
                                                              fromEl.setAttribute("selected", "selected");
                                                              fromEl.removeAttribute("selected");
                                                            }
                                                            parentNode.selectedIndex = -1;
                                                          }
                                                        }
                                                        syncBooleanAttrProp(fromEl, toEl, "selected");
                                                      },
                                                      /**
                                                       * The "value" attribute is special for the <input> element since it sets
                                                       * the initial value. Changing the "value" attribute without changing the
                                                       * "value" property will have no effect since it is only used to the set the
                                                       * initial value.  Similar for the "checked" attribute, and "disabled".
                                                       */
                                                      INPUT: function(fromEl, toEl) {
                                                        syncBooleanAttrProp(fromEl, toEl, "checked");
                                                        syncBooleanAttrProp(fromEl, toEl, "disabled");
                                                        if (fromEl.value !== toEl.value) {
                                                          fromEl.value = toEl.value;
                                                        }
                                                        if (!toEl.hasAttribute("value")) {
                                                          fromEl.removeAttribute("value");
                                                        }
                                                      },
                                                      TEXTAREA: function(fromEl, toEl) {
                                                        var newValue = toEl.value;
                                                        if (fromEl.value !== newValue) {
                                                          fromEl.value = newValue;
                                                        }
                                                        var firstChild = fromEl.firstChild;
                                                        if (firstChild) {
                                                          var oldValue = firstChild.nodeValue;
                                                          if (oldValue == newValue || !newValue && oldValue == fromEl.placeholder) {
                                                            return;
                                                          }
                                                          firstChild.nodeValue = newValue;
                                                        }
                                                      },
                                                      SELECT: function(fromEl, toEl) {
                                                        if (!toEl.hasAttribute("multiple")) {
                                                          var selectedIndex = -1;
                                                          var i = 0;
                                                          var curChild = fromEl.firstChild;
                                                          var optgroup;
                                                          var nodeName;
                                                          while (curChild) {
                                                            nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();
                                                            if (nodeName === "OPTGROUP") {
                                                              optgroup = curChild;
                                                              curChild = optgroup.firstChild;
                                                              if (!curChild) {
                                                                curChild = optgroup.nextSibling;
                                                                optgroup = null;
                                                              }
                                                            } else {
                                                              if (nodeName === "OPTION") {
                                                                if (curChild.hasAttribute("selected")) {
                                                                  selectedIndex = i;
                                                                  break;
                                                                }
                                                                i++;
                                                              }
                                                              curChild = curChild.nextSibling;
                                                              if (!curChild && optgroup) {
                                                                curChild = optgroup.nextSibling;
                                                                optgroup = null;
                                                              }
                                                            }
                                                          }
                                                          fromEl.selectedIndex = selectedIndex;
                                                        }
                                                      }
                                                    };
                                                    var ELEMENT_NODE = 1;
                                                    var DOCUMENT_FRAGMENT_NODE$1 = 11;
                                                    var TEXT_NODE = 3;
                                                    var COMMENT_NODE = 8;
                                                    function noop() {
                                                    }
                                                    function defaultGetNodeKey(node) {
                                                      if (node) {
                                                        return node.getAttribute && node.getAttribute("id") || node.id;
                                                      }
                                                    }
                                                    function morphdomFactory(morphAttrs2) {
                                                      return function morphdom2(fromNode, toNode, options) {
                                                        if (!options) {
                                                          options = {};
                                                        }
                                                        if (typeof toNode === "string") {
                                                          if (fromNode.nodeName === "#document" || fromNode.nodeName === "HTML") {
                                                            var toNodeHtml = toNode;
                                                            toNode = doc.createElement("html");
                                                            toNode.innerHTML = toNodeHtml;
                                                          } else if (fromNode.nodeName === "BODY") {
                                                            var toNodeBody = toNode;
                                                            toNode = doc.createElement("html");
                                                            toNode.innerHTML = toNodeBody;
                                                            var bodyElement = toNode.querySelector("body");
                                                            if (bodyElement) {
                                                              toNode = bodyElement;
                                                            }
                                                          } else {
                                                            toNode = toElement(toNode);
                                                          }
                                                        } else if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE$1) {
                                                          toNode = toNode.firstElementChild;
                                                        }
                                                        var getNodeKey = options.getNodeKey || defaultGetNodeKey;
                                                        var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;
                                                        var onNodeAdded = options.onNodeAdded || noop;
                                                        var onBeforeElUpdated = options.onBeforeElUpdated || noop;
                                                        var onElUpdated = options.onElUpdated || noop;
                                                        var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;
                                                        var onNodeDiscarded = options.onNodeDiscarded || noop;
                                                        var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;
                                                        var skipFromChildren = options.skipFromChildren || noop;
                                                        var addChild = options.addChild || function(parent, child) {
                                                          return parent.appendChild(child);
                                                        };
                                                        var childrenOnly = options.childrenOnly === true;
                                                        var fromNodesLookup = /* @__PURE__ */ Object.create(null);
                                                        var keyedRemovalList = [];
                                                        function addKeyedRemoval(key) {
                                                          keyedRemovalList.push(key);
                                                        }
                                                        function walkDiscardedChildNodes(node, skipKeyedNodes) {
                                                          if (node.nodeType === ELEMENT_NODE) {
                                                            var curChild = node.firstChild;
                                                            while (curChild) {
                                                              var key = void 0;
                                                              if (skipKeyedNodes && (key = getNodeKey(curChild))) {
                                                                addKeyedRemoval(key);
                                                              } else {
                                                                onNodeDiscarded(curChild);
                                                                if (curChild.firstChild) {
                                                                  walkDiscardedChildNodes(curChild, skipKeyedNodes);
                                                                }
                                                              }
                                                              curChild = curChild.nextSibling;
                                                            }
                                                          }
                                                        }
                                                        function removeNode(node, parentNode, skipKeyedNodes) {
                                                          if (onBeforeNodeDiscarded(node) === false) {
                                                            return;
                                                          }
                                                          if (parentNode) {
                                                            parentNode.removeChild(node);
                                                          }
                                                          onNodeDiscarded(node);
                                                          walkDiscardedChildNodes(node, skipKeyedNodes);
                                                        }
                                                        function indexTree(node) {
                                                          if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {
                                                            var curChild = node.firstChild;
                                                            while (curChild) {
                                                              var key = getNodeKey(curChild);
                                                              if (key) {
                                                                fromNodesLookup[key] = curChild;
                                                              }
                                                              indexTree(curChild);
                                                              curChild = curChild.nextSibling;
                                                            }
                                                          }
                                                        }
                                                        indexTree(fromNode);
                                                        function handleNodeAdded(el) {
                                                          onNodeAdded(el);
                                                          var curChild = el.firstChild;
                                                          while (curChild) {
                                                            var nextSibling = curChild.nextSibling;
                                                            var key = getNodeKey(curChild);
                                                            if (key) {
                                                              var unmatchedFromEl = fromNodesLookup[key];
                                                              if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {
                                                                curChild.parentNode.replaceChild(unmatchedFromEl, curChild);
                                                                morphEl(unmatchedFromEl, curChild);
                                                              } else {
                                                                handleNodeAdded(curChild);
                                                              }
                                                            } else {
                                                              handleNodeAdded(curChild);
                                                            }
                                                            curChild = nextSibling;
                                                          }
                                                        }
                                                        function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {
                                                          while (curFromNodeChild) {
                                                            var fromNextSibling = curFromNodeChild.nextSibling;
                                                            if (curFromNodeKey = getNodeKey(curFromNodeChild)) {
                                                              addKeyedRemoval(curFromNodeKey);
                                                            } else {
                                                              removeNode(
                                                                curFromNodeChild,
                                                                fromEl,
                                                                true
                                                                /* skip keyed nodes */
                                                              );
                                                            }
                                                            curFromNodeChild = fromNextSibling;
                                                          }
                                                        }
                                                        function morphEl(fromEl, toEl, childrenOnly2) {
                                                          var toElKey = getNodeKey(toEl);
                                                          if (toElKey) {
                                                            delete fromNodesLookup[toElKey];
                                                          }
                                                          if (!childrenOnly2) {
                                                            var beforeUpdateResult = onBeforeElUpdated(fromEl, toEl);
                                                            if (beforeUpdateResult === false) {
                                                              return;
                                                            } else if (beforeUpdateResult instanceof HTMLElement) {
                                                              fromEl = beforeUpdateResult;
                                                              indexTree(fromEl);
                                                            }
                                                            morphAttrs2(fromEl, toEl);
                                                            onElUpdated(fromEl);
                                                            if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {
                                                              return;
                                                            }
                                                          }
                                                          if (fromEl.nodeName !== "TEXTAREA") {
                                                            morphChildren(fromEl, toEl);
                                                          } else {
                                                            specialElHandlers.TEXTAREA(fromEl, toEl);
                                                          }
                                                        }
                                                        function morphChildren(fromEl, toEl) {
                                                          var skipFrom = skipFromChildren(fromEl, toEl);
                                                          var curToNodeChild = toEl.firstChild;
                                                          var curFromNodeChild = fromEl.firstChild;
                                                          var curToNodeKey;
                                                          var curFromNodeKey;
                                                          var fromNextSibling;
                                                          var toNextSibling;
                                                          var matchingFromEl;
                                                          outer:
                                                            while (curToNodeChild) {
                                                              toNextSibling = curToNodeChild.nextSibling;
                                                              curToNodeKey = getNodeKey(curToNodeChild);
                                                              while (!skipFrom && curFromNodeChild) {
                                                                fromNextSibling = curFromNodeChild.nextSibling;
                                                                if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {
                                                                  curToNodeChild = toNextSibling;
                                                                  curFromNodeChild = fromNextSibling;
                                                                  continue outer;
                                                                }
                                                                curFromNodeKey = getNodeKey(curFromNodeChild);
                                                                var curFromNodeType = curFromNodeChild.nodeType;
                                                                var isCompatible = void 0;
                                                                if (curFromNodeType === curToNodeChild.nodeType) {
                                                                  if (curFromNodeType === ELEMENT_NODE) {
                                                                    if (curToNodeKey) {
                                                                      if (curToNodeKey !== curFromNodeKey) {
                                                                        if (matchingFromEl = fromNodesLookup[curToNodeKey]) {
                                                                          if (fromNextSibling === matchingFromEl) {
                                                                            isCompatible = false;
                                                                          } else {
                                                                            fromEl.insertBefore(matchingFromEl, curFromNodeChild);
                                                                            if (curFromNodeKey) {
                                                                              addKeyedRemoval(curFromNodeKey);
                                                                            } else {
                                                                              removeNode(
                                                                                curFromNodeChild,
                                                                                fromEl,
                                                                                true
                                                                                /* skip keyed nodes */
                                                                              );
                                                                            }
                                                                            curFromNodeChild = matchingFromEl;
                                                                            curFromNodeKey = getNodeKey(curFromNodeChild);
                                                                          }
                                                                        } else {
                                                                          isCompatible = false;
                                                                        }
                                                                      }
                                                                    } else if (curFromNodeKey) {
                                                                      isCompatible = false;
                                                                    }
                                                                    isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);
                                                                    if (isCompatible) {
                                                                      morphEl(curFromNodeChild, curToNodeChild);
                                                                    }
                                                                  } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {
                                                                    isCompatible = true;
                                                                    if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {
                                                                      curFromNodeChild.nodeValue = curToNodeChild.nodeValue;
                                                                    }
                                                                  }
                                                                }
                                                                if (isCompatible) {
                                                                  curToNodeChild = toNextSibling;
                                                                  curFromNodeChild = fromNextSibling;
                                                                  continue outer;
                                                                }
                                                                if (curFromNodeKey) {
                                                                  addKeyedRemoval(curFromNodeKey);
                                                                } else {
                                                                  removeNode(
                                                                    curFromNodeChild,
                                                                    fromEl,
                                                                    true
                                                                    /* skip keyed nodes */
                                                                  );
                                                                }
                                                                curFromNodeChild = fromNextSibling;
                                                              }
                                                              if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {
                                                                if (!skipFrom) {
                                                                  addChild(fromEl, matchingFromEl);
                                                                }
                                                                morphEl(matchingFromEl, curToNodeChild);
                                                              } else {
                                                                var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);
                                                                if (onBeforeNodeAddedResult !== false) {
                                                                  if (onBeforeNodeAddedResult) {
                                                                    curToNodeChild = onBeforeNodeAddedResult;
                                                                  }
                                                                  if (curToNodeChild.actualize) {
                                                                    curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);
                                                                  }
                                                                  addChild(fromEl, curToNodeChild);
                                                                  handleNodeAdded(curToNodeChild);
                                                                }
                                                              }
                                                              curToNodeChild = toNextSibling;
                                                              curFromNodeChild = fromNextSibling;
                                                            }
                                                          cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);
                                                          var specialElHandler = specialElHandlers[fromEl.nodeName];
                                                          if (specialElHandler) {
                                                            specialElHandler(fromEl, toEl);
                                                          }
                                                        }
                                                        var morphedNode = fromNode;
                                                        var morphedNodeType = morphedNode.nodeType;
                                                        var toNodeType = toNode.nodeType;
                                                        if (!childrenOnly) {
                                                          if (morphedNodeType === ELEMENT_NODE) {
                                                            if (toNodeType === ELEMENT_NODE) {
                                                              if (!compareNodeNames(fromNode, toNode)) {
                                                                onNodeDiscarded(fromNode);
                                                                morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));
                                                              }
                                                            } else {
                                                              morphedNode = toNode;
                                                            }
                                                          } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) {
                                                            if (toNodeType === morphedNodeType) {
                                                              if (morphedNode.nodeValue !== toNode.nodeValue) {
                                                                morphedNode.nodeValue = toNode.nodeValue;
                                                              }
                                                              return morphedNode;
                                                            } else {
                                                              morphedNode = toNode;
                                                            }
                                                          }
                                                        }
                                                        if (morphedNode === toNode) {
                                                          onNodeDiscarded(fromNode);
                                                        } else {
                                                          if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {
                                                            return;
                                                          }
                                                          morphEl(morphedNode, toNode, childrenOnly);
                                                          if (keyedRemovalList) {
                                                            for (var i = 0, len = keyedRemovalList.length; i < len; i++) {
                                                              var elToRemove = fromNodesLookup[keyedRemovalList[i]];
                                                              if (elToRemove) {
                                                                removeNode(elToRemove, elToRemove.parentNode, false);
                                                              }
                                                            }
                                                          }
                                                        }
                                                        if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {
                                                          if (morphedNode.actualize) {
                                                            morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);
                                                          }
                                                          fromNode.parentNode.replaceChild(morphedNode, fromNode);
                                                        }
                                                        return morphedNode;
                                                      };
                                                    }
                                                    var morphdom = morphdomFactory(morphAttrs);
                                                    var morphdom_esm_default = morphdom;
                                                    var DOMPatch = class {
                                                      constructor(view, container, id, html, streams, targetCID, opts = {}) {
                                                        this.view = view;
                                                        this.liveSocket = view.liveSocket;
                                                        this.container = container;
                                                        this.id = id;
                                                        this.rootID = view.root.id;
                                                        this.html = html;
                                                        this.streams = streams;
                                                        this.streamInserts = {};
                                                        this.streamComponentRestore = {};
                                                        this.targetCID = targetCID;
                                                        this.cidPatch = isCid(this.targetCID);
                                                        this.pendingRemoves = [];
                                                        this.phxRemove = this.liveSocket.binding("remove");
                                                        this.targetContainer = this.isCIDPatch() ? this.targetCIDContainer(html) : container;
                                                        this.callbacks = {
                                                          beforeadded: [],
                                                          beforeupdated: [],
                                                          beforephxChildAdded: [],
                                                          afteradded: [],
                                                          afterupdated: [],
                                                          afterdiscarded: [],
                                                          afterphxChildAdded: [],
                                                          aftertransitionsDiscarded: []
                                                        };
                                                        this.withChildren = opts.withChildren || opts.undoRef || false;
                                                        this.undoRef = opts.undoRef;
                                                      }
                                                      before(kind, callback) {
                                                        this.callbacks[`before${kind}`].push(callback);
                                                      }
                                                      after(kind, callback) {
                                                        this.callbacks[`after${kind}`].push(callback);
                                                      }
                                                      trackBefore(kind, ...args) {
                                                        this.callbacks[`before${kind}`].forEach((callback) => callback(...args));
                                                      }
                                                      trackAfter(kind, ...args) {
                                                        this.callbacks[`after${kind}`].forEach((callback) => callback(...args));
                                                      }
                                                      markPrunableContentForRemoval() {
                                                        const phxUpdate = this.liveSocket.binding(PHX_UPDATE);
                                                        dom_default.all(
                                                          this.container,
                                                          `[${phxUpdate}=append] > *, [${phxUpdate}=prepend] > *`,
                                                          (el) => {
                                                            el.setAttribute(PHX_PRUNE, "");
                                                          }
                                                        );
                                                      }
                                                      perform(isJoinPatch) {
                                                        const { view, liveSocket: liveSocket2, html, container } = this;
                                                        let targetContainer = this.targetContainer;
                                                        if (this.isCIDPatch() && !this.targetContainer) {
                                                          return;
                                                        }
                                                        if (this.isCIDPatch()) {
                                                          const closestLock = targetContainer.closest(`[${PHX_REF_LOCK}]`);
                                                          if (closestLock) {
                                                            const clonedTree = dom_default.private(closestLock, PHX_REF_LOCK);
                                                            if (clonedTree) {
                                                              targetContainer = clonedTree.querySelector(
                                                                `[data-phx-component="${this.targetCID}"]`
                                                              );
                                                            }
                                                          }
                                                        }
                                                        const focused = liveSocket2.getActiveElement();
                                                        const { selectionStart, selectionEnd } = focused && dom_default.hasSelectionRange(focused) ? focused : {};
                                                        const phxUpdate = liveSocket2.binding(PHX_UPDATE);
                                                        const phxViewportTop = liveSocket2.binding(PHX_VIEWPORT_TOP);
                                                        const phxViewportBottom = liveSocket2.binding(PHX_VIEWPORT_BOTTOM);
                                                        const phxTriggerExternal = liveSocket2.binding(PHX_TRIGGER_ACTION);
                                                        const added = [];
                                                        const updates = [];
                                                        const appendPrependUpdates = [];
                                                        let portalCallbacks = [];
                                                        let externalFormTriggered = null;
                                                        const morph = (targetContainer2, source, withChildren = this.withChildren) => {
                                                          const morphCallbacks = {
                                                            // normally, we are running with childrenOnly, as the patch HTML for a LV
                                                            // does not include the LV attrs (data-phx-session, etc.)
                                                            // when we are patching a live component, we do want to patch the root element as well;
                                                            // another case is the recursive patch of a stream item that was kept on reset (-> onBeforeNodeAdded)
                                                            childrenOnly: targetContainer2.getAttribute(PHX_COMPONENT) === null && !withChildren,
                                                            getNodeKey: (node) => {
                                                              if (dom_default.isPhxDestroyed(node)) {
                                                                return null;
                                                              }
                                                              if (isJoinPatch) {
                                                                return node.id;
                                                              }
                                                              return node.id || node.getAttribute && node.getAttribute(PHX_MAGIC_ID);
                                                            },
                                                            // skip indexing from children when container is stream
                                                            skipFromChildren: (from) => {
                                                              return from.getAttribute(phxUpdate) === PHX_STREAM;
                                                            },
                                                            // tell morphdom how to add a child
                                                            addChild: (parent, child) => {
                                                              const { ref, streamAt } = this.getStreamInsert(child);
                                                              if (ref === void 0) {
                                                                return parent.appendChild(child);
                                                              }
                                                              this.setStreamRef(child, ref);
                                                              if (streamAt === 0) {
                                                                parent.insertAdjacentElement("afterbegin", child);
                                                              } else if (streamAt === -1) {
                                                                const lastChild = parent.lastElementChild;
                                                                if (lastChild && !lastChild.hasAttribute(PHX_STREAM_REF)) {
                                                                  const nonStreamChild = Array.from(parent.children).find(
                                                                    (c) => !c.hasAttribute(PHX_STREAM_REF)
                                                                  );
                                                                  parent.insertBefore(child, nonStreamChild);
                                                                } else {
                                                                  parent.appendChild(child);
                                                                }
                                                              } else if (streamAt > 0) {
                                                                const sibling = Array.from(parent.children)[streamAt];
                                                                parent.insertBefore(child, sibling);
                                                              }
                                                            },
                                                            onBeforeNodeAdded: (el) => {
                                                              if (this.getStreamInsert(el)?.updateOnly && !this.streamComponentRestore[el.id]) {
                                                                return false;
                                                              }
                                                              dom_default.maintainPrivateHooks(el, el, phxViewportTop, phxViewportBottom);
                                                              this.trackBefore("added", el);
                                                              let morphedEl = el;
                                                              if (this.streamComponentRestore[el.id]) {
                                                                morphedEl = this.streamComponentRestore[el.id];
                                                                delete this.streamComponentRestore[el.id];
                                                                morph(morphedEl, el, true);
                                                              }
                                                              return morphedEl;
                                                            },
                                                            onNodeAdded: (el) => {
                                                              if (el.getAttribute) {
                                                                this.maybeReOrderStream(el, true);
                                                              }
                                                              if (dom_default.isPortalTemplate(el)) {
                                                                portalCallbacks.push(() => this.teleport(el, morph));
                                                              }
                                                              if (el instanceof HTMLImageElement && el.srcset) {
                                                                el.srcset = el.srcset;
                                                              } else if (el instanceof HTMLVideoElement && el.autoplay) {
                                                                el.play();
                                                              }
                                                              if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {
                                                                externalFormTriggered = el;
                                                              }
                                                              if (dom_default.isPhxChild(el) && view.ownsElement(el) || dom_default.isPhxSticky(el) && view.ownsElement(el.parentNode)) {
                                                                this.trackAfter("phxChildAdded", el);
                                                              }
                                                              if (el.nodeName === "SCRIPT" && el.hasAttribute(PHX_RUNTIME_HOOK)) {
                                                                this.handleRuntimeHook(el, source);
                                                              }
                                                              added.push(el);
                                                            },
                                                            onNodeDiscarded: (el) => this.onNodeDiscarded(el),
                                                            onBeforeNodeDiscarded: (el) => {
                                                              if (el.getAttribute && el.getAttribute(PHX_PRUNE) !== null) {
                                                                return true;
                                                              }
                                                              if (el.parentElement !== null && el.id && dom_default.isPhxUpdate(el.parentElement, phxUpdate, [
                                                                PHX_STREAM,
                                                                "append",
                                                                "prepend"
                                                              ])) {
                                                                return false;
                                                              }
                                                              if (el.getAttribute && el.getAttribute(PHX_TELEPORTED_REF)) {
                                                                return false;
                                                              }
                                                              if (this.maybePendingRemove(el)) {
                                                                return false;
                                                              }
                                                              if (this.skipCIDSibling(el)) {
                                                                return false;
                                                              }
                                                              if (dom_default.isPortalTemplate(el)) {
                                                                const teleportedEl = document.getElementById(
                                                                  el.content.firstElementChild.id
                                                                );
                                                                if (teleportedEl) {
                                                                  teleportedEl.remove();
                                                                  morphCallbacks.onNodeDiscarded(teleportedEl);
                                                                  this.view.dropPortalElementId(teleportedEl.id);
                                                                }
                                                              }
                                                              return true;
                                                            },
                                                            onElUpdated: (el) => {
                                                              if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {
                                                                externalFormTriggered = el;
                                                              }
                                                              updates.push(el);
                                                              this.maybeReOrderStream(el, false);
                                                            },
                                                            onBeforeElUpdated: (fromEl, toEl) => {
                                                              if (fromEl.id && fromEl.isSameNode(targetContainer2) && fromEl.id !== toEl.id) {
                                                                morphCallbacks.onNodeDiscarded(fromEl);
                                                                fromEl.replaceWith(toEl);
                                                                return morphCallbacks.onNodeAdded(toEl);
                                                              }
                                                              dom_default.syncPendingAttrs(fromEl, toEl);
                                                              dom_default.maintainPrivateHooks(
                                                                fromEl,
                                                                toEl,
                                                                phxViewportTop,
                                                                phxViewportBottom
                                                              );
                                                              dom_default.cleanChildNodes(toEl, phxUpdate);
                                                              if (this.skipCIDSibling(toEl)) {
                                                                this.maybeReOrderStream(fromEl);
                                                                return false;
                                                              }
                                                              if (dom_default.isPhxSticky(fromEl)) {
                                                                [PHX_SESSION, PHX_STATIC, PHX_ROOT_ID].map((attr) => [
                                                                  attr,
                                                                  fromEl.getAttribute(attr),
                                                                  toEl.getAttribute(attr)
                                                                ]).forEach(([attr, fromVal, toVal]) => {
                                                                  if (toVal && fromVal !== toVal) {
                                                                    fromEl.setAttribute(attr, toVal);
                                                                  }
                                                                });
                                                                return false;
                                                              }
                                                              if (dom_default.isIgnored(fromEl, phxUpdate) || fromEl.form && fromEl.form.isSameNode(externalFormTriggered)) {
                                                                this.trackBefore("updated", fromEl, toEl);
                                                                dom_default.mergeAttrs(fromEl, toEl, {
                                                                  isIgnored: dom_default.isIgnored(fromEl, phxUpdate)
                                                                });
                                                                updates.push(fromEl);
                                                                dom_default.applyStickyOperations(fromEl);
                                                                return false;
                                                              }
                                                              if (fromEl.type === "number" && fromEl.validity && fromEl.validity.badInput) {
                                                                return false;
                                                              }
                                                              const isFocusedFormEl = focused && fromEl.isSameNode(focused) && dom_default.isFormInput(fromEl);
                                                              const focusedSelectChanged = isFocusedFormEl && this.isChangedSelect(fromEl, toEl);
                                                              if (fromEl.hasAttribute(PHX_REF_SRC)) {
                                                                const ref = new ElementRef(fromEl);
                                                                if (ref.lockRef && (!this.undoRef || !ref.isLockUndoneBy(this.undoRef))) {
                                                                  dom_default.applyStickyOperations(fromEl);
                                                                  const isLocked = fromEl.hasAttribute(PHX_REF_LOCK);
                                                                  const clone2 = isLocked ? dom_default.private(fromEl, PHX_REF_LOCK) || fromEl.cloneNode(true) : null;
                                                                  if (clone2) {
                                                                    dom_default.putPrivate(fromEl, PHX_REF_LOCK, clone2);
                                                                    if (!isFocusedFormEl) {
                                                                      fromEl = clone2;
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                              if (dom_default.isPhxChild(toEl)) {
                                                                const prevSession = fromEl.getAttribute(PHX_SESSION);
                                                                dom_default.mergeAttrs(fromEl, toEl, { exclude: [PHX_STATIC] });
                                                                if (prevSession !== "") {
                                                                  fromEl.setAttribute(PHX_SESSION, prevSession);
                                                                }
                                                                fromEl.setAttribute(PHX_ROOT_ID, this.rootID);
                                                                dom_default.applyStickyOperations(fromEl);
                                                                return false;
                                                              }
                                                              if (this.undoRef && dom_default.private(toEl, PHX_REF_LOCK)) {
                                                                dom_default.putPrivate(
                                                                  fromEl,
                                                                  PHX_REF_LOCK,
                                                                  dom_default.private(toEl, PHX_REF_LOCK)
                                                                );
                                                              }
                                                              dom_default.copyPrivates(toEl, fromEl);
                                                              if (dom_default.isPortalTemplate(toEl)) {
                                                                portalCallbacks.push(() => this.teleport(toEl, morph));
                                                                fromEl.innerHTML = toEl.innerHTML;
                                                                return false;
                                                              }
                                                              if (isFocusedFormEl && fromEl.type !== "hidden" && !focusedSelectChanged) {
                                                                this.trackBefore("updated", fromEl, toEl);
                                                                dom_default.mergeFocusedInput(fromEl, toEl);
                                                                dom_default.syncAttrsToProps(fromEl);
                                                                updates.push(fromEl);
                                                                dom_default.applyStickyOperations(fromEl);
                                                                return false;
                                                              } else {
                                                                if (focusedSelectChanged) {
                                                                  fromEl.blur();
                                                                }
                                                                if (dom_default.isPhxUpdate(toEl, phxUpdate, ["append", "prepend"])) {
                                                                  appendPrependUpdates.push(
                                                                    new DOMPostMorphRestorer(
                                                                      fromEl,
                                                                      toEl,
                                                                      toEl.getAttribute(phxUpdate)
                                                                    )
                                                                  );
                                                                }
                                                                dom_default.syncAttrsToProps(toEl);
                                                                dom_default.applyStickyOperations(toEl);
                                                                this.trackBefore("updated", fromEl, toEl);
                                                                return fromEl;
                                                              }
                                                            }
                                                          };
                                                          morphdom_esm_default(targetContainer2, source, morphCallbacks);
                                                        };
                                                        this.trackBefore("added", container);
                                                        this.trackBefore("updated", container, container);
                                                        liveSocket2.time("morphdom", () => {
                                                          this.streams.forEach(([ref, inserts, deleteIds, reset]) => {
                                                            inserts.forEach(([key, streamAt, limit, updateOnly]) => {
                                                              this.streamInserts[key] = { ref, streamAt, limit, reset, updateOnly };
                                                            });
                                                            if (reset !== void 0) {
                                                              dom_default.all(container, `[${PHX_STREAM_REF}="${ref}"]`, (child) => {
                                                                this.removeStreamChildElement(child);
                                                              });
                                                            }
                                                            deleteIds.forEach((id) => {
                                                              const child = container.querySelector(`[id="${id}"]`);
                                                              if (child) {
                                                                this.removeStreamChildElement(child);
                                                              }
                                                            });
                                                          });
                                                          if (isJoinPatch) {
                                                            dom_default.all(this.container, `[${phxUpdate}=${PHX_STREAM}]`).filter((el) => this.view.ownsElement(el)).forEach((el) => {
                                                              Array.from(el.children).forEach((child) => {
                                                                this.removeStreamChildElement(child, true);
                                                              });
                                                            });
                                                          }
                                                          morph(targetContainer, html);
                                                          let teleportCount = 0;
                                                          while (portalCallbacks.length > 0 && teleportCount < 5) {
                                                            const copy = portalCallbacks.slice();
                                                            portalCallbacks = [];
                                                            copy.forEach((callback) => callback());
                                                            teleportCount++;
                                                          }
                                                          this.view.portalElementIds.forEach((id) => {
                                                            const el = document.getElementById(id);
                                                            if (el) {
                                                              const source = document.getElementById(
                                                                el.getAttribute(PHX_TELEPORTED_SRC)
                                                              );
                                                              if (!source) {
                                                                el.remove();
                                                                this.onNodeDiscarded(el);
                                                                this.view.dropPortalElementId(id);
                                                              }
                                                            }
                                                          });
                                                        });
                                                        if (liveSocket2.isDebugEnabled()) {
                                                          detectDuplicateIds();
                                                          detectInvalidStreamInserts(this.streamInserts);
                                                          Array.from(document.querySelectorAll("input[name=id]")).forEach(
                                                            (node) => {
                                                              if (node instanceof HTMLInputElement && node.form) {
                                                                console.error(
                                                                  'Detected an input with name="id" inside a form! This will cause problems when patching the DOM.\n',
                                                                  node
                                                                );
                                                              }
                                                            }
                                                          );
                                                        }
                                                        if (appendPrependUpdates.length > 0) {
                                                          liveSocket2.time("post-morph append/prepend restoration", () => {
                                                            appendPrependUpdates.forEach((update) => update.perform());
                                                          });
                                                        }
                                                        liveSocket2.silenceEvents(
                                                          () => dom_default.restoreFocus(focused, selectionStart, selectionEnd)
                                                        );
                                                        dom_default.dispatchEvent(document, "phx:update");
                                                        added.forEach((el) => this.trackAfter("added", el));
                                                        updates.forEach((el) => this.trackAfter("updated", el));
                                                        this.transitionPendingRemoves();
                                                        if (externalFormTriggered) {
                                                          liveSocket2.unload();
                                                          const submitter = dom_default.private(externalFormTriggered, "submitter");
                                                          if (submitter && submitter.name && targetContainer.contains(submitter)) {
                                                            const input = document.createElement("input");
                                                            input.type = "hidden";
                                                            const formId = submitter.getAttribute("form");
                                                            if (formId) {
                                                              input.setAttribute("form", formId);
                                                            }
                                                            input.name = submitter.name;
                                                            input.value = submitter.value;
                                                            submitter.parentElement.insertBefore(input, submitter);
                                                          }
                                                          Object.getPrototypeOf(externalFormTriggered).submit.call(
                                                            externalFormTriggered
                                                          );
                                                        }
                                                        return true;
                                                      }
                                                      onNodeDiscarded(el) {
                                                        if (dom_default.isPhxChild(el) || dom_default.isPhxSticky(el)) {
                                                          this.liveSocket.destroyViewByEl(el);
                                                        }
                                                        this.trackAfter("discarded", el);
                                                      }
                                                      maybePendingRemove(node) {
                                                        if (node.getAttribute && node.getAttribute(this.phxRemove) !== null) {
                                                          this.pendingRemoves.push(node);
                                                          return true;
                                                        } else {
                                                          return false;
                                                        }
                                                      }
                                                      removeStreamChildElement(child, force = false) {
                                                        if (!force && !this.view.ownsElement(child)) {
                                                          return;
                                                        }
                                                        if (this.streamInserts[child.id]) {
                                                          this.streamComponentRestore[child.id] = child;
                                                          child.remove();
                                                        } else {
                                                          if (!this.maybePendingRemove(child)) {
                                                            child.remove();
                                                            this.onNodeDiscarded(child);
                                                          }
                                                        }
                                                      }
                                                      getStreamInsert(el) {
                                                        const insert = el.id ? this.streamInserts[el.id] : {};
                                                        return insert || {};
                                                      }
                                                      setStreamRef(el, ref) {
                                                        dom_default.putSticky(
                                                          el,
                                                          PHX_STREAM_REF,
                                                          (el2) => el2.setAttribute(PHX_STREAM_REF, ref)
                                                        );
                                                      }
                                                      maybeReOrderStream(el, isNew) {
                                                        const { ref, streamAt, reset } = this.getStreamInsert(el);
                                                        if (streamAt === void 0) {
                                                          return;
                                                        }
                                                        this.setStreamRef(el, ref);
                                                        if (!reset && !isNew) {
                                                          return;
                                                        }
                                                        if (!el.parentElement) {
                                                          return;
                                                        }
                                                        if (streamAt === 0) {
                                                          el.parentElement.insertBefore(el, el.parentElement.firstElementChild);
                                                        } else if (streamAt > 0) {
                                                          const children = Array.from(el.parentElement.children);
                                                          const oldIndex = children.indexOf(el);
                                                          if (streamAt >= children.length - 1) {
                                                            el.parentElement.appendChild(el);
                                                          } else {
                                                            const sibling = children[streamAt];
                                                            if (oldIndex > streamAt) {
                                                              el.parentElement.insertBefore(el, sibling);
                                                            } else {
                                                              el.parentElement.insertBefore(el, sibling.nextElementSibling);
                                                            }
                                                          }
                                                        }
                                                        this.maybeLimitStream(el);
                                                      }
                                                      maybeLimitStream(el) {
                                                        const { limit } = this.getStreamInsert(el);
                                                        const children = limit !== null && Array.from(el.parentElement.children);
                                                        if (limit && limit < 0 && children.length > limit * -1) {
                                                          children.slice(0, children.length + limit).forEach((child) => this.removeStreamChildElement(child));
                                                        } else if (limit && limit >= 0 && children.length > limit) {
                                                          children.slice(limit).forEach((child) => this.removeStreamChildElement(child));
                                                        }
                                                      }
                                                      transitionPendingRemoves() {
                                                        const { pendingRemoves, liveSocket: liveSocket2 } = this;
                                                        if (pendingRemoves.length > 0) {
                                                          liveSocket2.transitionRemoves(pendingRemoves, () => {
                                                            pendingRemoves.forEach((el) => {
                                                              const child = dom_default.firstPhxChild(el);
                                                              if (child) {
                                                                liveSocket2.destroyViewByEl(child);
                                                              }
                                                              el.remove();
                                                            });
                                                            this.trackAfter("transitionsDiscarded", pendingRemoves);
                                                          });
                                                        }
                                                      }
                                                      isChangedSelect(fromEl, toEl) {
                                                        if (!(fromEl instanceof HTMLSelectElement) || fromEl.multiple) {
                                                          return false;
                                                        }
                                                        if (fromEl.options.length !== toEl.options.length) {
                                                          return true;
                                                        }
                                                        toEl.value = fromEl.value;
                                                        return !fromEl.isEqualNode(toEl);
                                                      }
                                                      isCIDPatch() {
                                                        return this.cidPatch;
                                                      }
                                                      skipCIDSibling(el) {
                                                        return el.nodeType === Node.ELEMENT_NODE && el.hasAttribute(PHX_SKIP);
                                                      }
                                                      targetCIDContainer(html) {
                                                        if (!this.isCIDPatch()) {
                                                          return;
                                                        }
                                                        const [first, ...rest] = dom_default.findComponentNodeList(
                                                          this.view.id,
                                                          this.targetCID
                                                        );
                                                        if (rest.length === 0 && dom_default.childNodeLength(html) === 1) {
                                                          return first;
                                                        } else {
                                                          return first && first.parentNode;
                                                        }
                                                      }
                                                      indexOf(parent, child) {
                                                        return Array.from(parent.children).indexOf(child);
                                                      }
                                                      teleport(el, morph) {
                                                        const targetSelector = el.getAttribute(PHX_PORTAL);
                                                        const portalContainer = document.querySelector(targetSelector);
                                                        if (!portalContainer) {
                                                          throw new Error(
                                                            "portal target with selector " + targetSelector + " not found"
                                                          );
                                                        }
                                                        const toTeleport = el.content.firstElementChild;
                                                        if (this.skipCIDSibling(toTeleport)) {
                                                          return;
                                                        }
                                                        if (!toTeleport?.id) {
                                                          throw new Error(
                                                            "phx-portal template must have a single root element with ID!"
                                                          );
                                                        }
                                                        const existing = document.getElementById(toTeleport.id);
                                                        let portalTarget;
                                                        if (existing) {
                                                          if (!portalContainer.contains(existing)) {
                                                            portalContainer.appendChild(existing);
                                                          }
                                                          portalTarget = existing;
                                                        } else {
                                                          portalTarget = document.createElement(toTeleport.tagName);
                                                          portalContainer.appendChild(portalTarget);
                                                        }
                                                        toTeleport.setAttribute(PHX_TELEPORTED_REF, this.view.id);
                                                        toTeleport.setAttribute(PHX_TELEPORTED_SRC, el.id);
                                                        morph(portalTarget, toTeleport, true);
                                                        toTeleport.removeAttribute(PHX_TELEPORTED_REF);
                                                        toTeleport.removeAttribute(PHX_TELEPORTED_SRC);
                                                        this.view.pushPortalElementId(toTeleport.id);
                                                      }
                                                      handleRuntimeHook(el, source) {
                                                        const name = el.getAttribute(PHX_RUNTIME_HOOK);
                                                        let nonce = el.hasAttribute("nonce") ? el.getAttribute("nonce") : null;
                                                        if (el.hasAttribute("nonce")) {
                                                          const template = document.createElement("template");
                                                          template.innerHTML = source;
                                                          nonce = template.content.querySelector(`script[${PHX_RUNTIME_HOOK}="${CSS.escape(name)}"]`).getAttribute("nonce");
                                                        }
                                                        const script = document.createElement("script");
                                                        script.textContent = el.textContent;
                                                        dom_default.mergeAttrs(script, el, { isIgnored: false });
                                                        if (nonce) {
                                                          script.nonce = nonce;
                                                        }
                                                        el.replaceWith(script);
                                                        el = script;
                                                      }
                                                    };
                                                    var VOID_TAGS = /* @__PURE__ */ new Set([
                                                      "area",
                                                      "base",
                                                      "br",
                                                      "col",
                                                      "command",
                                                      "embed",
                                                      "hr",
                                                      "img",
                                                      "input",
                                                      "keygen",
                                                      "link",
                                                      "meta",
                                                      "param",
                                                      "source",
                                                      "track",
                                                      "wbr"
                                                    ]);
                                                    var quoteChars = /* @__PURE__ */ new Set(["'", '"']);
                                                    var modifyRoot = (html, attrs, clearInnerHTML) => {
                                                      let i = 0;
                                                      let insideComment = false;
                                                      let beforeTag, afterTag, tag, tagNameEndsAt, id, newHTML;
                                                      const lookahead = html.match(/^(\s*(?:<!--.*?-->\s*)*)<([^\s\/>]+)/);
                                                      if (lookahead === null) {
                                                        throw new Error(`malformed html ${html}`);
                                                      }
                                                      i = lookahead[0].length;
                                                      beforeTag = lookahead[1];
                                                      tag = lookahead[2];
                                                      tagNameEndsAt = i;
                                                      for (i; i < html.length; i++) {
                                                        if (html.charAt(i) === ">") {
                                                          break;
                                                        }
                                                        if (html.charAt(i) === "=") {
                                                          const isId = html.slice(i - 3, i) === " id";
                                                          i++;
                                                          const char = html.charAt(i);
                                                          if (quoteChars.has(char)) {
                                                            const attrStartsAt = i;
                                                            i++;
                                                            for (i; i < html.length; i++) {
                                                              if (html.charAt(i) === char) {
                                                                break;
                                                              }
                                                            }
                                                            if (isId) {
                                                              id = html.slice(attrStartsAt + 1, i);
                                                              break;
                                                            }
                                                          }
                                                        }
                                                      }
                                                      let closeAt = html.length - 1;
                                                      insideComment = false;
                                                      while (closeAt >= beforeTag.length + tag.length) {
                                                        const char = html.charAt(closeAt);
                                                        if (insideComment) {
                                                          if (char === "-" && html.slice(closeAt - 3, closeAt) === "<!-") {
                                                            insideComment = false;
                                                            closeAt -= 4;
                                                          } else {
                                                            closeAt -= 1;
                                                          }
                                                        } else if (char === ">" && html.slice(closeAt - 2, closeAt) === "--") {
                                                          insideComment = true;
                                                          closeAt -= 3;
                                                        } else if (char === ">") {
                                                          break;
                                                        } else {
                                                          closeAt -= 1;
                                                        }
                                                      }
                                                      afterTag = html.slice(closeAt + 1, html.length);
                                                      const attrsStr = Object.keys(attrs).map((attr) => attrs[attr] === true ? attr : `${attr}="${attrs[attr]}"`).join(" ");
                                                      if (clearInnerHTML) {
                                                        const idAttrStr = id ? ` id="${id}"` : "";
                                                        if (VOID_TAGS.has(tag)) {
                                                          newHTML = `<${tag}${idAttrStr}${attrsStr === "" ? "" : " "}${attrsStr}/>`;
                                                        } else {
                                                          newHTML = `<${tag}${idAttrStr}${attrsStr === "" ? "" : " "}${attrsStr}></${tag}>`;
                                                        }
                                                      } else {
                                                        const rest = html.slice(tagNameEndsAt, closeAt + 1);
                                                        newHTML = `<${tag}${attrsStr === "" ? "" : " "}${attrsStr}${rest}`;
                                                      }
                                                      return [newHTML, beforeTag, afterTag];
                                                    };
                                                    var Rendered = class {
                                                      static extract(diff) {
                                                        const { [REPLY]: reply, [EVENTS]: events, [TITLE]: title } = diff;
                                                        delete diff[REPLY];
                                                        delete diff[EVENTS];
                                                        delete diff[TITLE];
                                                        return { diff, title, reply: reply || null, events: events || [] };
                                                      }
                                                      constructor(viewId, rendered) {
                                                        this.viewId = viewId;
                                                        this.rendered = {};
                                                        this.magicId = 0;
                                                        this.mergeDiff(rendered);
                                                      }
                                                      parentViewId() {
                                                        return this.viewId;
                                                      }
                                                      toString(onlyCids) {
                                                        const { buffer: str, streams } = this.recursiveToString(
                                                          this.rendered,
                                                          this.rendered[COMPONENTS],
                                                          onlyCids,
                                                          true,
                                                          {}
                                                        );
                                                        return { buffer: str, streams };
                                                      }
                                                      recursiveToString(rendered, components = rendered[COMPONENTS], onlyCids, changeTracking, rootAttrs) {
                                                        onlyCids = onlyCids ? new Set(onlyCids) : null;
                                                        const output = {
                                                          buffer: "",
                                                          components,
                                                          onlyCids,
                                                          streams: /* @__PURE__ */ new Set()
                                                        };
                                                        this.toOutputBuffer(rendered, null, output, changeTracking, rootAttrs);
                                                        return { buffer: output.buffer, streams: output.streams };
                                                      }
                                                      componentCIDs(diff) {
                                                        return Object.keys(diff[COMPONENTS] || {}).map((i) => parseInt(i));
                                                      }
                                                      isComponentOnlyDiff(diff) {
                                                        if (!diff[COMPONENTS]) {
                                                          return false;
                                                        }
                                                        return Object.keys(diff).length === 1;
                                                      }
                                                      getComponent(diff, cid) {
                                                        return diff[COMPONENTS][cid];
                                                      }
                                                      resetRender(cid) {
                                                        if (this.rendered[COMPONENTS][cid]) {
                                                          this.rendered[COMPONENTS][cid].reset = true;
                                                        }
                                                      }
                                                      mergeDiff(diff) {
                                                        const newc = diff[COMPONENTS];
                                                        const cache = {};
                                                        delete diff[COMPONENTS];
                                                        this.rendered = this.mutableMerge(this.rendered, diff);
                                                        this.rendered[COMPONENTS] = this.rendered[COMPONENTS] || {};
                                                        if (newc) {
                                                          const oldc = this.rendered[COMPONENTS];
                                                          for (const cid in newc) {
                                                            newc[cid] = this.cachedFindComponent(cid, newc[cid], oldc, newc, cache);
                                                          }
                                                          for (const cid in newc) {
                                                            oldc[cid] = newc[cid];
                                                          }
                                                          diff[COMPONENTS] = newc;
                                                        }
                                                      }
                                                      cachedFindComponent(cid, cdiff, oldc, newc, cache) {
                                                        if (cache[cid]) {
                                                          return cache[cid];
                                                        } else {
                                                          let ndiff, stat, scid = cdiff[STATIC];
                                                          if (isCid(scid)) {
                                                            let tdiff;
                                                            if (scid > 0) {
                                                              tdiff = this.cachedFindComponent(scid, newc[scid], oldc, newc, cache);
                                                            } else {
                                                              tdiff = oldc[-scid];
                                                            }
                                                            stat = tdiff[STATIC];
                                                            ndiff = this.cloneMerge(tdiff, cdiff, true);
                                                            ndiff[STATIC] = stat;
                                                          } else {
                                                            ndiff = cdiff[STATIC] !== void 0 || oldc[cid] === void 0 ? cdiff : this.cloneMerge(oldc[cid], cdiff, false);
                                                          }
                                                          cache[cid] = ndiff;
                                                          return ndiff;
                                                        }
                                                      }
                                                      mutableMerge(target, source) {
                                                        if (source[STATIC] !== void 0) {
                                                          return source;
                                                        } else {
                                                          this.doMutableMerge(target, source);
                                                          return target;
                                                        }
                                                      }
                                                      doMutableMerge(target, source) {
                                                        if (source[KEYED]) {
                                                          this.mergeKeyed(target, source);
                                                        } else {
                                                          for (const key in source) {
                                                            const val = source[key];
                                                            const targetVal = target[key];
                                                            const isObjVal = isObject(val);
                                                            if (isObjVal && val[STATIC] === void 0 && isObject(targetVal)) {
                                                              this.doMutableMerge(targetVal, val);
                                                            } else {
                                                              target[key] = val;
                                                            }
                                                          }
                                                        }
                                                        if (target[ROOT]) {
                                                          target.newRender = true;
                                                        }
                                                      }
                                                      clone(diff) {
                                                        if ("structuredClone" in window) {
                                                          return structuredClone(diff);
                                                        } else {
                                                          return JSON.parse(JSON.stringify(diff));
                                                        }
                                                      }
                                                      // keyed comprehensions
                                                      mergeKeyed(target, source) {
                                                        const clonedTarget = this.clone(target);
                                                        Object.entries(source[KEYED]).forEach(([i, entry]) => {
                                                          if (i === KEYED_COUNT) {
                                                            return;
                                                          }
                                                          if (Array.isArray(entry)) {
                                                            const [old_idx, diff] = entry;
                                                            target[KEYED][i] = clonedTarget[KEYED][old_idx];
                                                            this.doMutableMerge(target[KEYED][i], diff);
                                                          } else if (typeof entry === "number") {
                                                            const old_idx = entry;
                                                            target[KEYED][i] = clonedTarget[KEYED][old_idx];
                                                          } else if (typeof entry === "object") {
                                                            if (!target[KEYED][i]) {
                                                              target[KEYED][i] = {};
                                                            }
                                                            this.doMutableMerge(target[KEYED][i], entry);
                                                          }
                                                        });
                                                        if (source[KEYED][KEYED_COUNT] < target[KEYED][KEYED_COUNT]) {
                                                          for (let i = source[KEYED][KEYED_COUNT]; i < target[KEYED][KEYED_COUNT]; i++) {
                                                            delete target[KEYED][i];
                                                          }
                                                        }
                                                        target[KEYED][KEYED_COUNT] = source[KEYED][KEYED_COUNT];
                                                        if (source[STREAM]) {
                                                          target[STREAM] = source[STREAM];
                                                        }
                                                        if (source[TEMPLATES]) {
                                                          target[TEMPLATES] = source[TEMPLATES];
                                                        }
                                                      }
                                                      // Merges cid trees together, copying statics from source tree.
                                                      //
                                                      // The `pruneMagicId` is passed to control pruning the magicId of the
                                                      // target. We must always prune the magicId when we are sharing statics
                                                      // from another component. If not pruning, we replicate the logic from
                                                      // mutableMerge, where we set newRender to true if there is a root
                                                      // (effectively forcing the new version to be rendered instead of skipped)
                                                      //
                                                      cloneMerge(target, source, pruneMagicId) {
                                                        let merged;
                                                        if (source[KEYED]) {
                                                          merged = this.clone(target);
                                                          this.mergeKeyed(merged, source);
                                                        } else {
                                                          merged = { ...target, ...source };
                                                          for (const key in merged) {
                                                            const val = source[key];
                                                            const targetVal = target[key];
                                                            if (isObject(val) && val[STATIC] === void 0 && isObject(targetVal)) {
                                                              merged[key] = this.cloneMerge(targetVal, val, pruneMagicId);
                                                            } else if (val === void 0 && isObject(targetVal)) {
                                                              merged[key] = this.cloneMerge(targetVal, {}, pruneMagicId);
                                                            }
                                                          }
                                                        }
                                                        if (pruneMagicId) {
                                                          delete merged.magicId;
                                                          delete merged.newRender;
                                                        } else if (target[ROOT]) {
                                                          merged.newRender = true;
                                                        }
                                                        return merged;
                                                      }
                                                      componentToString(cid) {
                                                        const { buffer: str, streams } = this.recursiveCIDToString(
                                                          this.rendered[COMPONENTS],
                                                          cid,
                                                          null
                                                        );
                                                        const [strippedHTML, _before, _after] = modifyRoot(str, {});
                                                        return { buffer: strippedHTML, streams };
                                                      }
                                                      pruneCIDs(cids) {
                                                        cids.forEach((cid) => delete this.rendered[COMPONENTS][cid]);
                                                      }
                                                      // private
                                                      get() {
                                                        return this.rendered;
                                                      }
                                                      isNewFingerprint(diff = {}) {
                                                        return !!diff[STATIC];
                                                      }
                                                      templateStatic(part, templates) {
                                                        if (typeof part === "number") {
                                                          return templates[part];
                                                        } else {
                                                          return part;
                                                        }
                                                      }
                                                      nextMagicID() {
                                                        this.magicId++;
                                                        return `m${this.magicId}-${this.parentViewId()}`;
                                                      }
                                                      // Converts rendered tree to output buffer.
                                                      //
                                                      // changeTracking controls if we can apply the PHX_SKIP optimization.
                                                      toOutputBuffer(rendered, templates, output, changeTracking, rootAttrs = {}) {
                                                        if (rendered[KEYED]) {
                                                          return this.comprehensionToBuffer(
                                                            rendered,
                                                            templates,
                                                            output,
                                                            changeTracking
                                                          );
                                                        }
                                                        if (rendered[TEMPLATES]) {
                                                          templates = rendered[TEMPLATES];
                                                          delete rendered[TEMPLATES];
                                                        }
                                                        let { [STATIC]: statics } = rendered;
                                                        statics = this.templateStatic(statics, templates);
                                                        rendered[STATIC] = statics;
                                                        const isRoot = rendered[ROOT];
                                                        const prevBuffer = output.buffer;
                                                        if (isRoot) {
                                                          output.buffer = "";
                                                        }
                                                        if (changeTracking && isRoot && !rendered.magicId) {
                                                          rendered.newRender = true;
                                                          rendered.magicId = this.nextMagicID();
                                                        }
                                                        output.buffer += statics[0];
                                                        for (let i = 1; i < statics.length; i++) {
                                                          this.dynamicToBuffer(rendered[i - 1], templates, output, changeTracking);
                                                          output.buffer += statics[i];
                                                        }
                                                        if (isRoot) {
                                                          let skip = false;
                                                          let attrs;
                                                          if (changeTracking || rendered.magicId) {
                                                            skip = changeTracking && !rendered.newRender;
                                                            attrs = { [PHX_MAGIC_ID]: rendered.magicId, ...rootAttrs };
                                                          } else {
                                                            attrs = rootAttrs;
                                                          }
                                                          if (skip) {
                                                            attrs[PHX_SKIP] = true;
                                                          }
                                                          const [newRoot, commentBefore, commentAfter] = modifyRoot(
                                                            output.buffer,
                                                            attrs,
                                                            skip
                                                          );
                                                          rendered.newRender = false;
                                                          output.buffer = prevBuffer + commentBefore + newRoot + commentAfter;
                                                        }
                                                      }
                                                      comprehensionToBuffer(rendered, templates, output, changeTracking) {
                                                        const keyedTemplates = templates || rendered[TEMPLATES];
                                                        const statics = this.templateStatic(rendered[STATIC], templates);
                                                        rendered[STATIC] = statics;
                                                        delete rendered[TEMPLATES];
                                                        for (let i = 0; i < rendered[KEYED][KEYED_COUNT]; i++) {
                                                          output.buffer += statics[0];
                                                          for (let j = 1; j < statics.length; j++) {
                                                            this.dynamicToBuffer(
                                                              rendered[KEYED][i][j - 1],
                                                              keyedTemplates,
                                                              output,
                                                              changeTracking
                                                            );
                                                            output.buffer += statics[j];
                                                          }
                                                        }
                                                        if (rendered[STREAM]) {
                                                          const stream = rendered[STREAM];
                                                          const [_ref, _inserts, deleteIds, reset] = stream || [null, {}, [], null];
                                                          if (stream !== void 0 && (rendered[KEYED][KEYED_COUNT] > 0 || deleteIds.length > 0 || reset)) {
                                                            delete rendered[STREAM];
                                                            rendered[KEYED] = {
                                                              [KEYED_COUNT]: 0
                                                            };
                                                            output.streams.add(stream);
                                                          }
                                                        }
                                                      }
                                                      dynamicToBuffer(rendered, templates, output, changeTracking) {
                                                        if (typeof rendered === "number") {
                                                          const { buffer: str, streams } = this.recursiveCIDToString(
                                                            output.components,
                                                            rendered,
                                                            output.onlyCids
                                                          );
                                                          output.buffer += str;
                                                          output.streams = /* @__PURE__ */ new Set([...output.streams, ...streams]);
                                                        } else if (isObject(rendered)) {
                                                          this.toOutputBuffer(rendered, templates, output, changeTracking, {});
                                                        } else {
                                                          output.buffer += rendered;
                                                        }
                                                      }
                                                      recursiveCIDToString(components, cid, onlyCids) {
                                                        const component = components[cid] || logError(`no component for CID ${cid}`, components);
                                                        const attrs = { [PHX_COMPONENT]: cid, [PHX_VIEW_REF]: this.viewId };
                                                        const skip = onlyCids && !onlyCids.has(cid);
                                                        component.newRender = !skip;
                                                        component.magicId = `c${cid}-${this.parentViewId()}`;
                                                        const changeTracking = !component.reset;
                                                        const { buffer: html, streams } = this.recursiveToString(
                                                          component,
                                                          components,
                                                          onlyCids,
                                                          changeTracking,
                                                          attrs
                                                        );
                                                        delete component.reset;
                                                        return { buffer: html, streams };
                                                      }
                                                    };
                                                    var focusStack = [];
                                                    var default_transition_time = 200;
                                                    var JS = {
                                                      // private
                                                      exec(e, eventType, phxEvent, view, sourceEl, defaults) {
                                                        const [defaultKind, defaultArgs] = defaults || [
                                                          null,
                                                          { callback: defaults && defaults.callback }
                                                        ];
                                                        const commands = phxEvent.charAt(0) === "[" ? JSON.parse(phxEvent) : [[defaultKind, defaultArgs]];
                                                        commands.forEach(([kind, args]) => {
                                                          if (kind === defaultKind) {
                                                            args = { ...defaultArgs, ...args };
                                                            args.callback = args.callback || defaultArgs.callback;
                                                          }
                                                          this.filterToEls(view.liveSocket, sourceEl, args).forEach((el) => {
                                                            this[`exec_${kind}`](e, eventType, phxEvent, view, sourceEl, el, args);
                                                          });
                                                        });
                                                      },
                                                      isVisible(el) {
                                                        return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length > 0);
                                                      },
                                                      // returns true if any part of the element is inside the viewport
                                                      isInViewport(el) {
                                                        const rect = el.getBoundingClientRect();
                                                        const windowHeight = window.innerHeight || document.documentElement.clientHeight;
                                                        const windowWidth = window.innerWidth || document.documentElement.clientWidth;
                                                        return rect.right > 0 && rect.bottom > 0 && rect.left < windowWidth && rect.top < windowHeight;
                                                      },
                                                      // private
                                                      // commands
                                                      exec_exec(e, eventType, phxEvent, view, sourceEl, el, { attr, to }) {
                                                        const encodedJS = el.getAttribute(attr);
                                                        if (!encodedJS) {
                                                          throw new Error(`expected ${attr} to contain JS command on "${to}"`);
                                                        }
                                                        view.liveSocket.execJS(el, encodedJS, eventType);
                                                      },
                                                      exec_dispatch(e, eventType, phxEvent, view, sourceEl, el, { event, detail, bubbles, blocking }) {
                                                        detail = detail || {};
                                                        detail.dispatcher = sourceEl;
                                                        if (blocking) {
                                                          const promise = new Promise((resolve, _reject) => {
                                                            detail.done = resolve;
                                                          });
                                                          view.liveSocket.asyncTransition(promise);
                                                        }
                                                        dom_default.dispatchEvent(el, event, { detail, bubbles });
                                                      },
                                                      exec_push(e, eventType, phxEvent, view, sourceEl, el, args) {
                                                        const {
                                                          event,
                                                          data,
                                                          target,
                                                          page_loading,
                                                          loading,
                                                          value,
                                                          dispatcher,
                                                          callback
                                                        } = args;
                                                        const pushOpts = {
                                                          loading,
                                                          value,
                                                          target,
                                                          page_loading: !!page_loading,
                                                          originalEvent: e
                                                        };
                                                        const targetSrc = eventType === "change" && dispatcher ? dispatcher : sourceEl;
                                                        const phxTarget = target || targetSrc.getAttribute(view.binding("target")) || targetSrc;
                                                        const handler = (targetView, targetCtx) => {
                                                          if (!targetView.isConnected()) {
                                                            return;
                                                          }
                                                          if (eventType === "change") {
                                                            let { newCid, _target } = args;
                                                            _target = _target || (dom_default.isFormInput(sourceEl) ? sourceEl.name : void 0);
                                                            if (_target) {
                                                              pushOpts._target = _target;
                                                            }
                                                            targetView.pushInput(
                                                              sourceEl,
                                                              targetCtx,
                                                              newCid,
                                                              event || phxEvent,
                                                              pushOpts,
                                                              callback
                                                            );
                                                          } else if (eventType === "submit") {
                                                            const { submitter } = args;
                                                            targetView.submitForm(
                                                              sourceEl,
                                                              targetCtx,
                                                              event || phxEvent,
                                                              submitter,
                                                              pushOpts,
                                                              callback
                                                            );
                                                          } else {
                                                            targetView.pushEvent(
                                                              eventType,
                                                              sourceEl,
                                                              targetCtx,
                                                              event || phxEvent,
                                                              data,
                                                              pushOpts,
                                                              callback
                                                            );
                                                          }
                                                        };
                                                        if (args.targetView && args.targetCtx) {
                                                          handler(args.targetView, args.targetCtx);
                                                        } else {
                                                          view.withinTargets(phxTarget, handler);
                                                        }
                                                      },
                                                      exec_navigate(e, eventType, phxEvent, view, sourceEl, el, { href, replace }) {
                                                        view.liveSocket.historyRedirect(
                                                          e,
                                                          href,
                                                          replace ? "replace" : "push",
                                                          null,
                                                          sourceEl
                                                        );
                                                      },
                                                      exec_patch(e, eventType, phxEvent, view, sourceEl, el, { href, replace }) {
                                                        view.liveSocket.pushHistoryPatch(
                                                          e,
                                                          href,
                                                          replace ? "replace" : "push",
                                                          sourceEl
                                                        );
                                                      },
                                                      exec_focus(e, eventType, phxEvent, view, sourceEl, el) {
                                                        aria_default.attemptFocus(el);
                                                        window.requestAnimationFrame(() => {
                                                          window.requestAnimationFrame(() => aria_default.attemptFocus(el));
                                                        });
                                                      },
                                                      exec_focus_first(e, eventType, phxEvent, view, sourceEl, el) {
                                                        aria_default.focusFirstInteractive(el) || aria_default.focusFirst(el);
                                                        window.requestAnimationFrame(() => {
                                                          window.requestAnimationFrame(
                                                            () => aria_default.focusFirstInteractive(el) || aria_default.focusFirst(el)
                                                          );
                                                        });
                                                      },
                                                      exec_push_focus(e, eventType, phxEvent, view, sourceEl, el) {
                                                        focusStack.push(el || sourceEl);
                                                      },
                                                      exec_pop_focus(_e, _eventType, _phxEvent, _view, _sourceEl, _el) {
                                                        const el = focusStack.pop();
                                                        if (el) {
                                                          el.focus();
                                                          window.requestAnimationFrame(() => {
                                                            window.requestAnimationFrame(() => el.focus());
                                                          });
                                                        }
                                                      },
                                                      exec_add_class(e, eventType, phxEvent, view, sourceEl, el, { names, transition, time, blocking }) {
                                                        this.addOrRemoveClasses(el, names, [], transition, time, view, blocking);
                                                      },
                                                      exec_remove_class(e, eventType, phxEvent, view, sourceEl, el, { names, transition, time, blocking }) {
                                                        this.addOrRemoveClasses(el, [], names, transition, time, view, blocking);
                                                      },
                                                      exec_toggle_class(e, eventType, phxEvent, view, sourceEl, el, { names, transition, time, blocking }) {
                                                        this.toggleClasses(el, names, transition, time, view, blocking);
                                                      },
                                                      exec_toggle_attr(e, eventType, phxEvent, view, sourceEl, el, { attr: [attr, val1, val2] }) {
                                                        this.toggleAttr(el, attr, val1, val2);
                                                      },
                                                      exec_ignore_attrs(e, eventType, phxEvent, view, sourceEl, el, { attrs }) {
                                                        this.ignoreAttrs(el, attrs);
                                                      },
                                                      exec_transition(e, eventType, phxEvent, view, sourceEl, el, { time, transition, blocking }) {
                                                        this.addOrRemoveClasses(el, [], [], transition, time, view, blocking);
                                                      },
                                                      exec_toggle(e, eventType, phxEvent, view, sourceEl, el, { display, ins, outs, time, blocking }) {
                                                        this.toggle(eventType, view, el, display, ins, outs, time, blocking);
                                                      },
                                                      exec_show(e, eventType, phxEvent, view, sourceEl, el, { display, transition, time, blocking }) {
                                                        this.show(eventType, view, el, display, transition, time, blocking);
                                                      },
                                                      exec_hide(e, eventType, phxEvent, view, sourceEl, el, { display, transition, time, blocking }) {
                                                        this.hide(eventType, view, el, display, transition, time, blocking);
                                                      },
                                                      exec_set_attr(e, eventType, phxEvent, view, sourceEl, el, { attr: [attr, val] }) {
                                                        this.setOrRemoveAttrs(el, [[attr, val]], []);
                                                      },
                                                      exec_remove_attr(e, eventType, phxEvent, view, sourceEl, el, { attr }) {
                                                        this.setOrRemoveAttrs(el, [], [attr]);
                                                      },
                                                      ignoreAttrs(el, attrs) {
                                                        dom_default.putPrivate(el, "JS:ignore_attrs", {
                                                          apply: (fromEl, toEl) => {
                                                            let fromAttributes = Array.from(fromEl.attributes);
                                                            let fromAttributeNames = fromAttributes.map((attr) => attr.name);
                                                            Array.from(toEl.attributes).filter((attr) => {
                                                              return !fromAttributeNames.includes(attr.name);
                                                            }).forEach((attr) => {
                                                              if (dom_default.attributeIgnored(attr, attrs)) {
                                                                toEl.removeAttribute(attr.name);
                                                              }
                                                            });
                                                            fromAttributes.forEach((attr) => {
                                                              if (dom_default.attributeIgnored(attr, attrs)) {
                                                                toEl.setAttribute(attr.name, attr.value);
                                                              }
                                                            });
                                                          }
                                                        });
                                                      },
                                                      onBeforeElUpdated(fromEl, toEl) {
                                                        const ignoreAttrs = dom_default.private(fromEl, "JS:ignore_attrs");
                                                        if (ignoreAttrs) {
                                                          ignoreAttrs.apply(fromEl, toEl);
                                                        }
                                                      },
                                                      // utils for commands
                                                      show(eventType, view, el, display, transition, time, blocking) {
                                                        if (!this.isVisible(el)) {
                                                          this.toggle(
                                                            eventType,
                                                            view,
                                                            el,
                                                            display,
                                                            transition,
                                                            null,
                                                            time,
                                                            blocking
                                                          );
                                                        }
                                                      },
                                                      hide(eventType, view, el, display, transition, time, blocking) {
                                                        if (this.isVisible(el)) {
                                                          this.toggle(
                                                            eventType,
                                                            view,
                                                            el,
                                                            display,
                                                            null,
                                                            transition,
                                                            time,
                                                            blocking
                                                          );
                                                        }
                                                      },
                                                      toggle(eventType, view, el, display, ins, outs, time, blocking) {
                                                        time = time || default_transition_time;
                                                        const [inClasses, inStartClasses, inEndClasses] = ins || [[], [], []];
                                                        const [outClasses, outStartClasses, outEndClasses] = outs || [[], [], []];
                                                        if (inClasses.length > 0 || outClasses.length > 0) {
                                                          if (this.isVisible(el)) {
                                                            const onStart = () => {
                                                              this.addOrRemoveClasses(
                                                                el,
                                                                outStartClasses,
                                                                inClasses.concat(inStartClasses).concat(inEndClasses)
                                                              );
                                                              window.requestAnimationFrame(() => {
                                                                this.addOrRemoveClasses(el, outClasses, []);
                                                                window.requestAnimationFrame(
                                                                  () => this.addOrRemoveClasses(el, outEndClasses, outStartClasses)
                                                                );
                                                              });
                                                            };
                                                            const onEnd = () => {
                                                              this.addOrRemoveClasses(el, [], outClasses.concat(outEndClasses));
                                                              dom_default.putSticky(
                                                                el,
                                                                "toggle",
                                                                (currentEl) => currentEl.style.display = "none"
                                                              );
                                                              el.dispatchEvent(new Event("phx:hide-end"));
                                                            };
                                                            el.dispatchEvent(new Event("phx:hide-start"));
                                                            if (blocking === false) {
                                                              onStart();
                                                              setTimeout(onEnd, time);
                                                            } else {
                                                              view.transition(time, onStart, onEnd);
                                                            }
                                                          } else {
                                                            if (eventType === "remove") {
                                                              return;
                                                            }
                                                            const onStart = () => {
                                                              this.addOrRemoveClasses(
                                                                el,
                                                                inStartClasses,
                                                                outClasses.concat(outStartClasses).concat(outEndClasses)
                                                              );
                                                              const stickyDisplay = display || this.defaultDisplay(el);
                                                              window.requestAnimationFrame(() => {
                                                                this.addOrRemoveClasses(el, inClasses, []);
                                                                window.requestAnimationFrame(() => {
                                                                  dom_default.putSticky(
                                                                    el,
                                                                    "toggle",
                                                                    (currentEl) => currentEl.style.display = stickyDisplay
                                                                  );
                                                                  this.addOrRemoveClasses(el, inEndClasses, inStartClasses);
                                                                });
                                                              });
                                                            };
                                                            const onEnd = () => {
                                                              this.addOrRemoveClasses(el, [], inClasses.concat(inEndClasses));
                                                              el.dispatchEvent(new Event("phx:show-end"));
                                                            };
                                                            el.dispatchEvent(new Event("phx:show-start"));
                                                            if (blocking === false) {
                                                              onStart();
                                                              setTimeout(onEnd, time);
                                                            } else {
                                                              view.transition(time, onStart, onEnd);
                                                            }
                                                          }
                                                        } else {
                                                          if (this.isVisible(el)) {
                                                            window.requestAnimationFrame(() => {
                                                              el.dispatchEvent(new Event("phx:hide-start"));
                                                              dom_default.putSticky(
                                                                el,
                                                                "toggle",
                                                                (currentEl) => currentEl.style.display = "none"
                                                              );
                                                              el.dispatchEvent(new Event("phx:hide-end"));
                                                            });
                                                          } else {
                                                            window.requestAnimationFrame(() => {
                                                              el.dispatchEvent(new Event("phx:show-start"));
                                                              const stickyDisplay = display || this.defaultDisplay(el);
                                                              dom_default.putSticky(
                                                                el,
                                                                "toggle",
                                                                (currentEl) => currentEl.style.display = stickyDisplay
                                                              );
                                                              el.dispatchEvent(new Event("phx:show-end"));
                                                            });
                                                          }
                                                        }
                                                      },
                                                      toggleClasses(el, classes, transition, time, view, blocking) {
                                                        window.requestAnimationFrame(() => {
                                                          const [prevAdds, prevRemoves] = dom_default.getSticky(el, "classes", [[], []]);
                                                          const newAdds = classes.filter(
                                                            (name) => prevAdds.indexOf(name) < 0 && !el.classList.contains(name)
                                                          );
                                                          const newRemoves = classes.filter(
                                                            (name) => prevRemoves.indexOf(name) < 0 && el.classList.contains(name)
                                                          );
                                                          this.addOrRemoveClasses(
                                                            el,
                                                            newAdds,
                                                            newRemoves,
                                                            transition,
                                                            time,
                                                            view,
                                                            blocking
                                                          );
                                                        });
                                                      },
                                                      toggleAttr(el, attr, val1, val2) {
                                                        if (el.hasAttribute(attr)) {
                                                          if (val2 !== void 0) {
                                                            if (el.getAttribute(attr) === val1) {
                                                              this.setOrRemoveAttrs(el, [[attr, val2]], []);
                                                            } else {
                                                              this.setOrRemoveAttrs(el, [[attr, val1]], []);
                                                            }
                                                          } else {
                                                            this.setOrRemoveAttrs(el, [], [attr]);
                                                          }
                                                        } else {
                                                          this.setOrRemoveAttrs(el, [[attr, val1]], []);
                                                        }
                                                      },
                                                      addOrRemoveClasses(el, adds, removes, transition, time, view, blocking) {
                                                        time = time || default_transition_time;
                                                        const [transitionRun, transitionStart, transitionEnd] = transition || [
                                                          [],
                                                          [],
                                                          []
                                                        ];
                                                        if (transitionRun.length > 0) {
                                                          const onStart = () => {
                                                            this.addOrRemoveClasses(
                                                              el,
                                                              transitionStart,
                                                              [].concat(transitionRun).concat(transitionEnd)
                                                            );
                                                            window.requestAnimationFrame(() => {
                                                              this.addOrRemoveClasses(el, transitionRun, []);
                                                              window.requestAnimationFrame(
                                                                () => this.addOrRemoveClasses(el, transitionEnd, transitionStart)
                                                              );
                                                            });
                                                          };
                                                          const onDone = () => this.addOrRemoveClasses(
                                                            el,
                                                            adds.concat(transitionEnd),
                                                            removes.concat(transitionRun).concat(transitionStart)
                                                          );
                                                          if (blocking === false) {
                                                            onStart();
                                                            setTimeout(onDone, time);
                                                          } else {
                                                            view.transition(time, onStart, onDone);
                                                          }
                                                          return;
                                                        }
                                                        window.requestAnimationFrame(() => {
                                                          const [prevAdds, prevRemoves] = dom_default.getSticky(el, "classes", [[], []]);
                                                          const keepAdds = adds.filter(
                                                            (name) => prevAdds.indexOf(name) < 0 && !el.classList.contains(name)
                                                          );
                                                          const keepRemoves = removes.filter(
                                                            (name) => prevRemoves.indexOf(name) < 0 && el.classList.contains(name)
                                                          );
                                                          const newAdds = prevAdds.filter((name) => removes.indexOf(name) < 0).concat(keepAdds);
                                                          const newRemoves = prevRemoves.filter((name) => adds.indexOf(name) < 0).concat(keepRemoves);
                                                          dom_default.putSticky(el, "classes", (currentEl) => {
                                                            currentEl.classList.remove(...newRemoves);
                                                            currentEl.classList.add(...newAdds);
                                                            return [newAdds, newRemoves];
                                                          });
                                                        });
                                                      },
                                                      setOrRemoveAttrs(el, sets, removes) {
                                                        const [prevSets, prevRemoves] = dom_default.getSticky(el, "attrs", [[], []]);
                                                        const alteredAttrs = sets.map(([attr, _val]) => attr).concat(removes);
                                                        const newSets = prevSets.filter(([attr, _val]) => !alteredAttrs.includes(attr)).concat(sets);
                                                        const newRemoves = prevRemoves.filter((attr) => !alteredAttrs.includes(attr)).concat(removes);
                                                        dom_default.putSticky(el, "attrs", (currentEl) => {
                                                          newRemoves.forEach((attr) => currentEl.removeAttribute(attr));
                                                          newSets.forEach(([attr, val]) => currentEl.setAttribute(attr, val));
                                                          return [newSets, newRemoves];
                                                        });
                                                      },
                                                      hasAllClasses(el, classes) {
                                                        return classes.every((name) => el.classList.contains(name));
                                                      },
                                                      isToggledOut(el, outClasses) {
                                                        return !this.isVisible(el) || this.hasAllClasses(el, outClasses);
                                                      },
                                                      filterToEls(liveSocket2, sourceEl, { to }) {
                                                        const defaultQuery = () => {
                                                          if (typeof to === "string") {
                                                            return document.querySelectorAll(to);
                                                          } else if (to.closest) {
                                                            const toEl = sourceEl.closest(to.closest);
                                                            return toEl ? [toEl] : [];
                                                          } else if (to.inner) {
                                                            return sourceEl.querySelectorAll(to.inner);
                                                          }
                                                        };
                                                        return to ? liveSocket2.jsQuerySelectorAll(sourceEl, to, defaultQuery) : [sourceEl];
                                                      },
                                                      defaultDisplay(el) {
                                                        return { tr: "table-row", td: "table-cell" }[el.tagName.toLowerCase()] || "block";
                                                      },
                                                      transitionClasses(val) {
                                                        if (!val) {
                                                          return null;
                                                        }
                                                        let [trans, tStart, tEnd] = Array.isArray(val) ? val : [val.split(" "), [], []];
                                                        trans = Array.isArray(trans) ? trans : trans.split(" ");
                                                        tStart = Array.isArray(tStart) ? tStart : tStart.split(" ");
                                                        tEnd = Array.isArray(tEnd) ? tEnd : tEnd.split(" ");
                                                        return [trans, tStart, tEnd];
                                                      }
                                                    };
                                                    var js_default = JS;
                                                    var js_commands_default = (liveSocket2, eventType) => {
                                                      return {
                                                        exec(el, encodedJS) {
                                                          liveSocket2.execJS(el, encodedJS, eventType);
                                                        },
                                                        show(el, opts = {}) {
                                                          const owner = liveSocket2.owner(el);
                                                          js_default.show(
                                                            eventType,
                                                            owner,
                                                            el,
                                                            opts.display,
                                                            js_default.transitionClasses(opts.transition),
                                                            opts.time,
                                                            opts.blocking
                                                          );
                                                        },
                                                        hide(el, opts = {}) {
                                                          const owner = liveSocket2.owner(el);
                                                          js_default.hide(
                                                            eventType,
                                                            owner,
                                                            el,
                                                            null,
                                                            js_default.transitionClasses(opts.transition),
                                                            opts.time,
                                                            opts.blocking
                                                          );
                                                        },
                                                        toggle(el, opts = {}) {
                                                          const owner = liveSocket2.owner(el);
                                                          const inTransition = js_default.transitionClasses(opts.in);
                                                          const outTransition = js_default.transitionClasses(opts.out);
                                                          js_default.toggle(
                                                            eventType,
                                                            owner,
                                                            el,
                                                            opts.display,
                                                            inTransition,
                                                            outTransition,
                                                            opts.time,
                                                            opts.blocking
                                                          );
                                                        },
                                                        addClass(el, names, opts = {}) {
                                                          const classNames = Array.isArray(names) ? names : names.split(" ");
                                                          const owner = liveSocket2.owner(el);
                                                          js_default.addOrRemoveClasses(
                                                            el,
                                                            classNames,
                                                            [],
                                                            js_default.transitionClasses(opts.transition),
                                                            opts.time,
                                                            owner,
                                                            opts.blocking
                                                          );
                                                        },
                                                        removeClass(el, names, opts = {}) {
                                                          const classNames = Array.isArray(names) ? names : names.split(" ");
                                                          const owner = liveSocket2.owner(el);
                                                          js_default.addOrRemoveClasses(
                                                            el,
                                                            [],
                                                            classNames,
                                                            js_default.transitionClasses(opts.transition),
                                                            opts.time,
                                                            owner,
                                                            opts.blocking
                                                          );
                                                        },
                                                        toggleClass(el, names, opts = {}) {
                                                          const classNames = Array.isArray(names) ? names : names.split(" ");
                                                          const owner = liveSocket2.owner(el);
                                                          js_default.toggleClasses(
                                                            el,
                                                            classNames,
                                                            js_default.transitionClasses(opts.transition),
                                                            opts.time,
                                                            owner,
                                                            opts.blocking
                                                          );
                                                        },
                                                        transition(el, transition, opts = {}) {
                                                          const owner = liveSocket2.owner(el);
                                                          js_default.addOrRemoveClasses(
                                                            el,
                                                            [],
                                                            [],
                                                            js_default.transitionClasses(transition),
                                                            opts.time,
                                                            owner,
                                                            opts.blocking
                                                          );
                                                        },
                                                        setAttribute(el, attr, val) {
                                                          js_default.setOrRemoveAttrs(el, [[attr, val]], []);
                                                        },
                                                        removeAttribute(el, attr) {
                                                          js_default.setOrRemoveAttrs(el, [], [attr]);
                                                        },
                                                        toggleAttribute(el, attr, val1, val2) {
                                                          js_default.toggleAttr(el, attr, val1, val2);
                                                        },
                                                        push(el, type, opts = {}) {
                                                          liveSocket2.withinOwners(el, (view) => {
                                                            const data = opts.value || {};
                                                            delete opts.value;
                                                            let e = new CustomEvent("phx:exec", { detail: { sourceElement: el } });
                                                            js_default.exec(e, eventType, type, view, el, ["push", { data, ...opts }]);
                                                          });
                                                        },
                                                        navigate(href, opts = {}) {
                                                          const customEvent = new CustomEvent("phx:exec");
                                                          liveSocket2.historyRedirect(
                                                            customEvent,
                                                            href,
                                                            opts.replace ? "replace" : "push",
                                                            null,
                                                            null
                                                          );
                                                        },
                                                        patch(href, opts = {}) {
                                                          const customEvent = new CustomEvent("phx:exec");
                                                          liveSocket2.pushHistoryPatch(
                                                            customEvent,
                                                            href,
                                                            opts.replace ? "replace" : "push",
                                                            null
                                                          );
                                                        },
                                                        ignoreAttributes(el, attrs) {
                                                          js_default.ignoreAttrs(el, Array.isArray(attrs) ? attrs : [attrs]);
                                                        }
                                                      };
                                                    };
                                                    var HOOK_ID = "hookId";
                                                    var viewHookID = 1;
                                                    var ViewHook = class _ViewHook {
                                                      get liveSocket() {
                                                        return this.__liveSocket();
                                                      }
                                                      static makeID() {
                                                        return viewHookID++;
                                                      }
                                                      static elementID(el) {
                                                        return dom_default.private(el, HOOK_ID);
                                                      }
                                                      constructor(view, el, callbacks) {
                                                        this.el = el;
                                                        this.__attachView(view);
                                                        this.__listeners = /* @__PURE__ */ new Set();
                                                        this.__isDisconnected = false;
                                                        dom_default.putPrivate(this.el, HOOK_ID, _ViewHook.makeID());
                                                        if (callbacks) {
                                                          const protectedProps = /* @__PURE__ */ new Set([
                                                            "el",
                                                            "liveSocket",
                                                            "__view",
                                                            "__listeners",
                                                            "__isDisconnected",
                                                            "constructor",
                                                            // Standard object properties
                                                            // Core ViewHook API methods
                                                            "js",
                                                            "pushEvent",
                                                            "pushEventTo",
                                                            "handleEvent",
                                                            "removeHandleEvent",
                                                            "upload",
                                                            "uploadTo",
                                                            // Internal lifecycle callers
                                                            "__mounted",
                                                            "__updated",
                                                            "__beforeUpdate",
                                                            "__destroyed",
                                                            "__reconnected",
                                                            "__disconnected",
                                                            "__cleanup__"
                                                          ]);
                                                          for (const key in callbacks) {
                                                            if (Object.prototype.hasOwnProperty.call(callbacks, key)) {
                                                              this[key] = callbacks[key];
                                                              if (protectedProps.has(key)) {
                                                                console.warn(
                                                                  `Hook object for element #${el.id} overwrites core property '${key}'!`
                                                                );
                                                              }
                                                            }
                                                          }
                                                          const lifecycleMethods = [
                                                            "mounted",
                                                            "beforeUpdate",
                                                            "updated",
                                                            "destroyed",
                                                            "disconnected",
                                                            "reconnected"
                                                          ];
                                                          lifecycleMethods.forEach((methodName) => {
                                                            if (callbacks[methodName] && typeof callbacks[methodName] === "function") {
                                                              this[methodName] = callbacks[methodName];
                                                            }
                                                          });
                                                        }
                                                      }
                                                      /** @internal */
                                                      __attachView(view) {
                                                        if (view) {
                                                          this.__view = () => view;
                                                          this.__liveSocket = () => view.liveSocket;
                                                        } else {
                                                          this.__view = () => {
                                                            throw new Error(
                                                              `hook not yet attached to a live view: ${this.el.outerHTML}`
                                                            );
                                                          };
                                                          this.__liveSocket = () => {
                                                            throw new Error(
                                                              `hook not yet attached to a live view: ${this.el.outerHTML}`
                                                            );
                                                          };
                                                        }
                                                      }
                                                      // Default lifecycle methods
                                                      mounted() {
                                                      }
                                                      beforeUpdate() {
                                                      }
                                                      updated() {
                                                      }
                                                      destroyed() {
                                                      }
                                                      disconnected() {
                                                      }
                                                      reconnected() {
                                                      }
                                                      // Internal lifecycle callers - called by the View
                                                      /** @internal */
                                                      __mounted() {
                                                        this.mounted();
                                                      }
                                                      /** @internal */
                                                      __updated() {
                                                        this.updated();
                                                      }
                                                      /** @internal */
                                                      __beforeUpdate() {
                                                        this.beforeUpdate();
                                                      }
                                                      /** @internal */
                                                      __destroyed() {
                                                        this.destroyed();
                                                        dom_default.deletePrivate(this.el, HOOK_ID);
                                                      }
                                                      /** @internal */
                                                      __reconnected() {
                                                        if (this.__isDisconnected) {
                                                          this.__isDisconnected = false;
                                                          this.reconnected();
                                                        }
                                                      }
                                                      /** @internal */
                                                      __disconnected() {
                                                        this.__isDisconnected = true;
                                                        this.disconnected();
                                                      }
                                                      js() {
                                                        return {
                                                          ...js_commands_default(this.__view().liveSocket, "hook"),
                                                          exec: (encodedJS) => {
                                                            this.__view().liveSocket.execJS(this.el, encodedJS, "hook");
                                                          }
                                                        };
                                                      }
                                                      pushEvent(event, payload, onReply) {
                                                        const promise = this.__view().pushHookEvent(
                                                          this.el,
                                                          null,
                                                          event,
                                                          payload || {}
                                                        );
                                                        if (onReply === void 0) {
                                                          return promise.then(({ reply }) => reply);
                                                        }
                                                        promise.then(
                                                          ({ reply, ref }) => onReply(reply, ref)
                                                        ).catch(() => {
                                                        });
                                                      }
                                                      pushEventTo(selectorOrTarget, event, payload, onReply) {
                                                        if (onReply === void 0) {
                                                          const targetPair = [];
                                                          this.__view().withinTargets(
                                                            selectorOrTarget,
                                                            (view, targetCtx) => {
                                                              targetPair.push({ view, targetCtx });
                                                            }
                                                          );
                                                          const promises = targetPair.map(({ view, targetCtx }) => {
                                                            return view.pushHookEvent(this.el, targetCtx, event, payload || {});
                                                          });
                                                          return Promise.allSettled(promises);
                                                        }
                                                        this.__view().withinTargets(
                                                          selectorOrTarget,
                                                          (view, targetCtx) => {
                                                            view.pushHookEvent(this.el, targetCtx, event, payload || {}).then(
                                                              ({ reply, ref }) => onReply(reply, ref)
                                                            ).catch(() => {
                                                            });
                                                          }
                                                        );
                                                      }
                                                      handleEvent(event, callback) {
                                                        const callbackRef = {
                                                          event,
                                                          callback: (customEvent) => callback(customEvent.detail)
                                                        };
                                                        window.addEventListener(
                                                          `phx:${event}`,
                                                          callbackRef.callback
                                                        );
                                                        this.__listeners.add(callbackRef);
                                                        return callbackRef;
                                                      }
                                                      removeHandleEvent(ref) {
                                                        window.removeEventListener(
                                                          `phx:${ref.event}`,
                                                          ref.callback
                                                        );
                                                        this.__listeners.delete(ref);
                                                      }
                                                      upload(name, files) {
                                                        return this.__view().dispatchUploads(null, name, files);
                                                      }
                                                      uploadTo(selectorOrTarget, name, files) {
                                                        return this.__view().withinTargets(
                                                          selectorOrTarget,
                                                          (view, targetCtx) => {
                                                            view.dispatchUploads(targetCtx, name, files);
                                                          }
                                                        );
                                                      }
                                                      /** @internal */
                                                      __cleanup__() {
                                                        this.__listeners.forEach(
                                                          (callbackRef) => this.removeHandleEvent(callbackRef)
                                                        );
                                                      }
                                                    };
                                                    var prependFormDataKey = (key, prefix) => {
                                                      const isArray = key.endsWith("[]");
                                                      let baseKey = isArray ? key.slice(0, -2) : key;
                                                      baseKey = baseKey.replace(/([^\[\]]+)(\]?$)/, `${prefix}$1$2`);
                                                      if (isArray) {
                                                        baseKey += "[]";
                                                      }
                                                      return baseKey;
                                                    };
                                                    var serializeForm = (form, opts, onlyNames = []) => {
                                                      const { submitter } = opts;
                                                      let injectedElement;
                                                      if (submitter && submitter.name) {
                                                        const input = document.createElement("input");
                                                        input.type = "hidden";
                                                        const formId = submitter.getAttribute("form");
                                                        if (formId) {
                                                          input.setAttribute("form", formId);
                                                        }
                                                        input.name = submitter.name;
                                                        input.value = submitter.value;
                                                        submitter.parentElement.insertBefore(input, submitter);
                                                        injectedElement = input;
                                                      }
                                                      const formData = new FormData(form);
                                                      const toRemove = [];
                                                      formData.forEach((val, key, _index) => {
                                                        if (val instanceof File) {
                                                          toRemove.push(key);
                                                        }
                                                      });
                                                      toRemove.forEach((key) => formData.delete(key));
                                                      const params = new URLSearchParams();
                                                      const { inputsUnused, onlyHiddenInputs } = Array.from(form.elements).reduce(
                                                        (acc, input) => {
                                                          const { inputsUnused: inputsUnused2, onlyHiddenInputs: onlyHiddenInputs2 } = acc;
                                                          const key = input.name;
                                                          if (!key) {
                                                            return acc;
                                                          }
                                                          if (inputsUnused2[key] === void 0) {
                                                            inputsUnused2[key] = true;
                                                          }
                                                          if (onlyHiddenInputs2[key] === void 0) {
                                                            onlyHiddenInputs2[key] = true;
                                                          }
                                                          const isUsed = dom_default.private(input, PHX_HAS_FOCUSED) || dom_default.private(input, PHX_HAS_SUBMITTED);
                                                          const isHidden = input.type === "hidden";
                                                          inputsUnused2[key] = inputsUnused2[key] && !isUsed;
                                                          onlyHiddenInputs2[key] = onlyHiddenInputs2[key] && isHidden;
                                                          return acc;
                                                        },
                                                        { inputsUnused: {}, onlyHiddenInputs: {} }
                                                      );
                                                      for (const [key, val] of formData.entries()) {
                                                        if (onlyNames.length === 0 || onlyNames.indexOf(key) >= 0) {
                                                          const isUnused = inputsUnused[key];
                                                          const hidden = onlyHiddenInputs[key];
                                                          if (isUnused && !(submitter && submitter.name == key) && !hidden) {
                                                            params.append(prependFormDataKey(key, "_unused_"), "");
                                                          }
                                                          if (typeof val === "string") {
                                                            params.append(key, val);
                                                          }
                                                        }
                                                      }
                                                      if (submitter && injectedElement) {
                                                        submitter.parentElement.removeChild(injectedElement);
                                                      }
                                                      return params.toString();
                                                    };
                                                    var View = class _View {
                                                      static closestView(el) {
                                                        const liveViewEl = el.closest(PHX_VIEW_SELECTOR);
                                                        return liveViewEl ? dom_default.private(liveViewEl, "view") : null;
                                                      }
                                                      constructor(el, liveSocket2, parentView, flash, liveReferer) {
                                                        this.isDead = false;
                                                        this.liveSocket = liveSocket2;
                                                        this.flash = flash;
                                                        this.parent = parentView;
                                                        this.root = parentView ? parentView.root : this;
                                                        this.el = el;
                                                        const boundView = dom_default.private(this.el, "view");
                                                        if (boundView !== void 0 && boundView.isDead !== true) {
                                                          logError(
                                                            `The DOM element for this view has already been bound to a view.

        An element can only ever be associated with a single view!
        Please ensure that you are not trying to initialize multiple LiveSockets on the same page.
        This could happen if you're accidentally trying to render your root layout more than once.
        Ensure that the template set on the LiveView is different than the root layout.
      `,
                                                            { view: boundView }
                                                          );
                                                          throw new Error("Cannot bind multiple views to the same DOM element.");
                                                        }
                                                        dom_default.putPrivate(this.el, "view", this);
                                                        this.id = this.el.id;
                                                        this.ref = 0;
                                                        this.lastAckRef = null;
                                                        this.childJoins = 0;
                                                        this.loaderTimer = null;
                                                        this.disconnectedTimer = null;
                                                        this.pendingDiffs = [];
                                                        this.pendingForms = /* @__PURE__ */ new Set();
                                                        this.redirect = false;
                                                        this.href = null;
                                                        this.joinCount = this.parent ? this.parent.joinCount - 1 : 0;
                                                        this.joinAttempts = 0;
                                                        this.joinPending = true;
                                                        this.destroyed = false;
                                                        this.joinCallback = function(onDone) {
                                                          onDone && onDone();
                                                        };
                                                        this.stopCallback = function() {
                                                        };
                                                        this.pendingJoinOps = [];
                                                        this.viewHooks = {};
                                                        this.formSubmits = [];
                                                        this.children = this.parent ? null : {};
                                                        this.root.children[this.id] = {};
                                                        this.formsForRecovery = {};
                                                        this.channel = this.liveSocket.channel(`lv:${this.id}`, () => {
                                                          const url = this.href && this.expandURL(this.href);
                                                          return {
                                                            redirect: this.redirect ? url : void 0,
                                                            url: this.redirect ? void 0 : url || void 0,
                                                            params: this.connectParams(liveReferer),
                                                            session: this.getSession(),
                                                            static: this.getStatic(),
                                                            flash: this.flash,
                                                            sticky: this.el.hasAttribute(PHX_STICKY)
                                                          };
                                                        });
                                                        this.portalElementIds = /* @__PURE__ */ new Set();
                                                      }
                                                      setHref(href) {
                                                        this.href = href;
                                                      }
                                                      setRedirect(href) {
                                                        this.redirect = true;
                                                        this.href = href;
                                                      }
                                                      isMain() {
                                                        return this.el.hasAttribute(PHX_MAIN);
                                                      }
                                                      connectParams(liveReferer) {
                                                        const params = this.liveSocket.params(this.el);
                                                        const manifest = dom_default.all(document, `[${this.binding(PHX_TRACK_STATIC)}]`).map((node) => node.src || node.href).filter((url) => typeof url === "string");
                                                        if (manifest.length > 0) {
                                                          params["_track_static"] = manifest;
                                                        }
                                                        params["_mounts"] = this.joinCount;
                                                        params["_mount_attempts"] = this.joinAttempts;
                                                        params["_live_referer"] = liveReferer;
                                                        this.joinAttempts++;
                                                        return params;
                                                      }
                                                      isConnected() {
                                                        return this.channel.canPush();
                                                      }
                                                      getSession() {
                                                        return this.el.getAttribute(PHX_SESSION);
                                                      }
                                                      getStatic() {
                                                        const val = this.el.getAttribute(PHX_STATIC);
                                                        return val === "" ? null : val;
                                                      }
                                                      destroy(callback = function() {
                                                      }) {
                                                        this.destroyAllChildren();
                                                        this.destroyPortalElements();
                                                        this.destroyed = true;
                                                        dom_default.deletePrivate(this.el, "view");
                                                        delete this.root.children[this.id];
                                                        if (this.parent) {
                                                          delete this.root.children[this.parent.id][this.id];
                                                        }
                                                        clearTimeout(this.loaderTimer);
                                                        const onFinished = () => {
                                                          callback();
                                                          for (const id in this.viewHooks) {
                                                            this.destroyHook(this.viewHooks[id]);
                                                          }
                                                        };
                                                        dom_default.markPhxChildDestroyed(this.el);
                                                        this.log("destroyed", () => ["the child has been removed from the parent"]);
                                                        this.channel.leave().receive("ok", onFinished).receive("error", onFinished).receive("timeout", onFinished);
                                                      }
                                                      setContainerClasses(...classes) {
                                                        this.el.classList.remove(
                                                          PHX_CONNECTED_CLASS,
                                                          PHX_LOADING_CLASS,
                                                          PHX_ERROR_CLASS,
                                                          PHX_CLIENT_ERROR_CLASS,
                                                          PHX_SERVER_ERROR_CLASS
                                                        );
                                                        this.el.classList.add(...classes);
                                                      }
                                                      showLoader(timeout) {
                                                        clearTimeout(this.loaderTimer);
                                                        if (timeout) {
                                                          this.loaderTimer = setTimeout(() => this.showLoader(), timeout);
                                                        } else {
                                                          for (const id in this.viewHooks) {
                                                            this.viewHooks[id].__disconnected();
                                                          }
                                                          this.setContainerClasses(PHX_LOADING_CLASS);
                                                        }
                                                      }
                                                      execAll(binding) {
                                                        dom_default.all(
                                                          this.el,
                                                          `[${binding}]`,
                                                          (el) => this.liveSocket.execJS(el, el.getAttribute(binding))
                                                        );
                                                      }
                                                      hideLoader() {
                                                        clearTimeout(this.loaderTimer);
                                                        clearTimeout(this.disconnectedTimer);
                                                        this.setContainerClasses(PHX_CONNECTED_CLASS);
                                                        this.execAll(this.binding("connected"));
                                                      }
                                                      triggerReconnected() {
                                                        for (const id in this.viewHooks) {
                                                          this.viewHooks[id].__reconnected();
                                                        }
                                                      }
                                                      log(kind, msgCallback) {
                                                        this.liveSocket.log(this, kind, msgCallback);
                                                      }
                                                      transition(time, onStart, onDone = function() {
                                                      }) {
                                                        this.liveSocket.transition(time, onStart, onDone);
                                                      }
                                                      // calls the callback with the view and target element for the given phxTarget
                                                      // targets can be:
                                                      //  * an element itself, then it is simply passed to liveSocket.owner;
                                                      //  * a CID (Component ID), then we first search the component's element in the DOM
                                                      //  * a selector, then we search the selector in the DOM and call the callback
                                                      //    for each element found with the corresponding owner view
                                                      withinTargets(phxTarget, callback, dom = document) {
                                                        if (phxTarget instanceof HTMLElement || phxTarget instanceof SVGElement) {
                                                          return this.liveSocket.owner(
                                                            phxTarget,
                                                            (view) => callback(view, phxTarget)
                                                          );
                                                        }
                                                        if (isCid(phxTarget)) {
                                                          const targets = dom_default.findComponentNodeList(this.id, phxTarget, dom);
                                                          if (targets.length === 0) {
                                                            logError(`no component found matching phx-target of ${phxTarget}`);
                                                          } else {
                                                            callback(this, parseInt(phxTarget));
                                                          }
                                                        } else {
                                                          const targets = Array.from(dom.querySelectorAll(phxTarget));
                                                          if (targets.length === 0) {
                                                            logError(
                                                              `nothing found matching the phx-target selector "${phxTarget}"`
                                                            );
                                                          }
                                                          targets.forEach(
                                                            (target) => this.liveSocket.owner(target, (view) => callback(view, target))
                                                          );
                                                        }
                                                      }
                                                      applyDiff(type, rawDiff, callback) {
                                                        this.log(type, () => ["", clone(rawDiff)]);
                                                        const { diff, reply, events, title } = Rendered.extract(rawDiff);
                                                        const ev = events.reduce(
                                                          (acc, args) => {
                                                            if (args.length === 3 && args[2] == true) {
                                                              acc.pre.push(args.slice(0, -1));
                                                            } else {
                                                              acc.post.push(args);
                                                            }
                                                            return acc;
                                                          },
                                                          { pre: [], post: [] }
                                                        );
                                                        this.liveSocket.dispatchEvents(ev.pre);
                                                        const update = () => {
                                                          callback({ diff, reply, events: ev.post });
                                                          if (typeof title === "string" || type == "mount" && this.isMain()) {
                                                            window.requestAnimationFrame(() => dom_default.putTitle(title));
                                                          }
                                                        };
                                                        if ("onDocumentPatch" in this.liveSocket.domCallbacks) {
                                                          this.liveSocket.triggerDOM("onDocumentPatch", [update]);
                                                        } else {
                                                          update();
                                                        }
                                                      }
                                                      onJoin(resp) {
                                                        const { rendered, container, liveview_version, pid } = resp;
                                                        if (container) {
                                                          const [tag, attrs] = container;
                                                          this.el = dom_default.replaceRootContainer(this.el, tag, attrs);
                                                        }
                                                        this.childJoins = 0;
                                                        this.joinPending = true;
                                                        this.flash = null;
                                                        if (this.root === this) {
                                                          this.formsForRecovery = this.getFormsForRecovery();
                                                        }
                                                        if (this.isMain() && window.history.state === null) {
                                                          browser_default.pushState("replace", {
                                                            type: "patch",
                                                            id: this.id,
                                                            position: this.liveSocket.currentHistoryPosition
                                                          });
                                                        }
                                                        if (liveview_version !== this.liveSocket.version()) {
                                                          console.warn(
                                                            `LiveView asset version mismatch. JavaScript version ${this.liveSocket.version()} vs. server ${liveview_version}. To avoid issues, please ensure that your assets use the same version as the server.`
                                                          );
                                                        }
                                                        if (pid) {
                                                          this.el.setAttribute(PHX_LV_PID, pid);
                                                        }
                                                        browser_default.dropLocal(
                                                          this.liveSocket.localStorage,
                                                          window.location.pathname,
                                                          CONSECUTIVE_RELOADS
                                                        );
                                                        this.applyDiff("mount", rendered, ({ diff, events }) => {
                                                          this.rendered = new Rendered(this.id, diff);
                                                          const [html, streams] = this.renderContainer(null, "join");
                                                          this.dropPendingRefs();
                                                          this.joinCount++;
                                                          this.joinAttempts = 0;
                                                          this.maybeRecoverForms(html, () => {
                                                            this.onJoinComplete(resp, html, streams, events);
                                                          });
                                                        });
                                                      }
                                                      dropPendingRefs() {
                                                        dom_default.all(document, `[${PHX_REF_SRC}="${this.refSrc()}"]`, (el) => {
                                                          el.removeAttribute(PHX_REF_LOADING);
                                                          el.removeAttribute(PHX_REF_SRC);
                                                          el.removeAttribute(PHX_REF_LOCK);
                                                        });
                                                      }
                                                      onJoinComplete({ live_patch }, html, streams, events) {
                                                        if (this.joinCount > 1 || this.parent && !this.parent.isJoinPending()) {
                                                          return this.applyJoinPatch(live_patch, html, streams, events);
                                                        }
                                                        const newChildren = dom_default.findPhxChildrenInFragment(html, this.id).filter(
                                                          (toEl) => {
                                                            const fromEl = toEl.id && this.el.querySelector(`[id="${toEl.id}"]`);
                                                            const phxStatic = fromEl && fromEl.getAttribute(PHX_STATIC);
                                                            if (phxStatic) {
                                                              toEl.setAttribute(PHX_STATIC, phxStatic);
                                                            }
                                                            if (fromEl) {
                                                              fromEl.setAttribute(PHX_ROOT_ID, this.root.id);
                                                            }
                                                            return this.joinChild(toEl);
                                                          }
                                                        );
                                                        if (newChildren.length === 0) {
                                                          if (this.parent) {
                                                            this.root.pendingJoinOps.push([
                                                              this,
                                                              () => this.applyJoinPatch(live_patch, html, streams, events)
                                                            ]);
                                                            this.parent.ackJoin(this);
                                                          } else {
                                                            this.onAllChildJoinsComplete();
                                                            this.applyJoinPatch(live_patch, html, streams, events);
                                                          }
                                                        } else {
                                                          this.root.pendingJoinOps.push([
                                                            this,
                                                            () => this.applyJoinPatch(live_patch, html, streams, events)
                                                          ]);
                                                        }
                                                      }
                                                      attachTrueDocEl() {
                                                        this.el = dom_default.byId(this.id);
                                                        this.el.setAttribute(PHX_ROOT_ID, this.root.id);
                                                      }
                                                      // this is invoked for dead and live views, so we must filter by
                                                      // by owner to ensure we aren't duplicating hooks across disconnect
                                                      // and connected states. This also handles cases where hooks exist
                                                      // in a root layout with a LV in the body
                                                      execNewMounted(parent = document) {
                                                        let phxViewportTop = this.binding(PHX_VIEWPORT_TOP);
                                                        let phxViewportBottom = this.binding(PHX_VIEWPORT_BOTTOM);
                                                        this.all(
                                                          parent,
                                                          `[${phxViewportTop}], [${phxViewportBottom}]`,
                                                          (hookEl) => {
                                                            dom_default.maintainPrivateHooks(
                                                              hookEl,
                                                              hookEl,
                                                              phxViewportTop,
                                                              phxViewportBottom
                                                            );
                                                            this.maybeAddNewHook(hookEl);
                                                          }
                                                        );
                                                        this.all(
                                                          parent,
                                                          `[${this.binding(PHX_HOOK)}], [data-phx-${PHX_HOOK}]`,
                                                          (hookEl) => {
                                                            this.maybeAddNewHook(hookEl);
                                                          }
                                                        );
                                                        this.all(parent, `[${this.binding(PHX_MOUNTED)}]`, (el) => {
                                                          this.maybeMounted(el);
                                                        });
                                                      }
                                                      all(parent, selector, callback) {
                                                        dom_default.all(parent, selector, (el) => {
                                                          if (this.ownsElement(el)) {
                                                            callback(el);
                                                          }
                                                        });
                                                      }
                                                      applyJoinPatch(live_patch, html, streams, events) {
                                                        if (this.joinCount > 1) {
                                                          if (this.pendingJoinOps.length) {
                                                            this.pendingJoinOps.forEach((cb) => typeof cb === "function" && cb());
                                                            this.pendingJoinOps = [];
                                                          }
                                                        }
                                                        this.attachTrueDocEl();
                                                        const patch = new DOMPatch(this, this.el, this.id, html, streams, null);
                                                        patch.markPrunableContentForRemoval();
                                                        this.performPatch(patch, false, true);
                                                        this.joinNewChildren();
                                                        this.execNewMounted();
                                                        this.joinPending = false;
                                                        this.liveSocket.dispatchEvents(events);
                                                        this.applyPendingUpdates();
                                                        if (live_patch) {
                                                          const { kind, to } = live_patch;
                                                          this.liveSocket.historyPatch(to, kind);
                                                        }
                                                        this.hideLoader();
                                                        if (this.joinCount > 1) {
                                                          this.triggerReconnected();
                                                        }
                                                        this.stopCallback();
                                                      }
                                                      triggerBeforeUpdateHook(fromEl, toEl) {
                                                        this.liveSocket.triggerDOM("onBeforeElUpdated", [fromEl, toEl]);
                                                        const hook = this.getHook(fromEl);
                                                        const isIgnored = hook && dom_default.isIgnored(fromEl, this.binding(PHX_UPDATE));
                                                        if (hook && !fromEl.isEqualNode(toEl) && !(isIgnored && isEqualObj(fromEl.dataset, toEl.dataset))) {
                                                          hook.__beforeUpdate();
                                                          return hook;
                                                        }
                                                      }
                                                      maybeMounted(el) {
                                                        const phxMounted = el.getAttribute(this.binding(PHX_MOUNTED));
                                                        const hasBeenInvoked = phxMounted && dom_default.private(el, "mounted");
                                                        if (phxMounted && !hasBeenInvoked) {
                                                          this.liveSocket.execJS(el, phxMounted);
                                                          dom_default.putPrivate(el, "mounted", true);
                                                        }
                                                      }
                                                      maybeAddNewHook(el) {
                                                        const newHook = this.addHook(el);
                                                        if (newHook) {
                                                          newHook.__mounted();
                                                        }
                                                      }
                                                      performPatch(patch, pruneCids, isJoinPatch = false) {
                                                        const removedEls = [];
                                                        let phxChildrenAdded = false;
                                                        const updatedHookIds = /* @__PURE__ */ new Set();
                                                        this.liveSocket.triggerDOM("onPatchStart", [patch.targetContainer]);
                                                        patch.after("added", (el) => {
                                                          this.liveSocket.triggerDOM("onNodeAdded", [el]);
                                                          const phxViewportTop = this.binding(PHX_VIEWPORT_TOP);
                                                          const phxViewportBottom = this.binding(PHX_VIEWPORT_BOTTOM);
                                                          dom_default.maintainPrivateHooks(el, el, phxViewportTop, phxViewportBottom);
                                                          this.maybeAddNewHook(el);
                                                          if (el.getAttribute) {
                                                            this.maybeMounted(el);
                                                          }
                                                        });
                                                        patch.after("phxChildAdded", (el) => {
                                                          if (dom_default.isPhxSticky(el)) {
                                                            this.liveSocket.joinRootViews();
                                                          } else {
                                                            phxChildrenAdded = true;
                                                          }
                                                        });
                                                        patch.before("updated", (fromEl, toEl) => {
                                                          const hook = this.triggerBeforeUpdateHook(fromEl, toEl);
                                                          if (hook) {
                                                            updatedHookIds.add(fromEl.id);
                                                          }
                                                          js_default.onBeforeElUpdated(fromEl, toEl);
                                                        });
                                                        patch.after("updated", (el) => {
                                                          if (updatedHookIds.has(el.id)) {
                                                            this.getHook(el).__updated();
                                                          }
                                                        });
                                                        patch.after("discarded", (el) => {
                                                          if (el.nodeType === Node.ELEMENT_NODE) {
                                                            removedEls.push(el);
                                                          }
                                                        });
                                                        patch.after(
                                                          "transitionsDiscarded",
                                                          (els) => this.afterElementsRemoved(els, pruneCids)
                                                        );
                                                        patch.perform(isJoinPatch);
                                                        this.afterElementsRemoved(removedEls, pruneCids);
                                                        this.liveSocket.triggerDOM("onPatchEnd", [patch.targetContainer]);
                                                        return phxChildrenAdded;
                                                      }
                                                      afterElementsRemoved(elements, pruneCids) {
                                                        const destroyedCIDs = [];
                                                        elements.forEach((parent) => {
                                                          const components = dom_default.all(
                                                            parent,
                                                            `[${PHX_VIEW_REF}="${this.id}"][${PHX_COMPONENT}]`
                                                          );
                                                          const hooks = dom_default.all(
                                                            parent,
                                                            `[${this.binding(PHX_HOOK)}], [data-phx-hook]`
                                                          );
                                                          components.concat(parent).forEach((el) => {
                                                            const cid = this.componentID(el);
                                                            if (isCid(cid) && destroyedCIDs.indexOf(cid) === -1 && el.getAttribute(PHX_VIEW_REF) === this.id) {
                                                              destroyedCIDs.push(cid);
                                                            }
                                                          });
                                                          hooks.concat(parent).forEach((hookEl) => {
                                                            const hook = this.getHook(hookEl);
                                                            hook && this.destroyHook(hook);
                                                          });
                                                        });
                                                        if (pruneCids) {
                                                          this.maybePushComponentsDestroyed(destroyedCIDs);
                                                        }
                                                      }
                                                      joinNewChildren() {
                                                        dom_default.findPhxChildren(document, this.id).forEach((el) => this.joinChild(el));
                                                      }
                                                      maybeRecoverForms(html, callback) {
                                                        const phxChange = this.binding("change");
                                                        const oldForms = this.root.formsForRecovery;
                                                        const template = document.createElement("template");
                                                        template.innerHTML = html;
                                                        dom_default.all(template.content, `[${PHX_PORTAL}]`).forEach((portalTemplate) => {
                                                          template.content.firstElementChild.appendChild(
                                                            portalTemplate.content.firstElementChild
                                                          );
                                                        });
                                                        const rootEl = template.content.firstElementChild;
                                                        rootEl.id = this.id;
                                                        rootEl.setAttribute(PHX_ROOT_ID, this.root.id);
                                                        rootEl.setAttribute(PHX_SESSION, this.getSession());
                                                        rootEl.setAttribute(PHX_STATIC, this.getStatic());
                                                        rootEl.setAttribute(PHX_PARENT_ID, this.parent ? this.parent.id : null);
                                                        const formsToRecover = (
                                                          // we go over all forms in the new DOM; because this is only the HTML for the current
                                                          // view, we can be sure that all forms are owned by this view:
                                                          dom_default.all(template.content, "form").filter((newForm) => newForm.id && oldForms[newForm.id]).filter((newForm) => !this.pendingForms.has(newForm.id)).filter(
                                                            (newForm) => oldForms[newForm.id].getAttribute(phxChange) === newForm.getAttribute(phxChange)
                                                          ).map((newForm) => {
                                                            return [oldForms[newForm.id], newForm];
                                                          })
                                                        );
                                                        if (formsToRecover.length === 0) {
                                                          return callback();
                                                        }
                                                        formsToRecover.forEach(([oldForm, newForm], i) => {
                                                          this.pendingForms.add(newForm.id);
                                                          this.pushFormRecovery(
                                                            oldForm,
                                                            newForm,
                                                            template.content.firstElementChild,
                                                            () => {
                                                              this.pendingForms.delete(newForm.id);
                                                              if (i === formsToRecover.length - 1) {
                                                                callback();
                                                              }
                                                            }
                                                          );
                                                        });
                                                      }
                                                      getChildById(id) {
                                                        return this.root.children[this.id][id];
                                                      }
                                                      getDescendentByEl(el) {
                                                        if (el.id === this.id) {
                                                          return this;
                                                        } else {
                                                          return this.children[el.getAttribute(PHX_PARENT_ID)]?.[el.id];
                                                        }
                                                      }
                                                      destroyDescendent(id) {
                                                        for (const parentId in this.root.children) {
                                                          for (const childId in this.root.children[parentId]) {
                                                            if (childId === id) {
                                                              return this.root.children[parentId][childId].destroy();
                                                            }
                                                          }
                                                        }
                                                      }
                                                      joinChild(el) {
                                                        const child = this.getChildById(el.id);
                                                        if (!child) {
                                                          const view = new _View(el, this.liveSocket, this);
                                                          this.root.children[this.id][view.id] = view;
                                                          view.join();
                                                          this.childJoins++;
                                                          return true;
                                                        }
                                                      }
                                                      isJoinPending() {
                                                        return this.joinPending;
                                                      }
                                                      ackJoin(_child) {
                                                        this.childJoins--;
                                                        if (this.childJoins === 0) {
                                                          if (this.parent) {
                                                            this.parent.ackJoin(this);
                                                          } else {
                                                            this.onAllChildJoinsComplete();
                                                          }
                                                        }
                                                      }
                                                      onAllChildJoinsComplete() {
                                                        this.pendingForms.clear();
                                                        this.formsForRecovery = {};
                                                        this.joinCallback(() => {
                                                          this.pendingJoinOps.forEach(([view, op]) => {
                                                            if (!view.isDestroyed()) {
                                                              op();
                                                            }
                                                          });
                                                          this.pendingJoinOps = [];
                                                        });
                                                      }
                                                      update(diff, events, isPending = false) {
                                                        if (this.isJoinPending() || this.liveSocket.hasPendingLink() && this.root.isMain()) {
                                                          if (!isPending) {
                                                            this.pendingDiffs.push({ diff, events });
                                                          }
                                                          return false;
                                                        }
                                                        this.rendered.mergeDiff(diff);
                                                        let phxChildrenAdded = false;
                                                        if (this.rendered.isComponentOnlyDiff(diff)) {
                                                          this.liveSocket.time("component patch complete", () => {
                                                            const parentCids = dom_default.findExistingParentCIDs(
                                                              this.id,
                                                              this.rendered.componentCIDs(diff)
                                                            );
                                                            parentCids.forEach((parentCID) => {
                                                              if (this.componentPatch(
                                                                this.rendered.getComponent(diff, parentCID),
                                                                parentCID
                                                              )) {
                                                                phxChildrenAdded = true;
                                                              }
                                                            });
                                                          });
                                                        } else if (!isEmpty(diff)) {
                                                          this.liveSocket.time("full patch complete", () => {
                                                            const [html, streams] = this.renderContainer(diff, "update");
                                                            const patch = new DOMPatch(this, this.el, this.id, html, streams, null);
                                                            phxChildrenAdded = this.performPatch(patch, true);
                                                          });
                                                        }
                                                        this.liveSocket.dispatchEvents(events);
                                                        if (phxChildrenAdded) {
                                                          this.joinNewChildren();
                                                        }
                                                        return true;
                                                      }
                                                      renderContainer(diff, kind) {
                                                        return this.liveSocket.time(`toString diff (${kind})`, () => {
                                                          const tag = this.el.tagName;
                                                          const cids = diff ? this.rendered.componentCIDs(diff) : null;
                                                          const { buffer: html, streams } = this.rendered.toString(cids);
                                                          return [`<${tag}>${html}</${tag}>`, streams];
                                                        });
                                                      }
                                                      componentPatch(diff, cid) {
                                                        if (isEmpty(diff))
                                                          return false;
                                                        const { buffer: html, streams } = this.rendered.componentToString(cid);
                                                        const patch = new DOMPatch(this, this.el, this.id, html, streams, cid);
                                                        const childrenAdded = this.performPatch(patch, true);
                                                        return childrenAdded;
                                                      }
                                                      getHook(el) {
                                                        return this.viewHooks[ViewHook.elementID(el)];
                                                      }
                                                      addHook(el) {
                                                        const hookElId = ViewHook.elementID(el);
                                                        if (el.getAttribute && !this.ownsElement(el)) {
                                                          return;
                                                        }
                                                        if (hookElId && !this.viewHooks[hookElId]) {
                                                          const hook = dom_default.getCustomElHook(el) || logError(`no hook found for custom element: ${el.id}`);
                                                          this.viewHooks[hookElId] = hook;
                                                          hook.__attachView(this);
                                                          return hook;
                                                        } else if (hookElId || !el.getAttribute) {
                                                          return;
                                                        } else {
                                                          const hookName = el.getAttribute(`data-phx-${PHX_HOOK}`) || el.getAttribute(this.binding(PHX_HOOK));
                                                          if (!hookName) {
                                                            return;
                                                          }
                                                          const hookDefinition = this.liveSocket.getHookDefinition(hookName);
                                                          if (hookDefinition) {
                                                            if (!el.id) {
                                                              logError(
                                                                `no DOM ID for hook "${hookName}". Hooks require a unique ID on each element.`,
                                                                el
                                                              );
                                                              return;
                                                            }
                                                            let hookInstance;
                                                            try {
                                                              if (typeof hookDefinition === "function" && hookDefinition.prototype instanceof ViewHook) {
                                                                hookInstance = new hookDefinition(this, el);
                                                              } else if (typeof hookDefinition === "object" && hookDefinition !== null) {
                                                                hookInstance = new ViewHook(this, el, hookDefinition);
                                                              } else {
                                                                logError(
                                                                  `Invalid hook definition for "${hookName}". Expected a class extending ViewHook or an object definition.`,
                                                                  el
                                                                );
                                                                return;
                                                              }
                                                            } catch (e) {
                                                              const errorMessage = e instanceof Error ? e.message : String(e);
                                                              logError(`Failed to create hook "${hookName}": ${errorMessage}`, el);
                                                              return;
                                                            }
                                                            this.viewHooks[ViewHook.elementID(hookInstance.el)] = hookInstance;
                                                            return hookInstance;
                                                          } else if (hookName !== null) {
                                                            logError(`unknown hook found for "${hookName}"`, el);
                                                          }
                                                        }
                                                      }
                                                      destroyHook(hook) {
                                                        const hookId = ViewHook.elementID(hook.el);
                                                        hook.__destroyed();
                                                        hook.__cleanup__();
                                                        delete this.viewHooks[hookId];
                                                      }
                                                      applyPendingUpdates() {
                                                        this.pendingDiffs = this.pendingDiffs.filter(
                                                          ({ diff, events }) => !this.update(diff, events, true)
                                                        );
                                                        this.eachChild((child) => child.applyPendingUpdates());
                                                      }
                                                      eachChild(callback) {
                                                        const children = this.root.children[this.id] || {};
                                                        for (const id in children) {
                                                          callback(this.getChildById(id));
                                                        }
                                                      }
                                                      onChannel(event, cb) {
                                                        this.liveSocket.onChannel(this.channel, event, (resp) => {
                                                          if (this.isJoinPending()) {
                                                            if (this.joinCount > 1) {
                                                              this.pendingJoinOps.push(() => cb(resp));
                                                            } else {
                                                              this.root.pendingJoinOps.push([this, () => cb(resp)]);
                                                            }
                                                          } else {
                                                            this.liveSocket.requestDOMUpdate(() => cb(resp));
                                                          }
                                                        });
                                                      }
                                                      bindChannel() {
                                                        this.liveSocket.onChannel(this.channel, "diff", (rawDiff) => {
                                                          this.liveSocket.requestDOMUpdate(() => {
                                                            this.applyDiff(
                                                              "update",
                                                              rawDiff,
                                                              ({ diff, events }) => this.update(diff, events)
                                                            );
                                                          });
                                                        });
                                                        this.onChannel(
                                                          "redirect",
                                                          ({ to, flash }) => this.onRedirect({ to, flash })
                                                        );
                                                        this.onChannel("live_patch", (redir) => this.onLivePatch(redir));
                                                        this.onChannel("live_redirect", (redir) => this.onLiveRedirect(redir));
                                                        this.channel.onError((reason) => this.onError(reason));
                                                        this.channel.onClose((reason) => this.onClose(reason));
                                                      }
                                                      destroyAllChildren() {
                                                        this.eachChild((child) => child.destroy());
                                                      }
                                                      onLiveRedirect(redir) {
                                                        const { to, kind, flash } = redir;
                                                        const url = this.expandURL(to);
                                                        const e = new CustomEvent("phx:server-navigate", {
                                                          detail: { to, kind, flash }
                                                        });
                                                        this.liveSocket.historyRedirect(e, url, kind, flash);
                                                      }
                                                      onLivePatch(redir) {
                                                        const { to, kind } = redir;
                                                        this.href = this.expandURL(to);
                                                        this.liveSocket.historyPatch(to, kind);
                                                      }
                                                      expandURL(to) {
                                                        return to.startsWith("/") ? `${window.location.protocol}//${window.location.host}${to}` : to;
                                                      }
                                                      /**
                                                       * @param {{to: string, flash?: string, reloadToken?: string}} redirect
                                                       */
                                                      onRedirect({ to, flash, reloadToken }) {
                                                        this.liveSocket.redirect(to, flash, reloadToken);
                                                      }
                                                      isDestroyed() {
                                                        return this.destroyed;
                                                      }
                                                      joinDead() {
                                                        this.isDead = true;
                                                      }
                                                      joinPush() {
                                                        this.joinPush = this.joinPush || this.channel.join();
                                                        return this.joinPush;
                                                      }
                                                      join(callback) {
                                                        this.showLoader(this.liveSocket.loaderTimeout);
                                                        this.bindChannel();
                                                        if (this.isMain()) {
                                                          this.stopCallback = this.liveSocket.withPageLoading({
                                                            to: this.href,
                                                            kind: "initial"
                                                          });
                                                        }
                                                        this.joinCallback = (onDone) => {
                                                          onDone = onDone || function() {
                                                          };
                                                          callback ? callback(this.joinCount, onDone) : onDone();
                                                        };
                                                        this.wrapPush(() => this.channel.join(), {
                                                          ok: (resp) => this.liveSocket.requestDOMUpdate(() => this.onJoin(resp)),
                                                          error: (error) => this.onJoinError(error),
                                                          timeout: () => this.onJoinError({ reason: "timeout" })
                                                        });
                                                      }
                                                      onJoinError(resp) {
                                                        if (resp.reason === "reload") {
                                                          this.log("error", () => [
                                                            `failed mount with ${resp.status}. Falling back to page reload`,
                                                            resp
                                                          ]);
                                                          this.onRedirect({
                                                            to: this.liveSocket.main.href,
                                                            reloadToken: resp.token
                                                          });
                                                          return;
                                                        } else if (resp.reason === "unauthorized" || resp.reason === "stale") {
                                                          this.log("error", () => [
                                                            "unauthorized live_redirect. Falling back to page request",
                                                            resp
                                                          ]);
                                                          this.onRedirect({ to: this.liveSocket.main.href, flash: this.flash });
                                                          return;
                                                        }
                                                        if (resp.redirect || resp.live_redirect) {
                                                          this.joinPending = false;
                                                          this.channel.leave();
                                                        }
                                                        if (resp.redirect) {
                                                          return this.onRedirect(resp.redirect);
                                                        }
                                                        if (resp.live_redirect) {
                                                          return this.onLiveRedirect(resp.live_redirect);
                                                        }
                                                        this.log("error", () => ["unable to join", resp]);
                                                        if (this.isMain()) {
                                                          this.displayError(
                                                            [PHX_LOADING_CLASS, PHX_ERROR_CLASS, PHX_SERVER_ERROR_CLASS],
                                                            { unstructuredError: resp, errorKind: "server" }
                                                          );
                                                          if (this.liveSocket.isConnected()) {
                                                            this.liveSocket.reloadWithJitter(this);
                                                          }
                                                        } else {
                                                          if (this.joinAttempts >= MAX_CHILD_JOIN_ATTEMPTS) {
                                                            this.root.displayError(
                                                              [PHX_LOADING_CLASS, PHX_ERROR_CLASS, PHX_SERVER_ERROR_CLASS],
                                                              { unstructuredError: resp, errorKind: "server" }
                                                            );
                                                            this.log("error", () => [
                                                              `giving up trying to mount after ${MAX_CHILD_JOIN_ATTEMPTS} tries`,
                                                              resp
                                                            ]);
                                                            this.destroy();
                                                          }
                                                          const trueChildEl = dom_default.byId(this.el.id);
                                                          if (trueChildEl) {
                                                            dom_default.mergeAttrs(trueChildEl, this.el);
                                                            this.displayError(
                                                              [PHX_LOADING_CLASS, PHX_ERROR_CLASS, PHX_SERVER_ERROR_CLASS],
                                                              { unstructuredError: resp, errorKind: "server" }
                                                            );
                                                            this.el = trueChildEl;
                                                          } else {
                                                            this.destroy();
                                                          }
                                                        }
                                                      }
                                                      onClose(reason) {
                                                        if (this.isDestroyed()) {
                                                          return;
                                                        }
                                                        if (this.isMain() && this.liveSocket.hasPendingLink() && reason !== "leave") {
                                                          return this.liveSocket.reloadWithJitter(this);
                                                        }
                                                        this.destroyAllChildren();
                                                        this.liveSocket.dropActiveElement(this);
                                                        if (this.liveSocket.isUnloaded()) {
                                                          this.showLoader(BEFORE_UNLOAD_LOADER_TIMEOUT);
                                                        }
                                                      }
                                                      onError(reason) {
                                                        this.onClose(reason);
                                                        if (this.liveSocket.isConnected()) {
                                                          this.log("error", () => ["view crashed", reason]);
                                                        }
                                                        if (!this.liveSocket.isUnloaded()) {
                                                          if (this.liveSocket.isConnected()) {
                                                            this.displayError(
                                                              [PHX_LOADING_CLASS, PHX_ERROR_CLASS, PHX_SERVER_ERROR_CLASS],
                                                              { unstructuredError: reason, errorKind: "server" }
                                                            );
                                                          } else {
                                                            this.displayError(
                                                              [PHX_LOADING_CLASS, PHX_ERROR_CLASS, PHX_CLIENT_ERROR_CLASS],
                                                              { unstructuredError: reason, errorKind: "client" }
                                                            );
                                                          }
                                                        }
                                                      }
                                                      displayError(classes, details = {}) {
                                                        if (this.isMain()) {
                                                          dom_default.dispatchEvent(window, "phx:page-loading-start", {
                                                            detail: { to: this.href, kind: "error", ...details }
                                                          });
                                                        }
                                                        this.showLoader();
                                                        this.setContainerClasses(...classes);
                                                        this.delayedDisconnected();
                                                      }
                                                      delayedDisconnected() {
                                                        this.disconnectedTimer = setTimeout(() => {
                                                          this.execAll(this.binding("disconnected"));
                                                        }, this.liveSocket.disconnectedTimeout);
                                                      }
                                                      wrapPush(callerPush, receives) {
                                                        const latency = this.liveSocket.getLatencySim();
                                                        const withLatency = latency ? (cb) => setTimeout(() => !this.isDestroyed() && cb(), latency) : (cb) => !this.isDestroyed() && cb();
                                                        withLatency(() => {
                                                          callerPush().receive(
                                                            "ok",
                                                            (resp) => withLatency(() => receives.ok && receives.ok(resp))
                                                          ).receive(
                                                            "error",
                                                            (reason) => withLatency(() => receives.error && receives.error(reason))
                                                          ).receive(
                                                            "timeout",
                                                            () => withLatency(() => receives.timeout && receives.timeout())
                                                          );
                                                        });
                                                      }
                                                      pushWithReply(refGenerator, event, payload) {
                                                        if (!this.isConnected()) {
                                                          return Promise.reject(new Error("no connection"));
                                                        }
                                                        const [ref, [el], opts] = refGenerator ? refGenerator({ payload }) : [null, [], {}];
                                                        const oldJoinCount = this.joinCount;
                                                        let onLoadingDone = function() {
                                                        };
                                                        if (opts.page_loading) {
                                                          onLoadingDone = this.liveSocket.withPageLoading({
                                                            kind: "element",
                                                            target: el
                                                          });
                                                        }
                                                        if (typeof payload.cid !== "number") {
                                                          delete payload.cid;
                                                        }
                                                        return new Promise((resolve, reject) => {
                                                          this.wrapPush(() => this.channel.push(event, payload, PUSH_TIMEOUT), {
                                                            ok: (resp) => {
                                                              if (ref !== null) {
                                                                this.lastAckRef = ref;
                                                              }
                                                              const finish = (hookReply) => {
                                                                if (resp.redirect) {
                                                                  this.onRedirect(resp.redirect);
                                                                }
                                                                if (resp.live_patch) {
                                                                  this.onLivePatch(resp.live_patch);
                                                                }
                                                                if (resp.live_redirect) {
                                                                  this.onLiveRedirect(resp.live_redirect);
                                                                }
                                                                onLoadingDone();
                                                                resolve({ resp, reply: hookReply, ref });
                                                              };
                                                              if (resp.diff) {
                                                                this.liveSocket.requestDOMUpdate(() => {
                                                                  this.applyDiff("update", resp.diff, ({ diff, reply, events }) => {
                                                                    if (ref !== null) {
                                                                      this.undoRefs(ref, payload.event);
                                                                    }
                                                                    this.update(diff, events);
                                                                    finish(reply);
                                                                  });
                                                                });
                                                              } else {
                                                                if (ref !== null) {
                                                                  this.undoRefs(ref, payload.event);
                                                                }
                                                                finish(null);
                                                              }
                                                            },
                                                            error: (reason) => reject(new Error(`failed with reason: ${JSON.stringify(reason)}`)),
                                                            timeout: () => {
                                                              reject(new Error("timeout"));
                                                              if (this.joinCount === oldJoinCount) {
                                                                this.liveSocket.reloadWithJitter(this, () => {
                                                                  this.log("timeout", () => [
                                                                    "received timeout while communicating with server. Falling back to hard refresh for recovery"
                                                                  ]);
                                                                });
                                                              }
                                                            }
                                                          });
                                                        });
                                                      }
                                                      undoRefs(ref, phxEvent, onlyEls) {
                                                        if (!this.isConnected()) {
                                                          return;
                                                        }
                                                        const selector = `[${PHX_REF_SRC}="${this.refSrc()}"]`;
                                                        if (onlyEls) {
                                                          onlyEls = new Set(onlyEls);
                                                          dom_default.all(document, selector, (parent) => {
                                                            if (onlyEls && !onlyEls.has(parent)) {
                                                              return;
                                                            }
                                                            dom_default.all(
                                                              parent,
                                                              selector,
                                                              (child) => this.undoElRef(child, ref, phxEvent)
                                                            );
                                                            this.undoElRef(parent, ref, phxEvent);
                                                          });
                                                        } else {
                                                          dom_default.all(document, selector, (el) => this.undoElRef(el, ref, phxEvent));
                                                        }
                                                      }
                                                      undoElRef(el, ref, phxEvent) {
                                                        const elRef = new ElementRef(el);
                                                        elRef.maybeUndo(ref, phxEvent, (clonedTree) => {
                                                          const patch = new DOMPatch(this, el, this.id, clonedTree, [], null, {
                                                            undoRef: ref
                                                          });
                                                          const phxChildrenAdded = this.performPatch(patch, true);
                                                          dom_default.all(
                                                            el,
                                                            `[${PHX_REF_SRC}="${this.refSrc()}"]`,
                                                            (child) => this.undoElRef(child, ref, phxEvent)
                                                          );
                                                          if (phxChildrenAdded) {
                                                            this.joinNewChildren();
                                                          }
                                                        });
                                                      }
                                                      refSrc() {
                                                        return this.el.id;
                                                      }
                                                      putRef(elements, phxEvent, eventType, opts = {}) {
                                                        const newRef = this.ref++;
                                                        const disableWith = this.binding(PHX_DISABLE_WITH);
                                                        if (opts.loading) {
                                                          const loadingEls = dom_default.all(document, opts.loading).map((el) => {
                                                            return { el, lock: true, loading: true };
                                                          });
                                                          elements = elements.concat(loadingEls);
                                                        }
                                                        for (const { el, lock, loading } of elements) {
                                                          if (!lock && !loading) {
                                                            throw new Error("putRef requires lock or loading");
                                                          }
                                                          el.setAttribute(PHX_REF_SRC, this.refSrc());
                                                          if (loading) {
                                                            el.setAttribute(PHX_REF_LOADING, newRef);
                                                          }
                                                          if (lock) {
                                                            el.setAttribute(PHX_REF_LOCK, newRef);
                                                          }
                                                          if (!loading || opts.submitter && !(el === opts.submitter || el === opts.form)) {
                                                            continue;
                                                          }
                                                          const lockCompletePromise = new Promise((resolve) => {
                                                            el.addEventListener(`phx:undo-lock:${newRef}`, () => resolve(detail), {
                                                              once: true
                                                            });
                                                          });
                                                          const loadingCompletePromise = new Promise((resolve) => {
                                                            el.addEventListener(
                                                              `phx:undo-loading:${newRef}`,
                                                              () => resolve(detail),
                                                              { once: true }
                                                            );
                                                          });
                                                          el.classList.add(`phx-${eventType}-loading`);
                                                          const disableText = el.getAttribute(disableWith);
                                                          if (disableText !== null) {
                                                            if (!el.getAttribute(PHX_DISABLE_WITH_RESTORE)) {
                                                              el.setAttribute(PHX_DISABLE_WITH_RESTORE, el.textContent);
                                                            }
                                                            if (disableText !== "") {
                                                              el.textContent = disableText;
                                                            }
                                                            el.setAttribute(
                                                              PHX_DISABLED,
                                                              el.getAttribute(PHX_DISABLED) || el.disabled
                                                            );
                                                            el.setAttribute("disabled", "");
                                                          }
                                                          const detail = {
                                                            event: phxEvent,
                                                            eventType,
                                                            ref: newRef,
                                                            isLoading: loading,
                                                            isLocked: lock,
                                                            lockElements: elements.filter(({ lock: lock2 }) => lock2).map(({ el: el2 }) => el2),
                                                            loadingElements: elements.filter(({ loading: loading2 }) => loading2).map(({ el: el2 }) => el2),
                                                            unlock: (els) => {
                                                              els = Array.isArray(els) ? els : [els];
                                                              this.undoRefs(newRef, phxEvent, els);
                                                            },
                                                            lockComplete: lockCompletePromise,
                                                            loadingComplete: loadingCompletePromise,
                                                            lock: (lockEl) => {
                                                              return new Promise((resolve) => {
                                                                if (this.isAcked(newRef)) {
                                                                  return resolve(detail);
                                                                }
                                                                lockEl.setAttribute(PHX_REF_LOCK, newRef);
                                                                lockEl.setAttribute(PHX_REF_SRC, this.refSrc());
                                                                lockEl.addEventListener(
                                                                  `phx:lock-stop:${newRef}`,
                                                                  () => resolve(detail),
                                                                  { once: true }
                                                                );
                                                              });
                                                            }
                                                          };
                                                          if (opts.payload) {
                                                            detail["payload"] = opts.payload;
                                                          }
                                                          if (opts.target) {
                                                            detail["target"] = opts.target;
                                                          }
                                                          if (opts.originalEvent) {
                                                            detail["originalEvent"] = opts.originalEvent;
                                                          }
                                                          el.dispatchEvent(
                                                            new CustomEvent("phx:push", {
                                                              detail,
                                                              bubbles: true,
                                                              cancelable: false
                                                            })
                                                          );
                                                          if (phxEvent) {
                                                            el.dispatchEvent(
                                                              new CustomEvent(`phx:push:${phxEvent}`, {
                                                                detail,
                                                                bubbles: true,
                                                                cancelable: false
                                                              })
                                                            );
                                                          }
                                                        }
                                                        return [newRef, elements.map(({ el }) => el), opts];
                                                      }
                                                      isAcked(ref) {
                                                        return this.lastAckRef !== null && this.lastAckRef >= ref;
                                                      }
                                                      componentID(el) {
                                                        const cid = el.getAttribute && el.getAttribute(PHX_COMPONENT);
                                                        return cid ? parseInt(cid) : null;
                                                      }
                                                      targetComponentID(target, targetCtx, opts = {}) {
                                                        if (isCid(targetCtx)) {
                                                          return targetCtx;
                                                        }
                                                        const cidOrSelector = opts.target || target.getAttribute(this.binding("target"));
                                                        if (isCid(cidOrSelector)) {
                                                          return parseInt(cidOrSelector);
                                                        } else if (targetCtx && (cidOrSelector !== null || opts.target)) {
                                                          return this.closestComponentID(targetCtx);
                                                        } else {
                                                          return null;
                                                        }
                                                      }
                                                      closestComponentID(targetCtx) {
                                                        if (isCid(targetCtx)) {
                                                          return targetCtx;
                                                        } else if (targetCtx) {
                                                          return maybe(
                                                            // We either use the closest data-phx-component binding, or -
                                                            // in case of portals - continue with the portal source.
                                                            // This is necessary if teleporting an element outside of its LiveComponent.
                                                            targetCtx.closest(`[${PHX_COMPONENT}],[${PHX_TELEPORTED_SRC}]`),
                                                            (el) => {
                                                              if (el.hasAttribute(PHX_COMPONENT)) {
                                                                return this.ownsElement(el) && this.componentID(el);
                                                              }
                                                              if (el.hasAttribute(PHX_TELEPORTED_SRC)) {
                                                                const portalParent = dom_default.byId(el.getAttribute(PHX_TELEPORTED_SRC));
                                                                return this.closestComponentID(portalParent);
                                                              }
                                                            }
                                                          );
                                                        } else {
                                                          return null;
                                                        }
                                                      }
                                                      pushHookEvent(el, targetCtx, event, payload) {
                                                        if (!this.isConnected()) {
                                                          this.log("hook", () => [
                                                            "unable to push hook event. LiveView not connected",
                                                            event,
                                                            payload
                                                          ]);
                                                          return Promise.reject(
                                                            new Error("unable to push hook event. LiveView not connected")
                                                          );
                                                        }
                                                        const refGenerator = () => this.putRef([{ el, loading: true, lock: true }], event, "hook", {
                                                          payload,
                                                          target: targetCtx
                                                        });
                                                        return this.pushWithReply(refGenerator, "event", {
                                                          type: "hook",
                                                          event,
                                                          value: payload,
                                                          cid: this.closestComponentID(targetCtx)
                                                        }).then(({ resp: _resp, reply, ref }) => ({ reply, ref }));
                                                      }
                                                      extractMeta(el, meta, value) {
                                                        const prefix = this.binding("value-");
                                                        for (let i = 0; i < el.attributes.length; i++) {
                                                          if (!meta) {
                                                            meta = {};
                                                          }
                                                          const name = el.attributes[i].name;
                                                          if (name.startsWith(prefix)) {
                                                            meta[name.replace(prefix, "")] = el.getAttribute(name);
                                                          }
                                                        }
                                                        if (el.value !== void 0 && !(el instanceof HTMLFormElement)) {
                                                          if (!meta) {
                                                            meta = {};
                                                          }
                                                          meta.value = el.value;
                                                          if (el.tagName === "INPUT" && CHECKABLE_INPUTS.indexOf(el.type) >= 0 && !el.checked) {
                                                            delete meta.value;
                                                          }
                                                        }
                                                        if (value) {
                                                          if (!meta) {
                                                            meta = {};
                                                          }
                                                          for (const key in value) {
                                                            meta[key] = value[key];
                                                          }
                                                        }
                                                        return meta;
                                                      }
                                                      pushEvent(type, el, targetCtx, phxEvent, meta, opts = {}, onReply) {
                                                        this.pushWithReply(
                                                          (maybePayload) => this.putRef([{ el, loading: true, lock: true }], phxEvent, type, {
                                                            ...opts,
                                                            payload: maybePayload?.payload
                                                          }),
                                                          "event",
                                                          {
                                                            type,
                                                            event: phxEvent,
                                                            value: this.extractMeta(el, meta, opts.value),
                                                            cid: this.targetComponentID(el, targetCtx, opts)
                                                          }
                                                        ).then(({ reply }) => onReply && onReply(reply)).catch((error) => logError("Failed to push event", error));
                                                      }
                                                      pushFileProgress(fileEl, entryRef, progress, onReply = function() {
                                                      }) {
                                                        this.liveSocket.withinOwners(fileEl.form, (view, targetCtx) => {
                                                          view.pushWithReply(null, "progress", {
                                                            event: fileEl.getAttribute(view.binding(PHX_PROGRESS)),
                                                            ref: fileEl.getAttribute(PHX_UPLOAD_REF),
                                                            entry_ref: entryRef,
                                                            progress,
                                                            cid: view.targetComponentID(fileEl.form, targetCtx)
                                                          }).then(() => onReply()).catch((error) => logError("Failed to push file progress", error));
                                                        });
                                                      }
                                                      pushInput(inputEl, targetCtx, forceCid, phxEvent, opts, callback) {
                                                        if (!inputEl.form) {
                                                          throw new Error("form events require the input to be inside a form");
                                                        }
                                                        let uploads;
                                                        const cid = isCid(forceCid) ? forceCid : this.targetComponentID(inputEl.form, targetCtx, opts);
                                                        const refGenerator = (maybePayload) => {
                                                          return this.putRef(
                                                            [
                                                              { el: inputEl, loading: true, lock: true },
                                                              { el: inputEl.form, loading: true, lock: true }
                                                            ],
                                                            phxEvent,
                                                            "change",
                                                            { ...opts, payload: maybePayload?.payload }
                                                          );
                                                        };
                                                        let formData;
                                                        const meta = this.extractMeta(inputEl.form, {}, opts.value);
                                                        const serializeOpts = {};
                                                        if (inputEl instanceof HTMLButtonElement) {
                                                          serializeOpts.submitter = inputEl;
                                                        }
                                                        if (inputEl.getAttribute(this.binding("change"))) {
                                                          formData = serializeForm(inputEl.form, serializeOpts, [inputEl.name]);
                                                        } else {
                                                          formData = serializeForm(inputEl.form, serializeOpts);
                                                        }
                                                        if (dom_default.isUploadInput(inputEl) && inputEl.files && inputEl.files.length > 0) {
                                                          LiveUploader.trackFiles(inputEl, Array.from(inputEl.files));
                                                        }
                                                        uploads = LiveUploader.serializeUploads(inputEl);
                                                        const event = {
                                                          type: "form",
                                                          event: phxEvent,
                                                          value: formData,
                                                          meta: {
                                                            // no target was implicitly sent as "undefined" in LV <= 1.0.5, therefore
                                                            // we have to keep it. In 1.0.6 we switched from passing meta as URL encoded data
                                                            // to passing it directly in the event, but the JSON encode would drop keys with
                                                            // undefined values.
                                                            _target: opts._target || "undefined",
                                                            ...meta
                                                          },
                                                          uploads,
                                                          cid
                                                        };
                                                        this.pushWithReply(refGenerator, "event", event).then(({ resp }) => {
                                                          if (dom_default.isUploadInput(inputEl) && dom_default.isAutoUpload(inputEl)) {
                                                            ElementRef.onUnlock(inputEl, () => {
                                                              if (LiveUploader.filesAwaitingPreflight(inputEl).length > 0) {
                                                                const [ref, _els] = refGenerator();
                                                                this.undoRefs(ref, phxEvent, [inputEl.form]);
                                                                this.uploadFiles(
                                                                  inputEl.form,
                                                                  phxEvent,
                                                                  targetCtx,
                                                                  ref,
                                                                  cid,
                                                                  (_uploads) => {
                                                                    callback && callback(resp);
                                                                    this.triggerAwaitingSubmit(inputEl.form, phxEvent);
                                                                    this.undoRefs(ref, phxEvent);
                                                                  }
                                                                );
                                                              }
                                                            });
                                                          } else {
                                                            callback && callback(resp);
                                                          }
                                                        }).catch((error) => logError("Failed to push input event", error));
                                                      }
                                                      triggerAwaitingSubmit(formEl, phxEvent) {
                                                        const awaitingSubmit = this.getScheduledSubmit(formEl);
                                                        if (awaitingSubmit) {
                                                          const [_el, _ref, _opts, callback] = awaitingSubmit;
                                                          this.cancelSubmit(formEl, phxEvent);
                                                          callback();
                                                        }
                                                      }
                                                      getScheduledSubmit(formEl) {
                                                        return this.formSubmits.find(
                                                          ([el, _ref, _opts, _callback]) => el.isSameNode(formEl)
                                                        );
                                                      }
                                                      scheduleSubmit(formEl, ref, opts, callback) {
                                                        if (this.getScheduledSubmit(formEl)) {
                                                          return true;
                                                        }
                                                        this.formSubmits.push([formEl, ref, opts, callback]);
                                                      }
                                                      cancelSubmit(formEl, phxEvent) {
                                                        this.formSubmits = this.formSubmits.filter(
                                                          ([el, ref, _opts, _callback]) => {
                                                            if (el.isSameNode(formEl)) {
                                                              this.undoRefs(ref, phxEvent);
                                                              return false;
                                                            } else {
                                                              return true;
                                                            }
                                                          }
                                                        );
                                                      }
                                                      disableForm(formEl, phxEvent, opts = {}) {
                                                        const filterIgnored = (el) => {
                                                          const userIgnored = closestPhxBinding(
                                                            el,
                                                            `${this.binding(PHX_UPDATE)}=ignore`,
                                                            el.form
                                                          );
                                                          return !(userIgnored || closestPhxBinding(el, "data-phx-update=ignore", el.form));
                                                        };
                                                        const filterDisables = (el) => {
                                                          return el.hasAttribute(this.binding(PHX_DISABLE_WITH));
                                                        };
                                                        const filterButton = (el) => el.tagName == "BUTTON";
                                                        const filterInput = (el) => ["INPUT", "TEXTAREA", "SELECT"].includes(el.tagName);
                                                        const formElements = Array.from(formEl.elements);
                                                        const disables = formElements.filter(filterDisables);
                                                        const buttons = formElements.filter(filterButton).filter(filterIgnored);
                                                        const inputs = formElements.filter(filterInput).filter(filterIgnored);
                                                        buttons.forEach((button) => {
                                                          button.setAttribute(PHX_DISABLED, button.disabled);
                                                          button.disabled = true;
                                                        });
                                                        inputs.forEach((input) => {
                                                          input.setAttribute(PHX_READONLY, input.readOnly);
                                                          input.readOnly = true;
                                                          if (input.files) {
                                                            input.setAttribute(PHX_DISABLED, input.disabled);
                                                            input.disabled = true;
                                                          }
                                                        });
                                                        const formEls = disables.concat(buttons).concat(inputs).map((el) => {
                                                          return { el, loading: true, lock: true };
                                                        });
                                                        const els = [{ el: formEl, loading: true, lock: false }].concat(formEls).reverse();
                                                        return this.putRef(els, phxEvent, "submit", opts);
                                                      }
                                                      pushFormSubmit(formEl, targetCtx, phxEvent, submitter, opts, onReply) {
                                                        const refGenerator = (maybePayload) => this.disableForm(formEl, phxEvent, {
                                                          ...opts,
                                                          form: formEl,
                                                          payload: maybePayload?.payload,
                                                          submitter
                                                        });
                                                        dom_default.putPrivate(formEl, "submitter", submitter);
                                                        const cid = this.targetComponentID(formEl, targetCtx);
                                                        if (LiveUploader.hasUploadsInProgress(formEl)) {
                                                          const [ref, _els] = refGenerator();
                                                          const push = () => this.pushFormSubmit(
                                                            formEl,
                                                            targetCtx,
                                                            phxEvent,
                                                            submitter,
                                                            opts,
                                                            onReply
                                                          );
                                                          return this.scheduleSubmit(formEl, ref, opts, push);
                                                        } else if (LiveUploader.inputsAwaitingPreflight(formEl).length > 0) {
                                                          const [ref, els] = refGenerator();
                                                          const proxyRefGen = () => [ref, els, opts];
                                                          this.uploadFiles(formEl, phxEvent, targetCtx, ref, cid, (_uploads) => {
                                                            if (LiveUploader.inputsAwaitingPreflight(formEl).length > 0) {
                                                              return this.undoRefs(ref, phxEvent);
                                                            }
                                                            const meta = this.extractMeta(formEl, {}, opts.value);
                                                            const formData = serializeForm(formEl, { submitter });
                                                            this.pushWithReply(proxyRefGen, "event", {
                                                              type: "form",
                                                              event: phxEvent,
                                                              value: formData,
                                                              meta,
                                                              cid
                                                            }).then(({ resp }) => onReply(resp)).catch((error) => logError("Failed to push form submit", error));
                                                          });
                                                        } else if (!(formEl.hasAttribute(PHX_REF_SRC) && formEl.classList.contains("phx-submit-loading"))) {
                                                          const meta = this.extractMeta(formEl, {}, opts.value);
                                                          const formData = serializeForm(formEl, { submitter });
                                                          this.pushWithReply(refGenerator, "event", {
                                                            type: "form",
                                                            event: phxEvent,
                                                            value: formData,
                                                            meta,
                                                            cid
                                                          }).then(({ resp }) => onReply(resp)).catch((error) => logError("Failed to push form submit", error));
                                                        }
                                                      }
                                                      uploadFiles(formEl, phxEvent, targetCtx, ref, cid, onComplete) {
                                                        const joinCountAtUpload = this.joinCount;
                                                        const inputEls = LiveUploader.activeFileInputs(formEl);
                                                        let numFileInputsInProgress = inputEls.length;
                                                        inputEls.forEach((inputEl) => {
                                                          const uploader = new LiveUploader(inputEl, this, () => {
                                                            numFileInputsInProgress--;
                                                            if (numFileInputsInProgress === 0) {
                                                              onComplete();
                                                            }
                                                          });
                                                          const entries = uploader.entries().map((entry) => entry.toPreflightPayload());
                                                          if (entries.length === 0) {
                                                            numFileInputsInProgress--;
                                                            return;
                                                          }
                                                          const payload = {
                                                            ref: inputEl.getAttribute(PHX_UPLOAD_REF),
                                                            entries,
                                                            cid: this.targetComponentID(inputEl.form, targetCtx)
                                                          };
                                                          this.log("upload", () => ["sending preflight request", payload]);
                                                          this.pushWithReply(null, "allow_upload", payload).then(({ resp }) => {
                                                            this.log("upload", () => ["got preflight response", resp]);
                                                            uploader.entries().forEach((entry) => {
                                                              if (resp.entries && !resp.entries[entry.ref]) {
                                                                this.handleFailedEntryPreflight(
                                                                  entry.ref,
                                                                  "failed preflight",
                                                                  uploader
                                                                );
                                                              }
                                                            });
                                                            if (resp.error || Object.keys(resp.entries).length === 0) {
                                                              this.undoRefs(ref, phxEvent);
                                                              const errors = resp.error || [];
                                                              errors.map(([entry_ref, reason]) => {
                                                                this.handleFailedEntryPreflight(entry_ref, reason, uploader);
                                                              });
                                                            } else {
                                                              const onError = (callback) => {
                                                                this.channel.onError(() => {
                                                                  if (this.joinCount === joinCountAtUpload) {
                                                                    callback();
                                                                  }
                                                                });
                                                              };
                                                              uploader.initAdapterUpload(resp, onError, this.liveSocket);
                                                            }
                                                          }).catch((error) => logError("Failed to push upload", error));
                                                        });
                                                      }
                                                      handleFailedEntryPreflight(uploadRef, reason, uploader) {
                                                        if (uploader.isAutoUpload()) {
                                                          const entry = uploader.entries().find((entry2) => entry2.ref === uploadRef.toString());
                                                          if (entry) {
                                                            entry.cancel();
                                                          }
                                                        } else {
                                                          uploader.entries().map((entry) => entry.cancel());
                                                        }
                                                        this.log("upload", () => [`error for entry ${uploadRef}`, reason]);
                                                      }
                                                      dispatchUploads(targetCtx, name, filesOrBlobs) {
                                                        const targetElement = this.targetCtxElement(targetCtx) || this.el;
                                                        const inputs = dom_default.findUploadInputs(targetElement).filter(
                                                          (el) => el.name === name
                                                        );
                                                        if (inputs.length === 0) {
                                                          logError(`no live file inputs found matching the name "${name}"`);
                                                        } else if (inputs.length > 1) {
                                                          logError(`duplicate live file inputs found matching the name "${name}"`);
                                                        } else {
                                                          dom_default.dispatchEvent(inputs[0], PHX_TRACK_UPLOADS, {
                                                            detail: { files: filesOrBlobs }
                                                          });
                                                        }
                                                      }
                                                      targetCtxElement(targetCtx) {
                                                        if (isCid(targetCtx)) {
                                                          const [target] = dom_default.findComponentNodeList(this.id, targetCtx);
                                                          return target;
                                                        } else if (targetCtx) {
                                                          return targetCtx;
                                                        } else {
                                                          return null;
                                                        }
                                                      }
                                                      pushFormRecovery(oldForm, newForm, templateDom, callback) {
                                                        const phxChange = this.binding("change");
                                                        const phxTarget = newForm.getAttribute(this.binding("target")) || newForm;
                                                        const phxEvent = newForm.getAttribute(this.binding(PHX_AUTO_RECOVER)) || newForm.getAttribute(this.binding("change"));
                                                        const inputs = Array.from(oldForm.elements).filter(
                                                          (el) => dom_default.isFormInput(el) && el.name && !el.hasAttribute(phxChange)
                                                        );
                                                        if (inputs.length === 0) {
                                                          callback();
                                                          return;
                                                        }
                                                        inputs.forEach(
                                                          (input2) => input2.hasAttribute(PHX_UPLOAD_REF) && LiveUploader.clearFiles(input2)
                                                        );
                                                        const input = inputs.find((el) => el.type !== "hidden") || inputs[0];
                                                        let pending = 0;
                                                        this.withinTargets(
                                                          phxTarget,
                                                          (targetView, targetCtx) => {
                                                            const cid = this.targetComponentID(newForm, targetCtx);
                                                            pending++;
                                                            let e = new CustomEvent("phx:form-recovery", {
                                                              detail: { sourceElement: oldForm }
                                                            });
                                                            js_default.exec(e, "change", phxEvent, this, input, [
                                                              "push",
                                                              {
                                                                _target: input.name,
                                                                targetView,
                                                                targetCtx,
                                                                newCid: cid,
                                                                callback: () => {
                                                                  pending--;
                                                                  if (pending === 0) {
                                                                    callback();
                                                                  }
                                                                }
                                                              }
                                                            ]);
                                                          },
                                                          templateDom
                                                        );
                                                      }
                                                      pushLinkPatch(e, href, targetEl, callback) {
                                                        const linkRef = this.liveSocket.setPendingLink(href);
                                                        const loading = e.isTrusted && e.type !== "popstate";
                                                        const refGen = targetEl ? () => this.putRef(
                                                          [{ el: targetEl, loading, lock: true }],
                                                          null,
                                                          "click"
                                                        ) : null;
                                                        const fallback = () => this.liveSocket.redirect(window.location.href);
                                                        const url = href.startsWith("/") ? `${location.protocol}//${location.host}${href}` : href;
                                                        this.pushWithReply(refGen, "live_patch", { url }).then(
                                                          ({ resp }) => {
                                                            this.liveSocket.requestDOMUpdate(() => {
                                                              if (resp.link_redirect) {
                                                                this.liveSocket.replaceMain(href, null, callback, linkRef);
                                                              } else if (resp.redirect) {
                                                                return;
                                                              } else {
                                                                if (this.liveSocket.commitPendingLink(linkRef)) {
                                                                  this.href = href;
                                                                }
                                                                this.applyPendingUpdates();
                                                                callback && callback(linkRef);
                                                              }
                                                            });
                                                          },
                                                          ({ error: _error, timeout: _timeout }) => fallback()
                                                        );
                                                      }
                                                      getFormsForRecovery() {
                                                        if (this.joinCount === 0) {
                                                          return {};
                                                        }
                                                        const phxChange = this.binding("change");
                                                        return dom_default.all(
                                                          document,
                                                          `#${CSS.escape(this.id)} form[${phxChange}], [${PHX_TELEPORTED_REF}="${CSS.escape(this.id)}"] form[${phxChange}]`
                                                        ).filter((form) => form.id).filter((form) => form.elements.length > 0).filter(
                                                          (form) => form.getAttribute(this.binding(PHX_AUTO_RECOVER)) !== "ignore"
                                                        ).map((form) => {
                                                          const clonedForm = form.cloneNode(true);
                                                          morphdom_esm_default(clonedForm, form, {
                                                            onBeforeElUpdated: (fromEl, toEl) => {
                                                              dom_default.copyPrivates(fromEl, toEl);
                                                              if (fromEl.getAttribute("form") === form.id) {
                                                                fromEl.parentNode.removeChild(fromEl);
                                                                return false;
                                                              }
                                                              return true;
                                                            }
                                                          });
                                                          const externalElements = document.querySelectorAll(
                                                            `[form="${CSS.escape(form.id)}"]`
                                                          );
                                                          Array.from(externalElements).forEach((el) => {
                                                            const clonedEl = (
                                                              /** @type {HTMLElement} */
                                                              el.cloneNode(true)
                                                            );
                                                            morphdom_esm_default(clonedEl, el);
                                                            dom_default.copyPrivates(clonedEl, el);
                                                            clonedEl.removeAttribute("form");
                                                            clonedForm.appendChild(clonedEl);
                                                          });
                                                          return clonedForm;
                                                        }).reduce((acc, form) => {
                                                          acc[form.id] = form;
                                                          return acc;
                                                        }, {});
                                                      }
                                                      maybePushComponentsDestroyed(destroyedCIDs) {
                                                        let willDestroyCIDs = destroyedCIDs.filter((cid) => {
                                                          return dom_default.findComponentNodeList(this.id, cid).length === 0;
                                                        });
                                                        const onError = (error) => {
                                                          if (!this.isDestroyed()) {
                                                            logError("Failed to push components destroyed", error);
                                                          }
                                                        };
                                                        if (willDestroyCIDs.length > 0) {
                                                          willDestroyCIDs.forEach((cid) => this.rendered.resetRender(cid));
                                                          this.pushWithReply(null, "cids_will_destroy", { cids: willDestroyCIDs }).then(() => {
                                                            this.liveSocket.requestDOMUpdate(() => {
                                                              let completelyDestroyCIDs = willDestroyCIDs.filter((cid) => {
                                                                return dom_default.findComponentNodeList(this.id, cid).length === 0;
                                                              });
                                                              if (completelyDestroyCIDs.length > 0) {
                                                                this.pushWithReply(null, "cids_destroyed", {
                                                                  cids: completelyDestroyCIDs
                                                                }).then(({ resp }) => {
                                                                  this.rendered.pruneCIDs(resp.cids);
                                                                }).catch(onError);
                                                              }
                                                            });
                                                          }).catch(onError);
                                                        }
                                                      }
                                                      ownsElement(el) {
                                                        let parentViewEl = dom_default.closestViewEl(el);
                                                        return el.getAttribute(PHX_PARENT_ID) === this.id || parentViewEl && parentViewEl.id === this.id || !parentViewEl && this.isDead;
                                                      }
                                                      submitForm(form, targetCtx, phxEvent, submitter, opts = {}) {
                                                        dom_default.putPrivate(form, PHX_HAS_SUBMITTED, true);
                                                        const inputs = Array.from(form.elements);
                                                        inputs.forEach((input) => dom_default.putPrivate(input, PHX_HAS_SUBMITTED, true));
                                                        this.liveSocket.blurActiveElement(this);
                                                        this.pushFormSubmit(form, targetCtx, phxEvent, submitter, opts, () => {
                                                          this.liveSocket.restorePreviouslyActiveFocus();
                                                        });
                                                      }
                                                      binding(kind) {
                                                        return this.liveSocket.binding(kind);
                                                      }
                                                      // phx-portal
                                                      pushPortalElementId(id) {
                                                        this.portalElementIds.add(id);
                                                      }
                                                      dropPortalElementId(id) {
                                                        this.portalElementIds.delete(id);
                                                      }
                                                      destroyPortalElements() {
                                                        if (!this.liveSocket.unloaded) {
                                                          this.portalElementIds.forEach((id) => {
                                                            const el = document.getElementById(id);
                                                            if (el) {
                                                              el.remove();
                                                            }
                                                          });
                                                        }
                                                      }
                                                    };
                                                    var LiveSocket = class {
                                                      constructor(url, phxSocket, opts = {}) {
                                                        this.unloaded = false;
                                                        if (!phxSocket || phxSocket.constructor.name === "Object") {
                                                          throw new Error(`
      a phoenix Socket must be provided as the second argument to the LiveSocket constructor. For example:

          import {Socket} from "phoenix"
          import {LiveSocket} from "phoenix_live_view"
          let liveSocket = new LiveSocket("/live", Socket, {...})
      `);
                                                        }
                                                        this.socket = new phxSocket(url, opts);
                                                        this.bindingPrefix = opts.bindingPrefix || BINDING_PREFIX;
                                                        this.opts = opts;
                                                        this.params = closure2(opts.params || {});
                                                        this.viewLogger = opts.viewLogger;
                                                        this.metadataCallbacks = opts.metadata || {};
                                                        this.defaults = Object.assign(clone(DEFAULTS), opts.defaults || {});
                                                        this.prevActive = null;
                                                        this.silenced = false;
                                                        this.main = null;
                                                        this.outgoingMainEl = null;
                                                        this.clickStartedAtTarget = null;
                                                        this.linkRef = 1;
                                                        this.roots = {};
                                                        this.href = window.location.href;
                                                        this.pendingLink = null;
                                                        this.currentLocation = clone(window.location);
                                                        this.hooks = opts.hooks || {};
                                                        this.uploaders = opts.uploaders || {};
                                                        this.loaderTimeout = opts.loaderTimeout || LOADER_TIMEOUT;
                                                        this.disconnectedTimeout = opts.disconnectedTimeout || DISCONNECTED_TIMEOUT;
                                                        this.reloadWithJitterTimer = null;
                                                        this.maxReloads = opts.maxReloads || MAX_RELOADS;
                                                        this.reloadJitterMin = opts.reloadJitterMin || RELOAD_JITTER_MIN;
                                                        this.reloadJitterMax = opts.reloadJitterMax || RELOAD_JITTER_MAX;
                                                        this.failsafeJitter = opts.failsafeJitter || FAILSAFE_JITTER;
                                                        this.localStorage = opts.localStorage || window.localStorage;
                                                        this.sessionStorage = opts.sessionStorage || window.sessionStorage;
                                                        this.boundTopLevelEvents = false;
                                                        this.boundEventNames = /* @__PURE__ */ new Set();
                                                        this.blockPhxChangeWhileComposing = opts.blockPhxChangeWhileComposing || false;
                                                        this.serverCloseRef = null;
                                                        this.domCallbacks = Object.assign(
                                                          {
                                                            jsQuerySelectorAll: null,
                                                            onPatchStart: closure2(),
                                                            onPatchEnd: closure2(),
                                                            onNodeAdded: closure2(),
                                                            onBeforeElUpdated: closure2()
                                                          },
                                                          opts.dom || {}
                                                        );
                                                        this.transitions = new TransitionSet();
                                                        this.currentHistoryPosition = parseInt(this.sessionStorage.getItem(PHX_LV_HISTORY_POSITION)) || 0;
                                                        window.addEventListener("pagehide", (_e) => {
                                                          this.unloaded = true;
                                                        });
                                                        this.socket.onOpen(() => {
                                                          if (this.isUnloaded()) {
                                                            window.location.reload();
                                                          }
                                                        });
                                                      }
                                                      // public
                                                      version() {
                                                        return "1.1.20";
                                                      }
                                                      isProfileEnabled() {
                                                        return this.sessionStorage.getItem(PHX_LV_PROFILE) === "true";
                                                      }
                                                      isDebugEnabled() {
                                                        return this.sessionStorage.getItem(PHX_LV_DEBUG) === "true";
                                                      }
                                                      isDebugDisabled() {
                                                        return this.sessionStorage.getItem(PHX_LV_DEBUG) === "false";
                                                      }
                                                      enableDebug() {
                                                        this.sessionStorage.setItem(PHX_LV_DEBUG, "true");
                                                      }
                                                      enableProfiling() {
                                                        this.sessionStorage.setItem(PHX_LV_PROFILE, "true");
                                                      }
                                                      disableDebug() {
                                                        this.sessionStorage.setItem(PHX_LV_DEBUG, "false");
                                                      }
                                                      disableProfiling() {
                                                        this.sessionStorage.removeItem(PHX_LV_PROFILE);
                                                      }
                                                      enableLatencySim(upperBoundMs) {
                                                        this.enableDebug();
                                                        console.log(
                                                          "latency simulator enabled for the duration of this browser session. Call disableLatencySim() to disable"
                                                        );
                                                        this.sessionStorage.setItem(PHX_LV_LATENCY_SIM, upperBoundMs);
                                                      }
                                                      disableLatencySim() {
                                                        this.sessionStorage.removeItem(PHX_LV_LATENCY_SIM);
                                                      }
                                                      getLatencySim() {
                                                        const str = this.sessionStorage.getItem(PHX_LV_LATENCY_SIM);
                                                        return str ? parseInt(str) : null;
                                                      }
                                                      getSocket() {
                                                        return this.socket;
                                                      }
                                                      connect() {
                                                        if (window.location.hostname === "localhost" && !this.isDebugDisabled()) {
                                                          this.enableDebug();
                                                        }
                                                        const doConnect = () => {
                                                          this.resetReloadStatus();
                                                          if (this.joinRootViews()) {
                                                            this.bindTopLevelEvents();
                                                            this.socket.connect();
                                                          } else if (this.main) {
                                                            this.socket.connect();
                                                          } else {
                                                            this.bindTopLevelEvents({ dead: true });
                                                          }
                                                          this.joinDeadView();
                                                        };
                                                        if (["complete", "loaded", "interactive"].indexOf(document.readyState) >= 0) {
                                                          doConnect();
                                                        } else {
                                                          document.addEventListener("DOMContentLoaded", () => doConnect());
                                                        }
                                                      }
                                                      disconnect(callback) {
                                                        clearTimeout(this.reloadWithJitterTimer);
                                                        if (this.serverCloseRef) {
                                                          this.socket.off(this.serverCloseRef);
                                                          this.serverCloseRef = null;
                                                        }
                                                        this.socket.disconnect(callback);
                                                      }
                                                      replaceTransport(transport) {
                                                        clearTimeout(this.reloadWithJitterTimer);
                                                        this.socket.replaceTransport(transport);
                                                        this.connect();
                                                      }
                                                      /**
                                                       * @param {HTMLElement} el
                                                       * @param {string} encodedJS
                                                       * @param {string | null} [eventType]
                                                       */
                                                      execJS(el, encodedJS, eventType = null) {
                                                        const e = new CustomEvent("phx:exec", { detail: { sourceElement: el } });
                                                        this.owner(el, (view) => js_default.exec(e, eventType, encodedJS, view, el));
                                                      }
                                                      /**
                                                       * Returns an object with methods to manipulate the DOM and execute JavaScript.
                                                       * The applied changes integrate with server DOM patching.
                                                       *
                                                       * @returns {import("./js_commands").LiveSocketJSCommands}
                                                       */
                                                      js() {
                                                        return js_commands_default(this, "js");
                                                      }
                                                      // private
                                                      unload() {
                                                        if (this.unloaded) {
                                                          return;
                                                        }
                                                        if (this.main && this.isConnected()) {
                                                          this.log(this.main, "socket", () => ["disconnect for page nav"]);
                                                        }
                                                        this.unloaded = true;
                                                        this.destroyAllViews();
                                                        this.disconnect();
                                                      }
                                                      triggerDOM(kind, args) {
                                                        this.domCallbacks[kind](...args);
                                                      }
                                                      time(name, func) {
                                                        if (!this.isProfileEnabled() || !console.time) {
                                                          return func();
                                                        }
                                                        console.time(name);
                                                        const result = func();
                                                        console.timeEnd(name);
                                                        return result;
                                                      }
                                                      log(view, kind, msgCallback) {
                                                        if (this.viewLogger) {
                                                          const [msg, obj] = msgCallback();
                                                          this.viewLogger(view, kind, msg, obj);
                                                        } else if (this.isDebugEnabled()) {
                                                          const [msg, obj] = msgCallback();
                                                          debug(view, kind, msg, obj);
                                                        }
                                                      }
                                                      requestDOMUpdate(callback) {
                                                        this.transitions.after(callback);
                                                      }
                                                      asyncTransition(promise) {
                                                        this.transitions.addAsyncTransition(promise);
                                                      }
                                                      transition(time, onStart, onDone = function() {
                                                      }) {
                                                        this.transitions.addTransition(time, onStart, onDone);
                                                      }
                                                      onChannel(channel, event, cb) {
                                                        channel.on(event, (data) => {
                                                          const latency = this.getLatencySim();
                                                          if (!latency) {
                                                            cb(data);
                                                          } else {
                                                            setTimeout(() => cb(data), latency);
                                                          }
                                                        });
                                                      }
                                                      reloadWithJitter(view, log) {
                                                        clearTimeout(this.reloadWithJitterTimer);
                                                        this.disconnect();
                                                        const minMs = this.reloadJitterMin;
                                                        const maxMs = this.reloadJitterMax;
                                                        let afterMs = Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;
                                                        const tries = browser_default.updateLocal(
                                                          this.localStorage,
                                                          window.location.pathname,
                                                          CONSECUTIVE_RELOADS,
                                                          0,
                                                          (count) => count + 1
                                                        );
                                                        if (tries >= this.maxReloads) {
                                                          afterMs = this.failsafeJitter;
                                                        }
                                                        this.reloadWithJitterTimer = setTimeout(() => {
                                                          if (view.isDestroyed() || view.isConnected()) {
                                                            return;
                                                          }
                                                          view.destroy();
                                                          log ? log() : this.log(view, "join", () => [
                                                            `encountered ${tries} consecutive reloads`
                                                          ]);
                                                          if (tries >= this.maxReloads) {
                                                            this.log(view, "join", () => [
                                                              `exceeded ${this.maxReloads} consecutive reloads. Entering failsafe mode`
                                                            ]);
                                                          }
                                                          if (this.hasPendingLink()) {
                                                            window.location = this.pendingLink;
                                                          } else {
                                                            window.location.reload();
                                                          }
                                                        }, afterMs);
                                                      }
                                                      getHookDefinition(name) {
                                                        if (!name) {
                                                          return;
                                                        }
                                                        return this.maybeInternalHook(name) || this.hooks[name] || this.maybeRuntimeHook(name);
                                                      }
                                                      maybeInternalHook(name) {
                                                        return name && name.startsWith("Phoenix.") && hooks_default[name.split(".")[1]];
                                                      }
                                                      maybeRuntimeHook(name) {
                                                        const runtimeHook = document.querySelector(
                                                          `script[${PHX_RUNTIME_HOOK}="${CSS.escape(name)}"]`
                                                        );
                                                        if (!runtimeHook) {
                                                          return;
                                                        }
                                                        let callbacks = window[`phx_hook_${name}`];
                                                        if (!callbacks || typeof callbacks !== "function") {
                                                          logError("a runtime hook must be a function", runtimeHook);
                                                          return;
                                                        }
                                                        const hookDefiniton = callbacks();
                                                        if (hookDefiniton && (typeof hookDefiniton === "object" || typeof hookDefiniton === "function")) {
                                                          return hookDefiniton;
                                                        }
                                                        logError(
                                                          "runtime hook must return an object with hook callbacks or an instance of ViewHook",
                                                          runtimeHook
                                                        );
                                                      }
                                                      isUnloaded() {
                                                        return this.unloaded;
                                                      }
                                                      isConnected() {
                                                        return this.socket.isConnected();
                                                      }
                                                      getBindingPrefix() {
                                                        return this.bindingPrefix;
                                                      }
                                                      binding(kind) {
                                                        return `${this.getBindingPrefix()}${kind}`;
                                                      }
                                                      channel(topic, params) {
                                                        return this.socket.channel(topic, params);
                                                      }
                                                      joinDeadView() {
                                                        const body = document.body;
                                                        if (body && !this.isPhxView(body) && !this.isPhxView(document.firstElementChild)) {
                                                          const view = this.newRootView(body);
                                                          view.setHref(this.getHref());
                                                          view.joinDead();
                                                          if (!this.main) {
                                                            this.main = view;
                                                          }
                                                          window.requestAnimationFrame(() => {
                                                            view.execNewMounted();
                                                            this.maybeScroll(history.state?.scroll);
                                                          });
                                                        }
                                                      }
                                                      joinRootViews() {
                                                        let rootsFound = false;
                                                        dom_default.all(
                                                          document,
                                                          `${PHX_VIEW_SELECTOR}:not([${PHX_PARENT_ID}])`,
                                                          (rootEl) => {
                                                            if (!this.getRootById(rootEl.id)) {
                                                              const view = this.newRootView(rootEl);
                                                              if (!dom_default.isPhxSticky(rootEl)) {
                                                                view.setHref(this.getHref());
                                                              }
                                                              view.join();
                                                              if (rootEl.hasAttribute(PHX_MAIN)) {
                                                                this.main = view;
                                                              }
                                                            }
                                                            rootsFound = true;
                                                          }
                                                        );
                                                        return rootsFound;
                                                      }
                                                      redirect(to, flash, reloadToken) {
                                                        if (reloadToken) {
                                                          browser_default.setCookie(PHX_RELOAD_STATUS, reloadToken, 60);
                                                        }
                                                        this.unload();
                                                        browser_default.redirect(to, flash);
                                                      }
                                                      replaceMain(href, flash, callback = null, linkRef = this.setPendingLink(href)) {
                                                        const liveReferer = this.currentLocation.href;
                                                        this.outgoingMainEl = this.outgoingMainEl || this.main.el;
                                                        const stickies = dom_default.findPhxSticky(document) || [];
                                                        const removeEls = dom_default.all(
                                                          this.outgoingMainEl,
                                                          `[${this.binding("remove")}]`
                                                        ).filter((el) => !dom_default.isChildOfAny(el, stickies));
                                                        const newMainEl = dom_default.cloneNode(this.outgoingMainEl, "");
                                                        this.main.showLoader(this.loaderTimeout);
                                                        this.main.destroy();
                                                        this.main = this.newRootView(newMainEl, flash, liveReferer);
                                                        this.main.setRedirect(href);
                                                        this.transitionRemoves(removeEls);
                                                        this.main.join((joinCount, onDone) => {
                                                          if (joinCount === 1 && this.commitPendingLink(linkRef)) {
                                                            this.requestDOMUpdate(() => {
                                                              removeEls.forEach((el) => el.remove());
                                                              stickies.forEach((el) => newMainEl.appendChild(el));
                                                              this.outgoingMainEl.replaceWith(newMainEl);
                                                              this.outgoingMainEl = null;
                                                              callback && callback(linkRef);
                                                              onDone();
                                                            });
                                                          }
                                                        });
                                                      }
                                                      transitionRemoves(elements, callback) {
                                                        const removeAttr = this.binding("remove");
                                                        const silenceEvents = (e) => {
                                                          e.preventDefault();
                                                          e.stopImmediatePropagation();
                                                        };
                                                        elements.forEach((el) => {
                                                          for (const event of this.boundEventNames) {
                                                            el.addEventListener(event, silenceEvents, true);
                                                          }
                                                          this.execJS(el, el.getAttribute(removeAttr), "remove");
                                                        });
                                                        this.requestDOMUpdate(() => {
                                                          elements.forEach((el) => {
                                                            for (const event of this.boundEventNames) {
                                                              el.removeEventListener(event, silenceEvents, true);
                                                            }
                                                          });
                                                          callback && callback();
                                                        });
                                                      }
                                                      isPhxView(el) {
                                                        return el.getAttribute && el.getAttribute(PHX_SESSION) !== null;
                                                      }
                                                      newRootView(el, flash, liveReferer) {
                                                        const view = new View(el, this, null, flash, liveReferer);
                                                        this.roots[view.id] = view;
                                                        return view;
                                                      }
                                                      owner(childEl, callback) {
                                                        let view;
                                                        const viewEl = dom_default.closestViewEl(childEl);
                                                        if (viewEl) {
                                                          view = this.getViewByEl(viewEl);
                                                        } else {
                                                          if (!childEl.isConnected) {
                                                            return null;
                                                          }
                                                          view = this.main;
                                                        }
                                                        return view && callback ? callback(view) : view;
                                                      }
                                                      withinOwners(childEl, callback) {
                                                        this.owner(childEl, (view) => callback(view, childEl));
                                                      }
                                                      getViewByEl(el) {
                                                        const rootId = el.getAttribute(PHX_ROOT_ID);
                                                        return maybe(
                                                          this.getRootById(rootId),
                                                          (root) => root.getDescendentByEl(el)
                                                        );
                                                      }
                                                      getRootById(id) {
                                                        return this.roots[id];
                                                      }
                                                      destroyAllViews() {
                                                        for (const id in this.roots) {
                                                          this.roots[id].destroy();
                                                          delete this.roots[id];
                                                        }
                                                        this.main = null;
                                                      }
                                                      destroyViewByEl(el) {
                                                        const root = this.getRootById(el.getAttribute(PHX_ROOT_ID));
                                                        if (root && root.id === el.id) {
                                                          root.destroy();
                                                          delete this.roots[root.id];
                                                        } else if (root) {
                                                          root.destroyDescendent(el.id);
                                                        }
                                                      }
                                                      getActiveElement() {
                                                        return document.activeElement;
                                                      }
                                                      dropActiveElement(view) {
                                                        if (this.prevActive && view.ownsElement(this.prevActive)) {
                                                          this.prevActive = null;
                                                        }
                                                      }
                                                      restorePreviouslyActiveFocus() {
                                                        if (this.prevActive && this.prevActive !== document.body && this.prevActive instanceof HTMLElement) {
                                                          this.prevActive.focus();
                                                        }
                                                      }
                                                      blurActiveElement() {
                                                        this.prevActive = this.getActiveElement();
                                                        if (this.prevActive !== document.body && this.prevActive instanceof HTMLElement) {
                                                          this.prevActive.blur();
                                                        }
                                                      }
                                                      /**
                                                       * @param {{dead?: boolean}} [options={}]
                                                       */
                                                      bindTopLevelEvents({ dead } = {}) {
                                                        if (this.boundTopLevelEvents) {
                                                          return;
                                                        }
                                                        this.boundTopLevelEvents = true;
                                                        this.serverCloseRef = this.socket.onClose((event) => {
                                                          if (event && event.code === 1e3 && this.main) {
                                                            return this.reloadWithJitter(this.main);
                                                          }
                                                        });
                                                        document.body.addEventListener("click", function() {
                                                        });
                                                        window.addEventListener(
                                                          "pageshow",
                                                          (e) => {
                                                            if (e.persisted) {
                                                              this.getSocket().disconnect();
                                                              this.withPageLoading({ to: window.location.href, kind: "redirect" });
                                                              window.location.reload();
                                                            }
                                                          },
                                                          true
                                                        );
                                                        if (!dead) {
                                                          this.bindNav();
                                                        }
                                                        this.bindClicks();
                                                        if (!dead) {
                                                          this.bindForms();
                                                        }
                                                        this.bind(
                                                          { keyup: "keyup", keydown: "keydown" },
                                                          (e, type, view, targetEl, phxEvent, _phxTarget) => {
                                                            const matchKey = targetEl.getAttribute(this.binding(PHX_KEY));
                                                            const pressedKey = e.key && e.key.toLowerCase();
                                                            if (matchKey && matchKey.toLowerCase() !== pressedKey) {
                                                              return;
                                                            }
                                                            const data = { key: e.key, ...this.eventMeta(type, e, targetEl) };
                                                            js_default.exec(e, type, phxEvent, view, targetEl, ["push", { data }]);
                                                          }
                                                        );
                                                        this.bind(
                                                          { blur: "focusout", focus: "focusin" },
                                                          (e, type, view, targetEl, phxEvent, phxTarget) => {
                                                            if (!phxTarget) {
                                                              const data = { key: e.key, ...this.eventMeta(type, e, targetEl) };
                                                              js_default.exec(e, type, phxEvent, view, targetEl, ["push", { data }]);
                                                            }
                                                          }
                                                        );
                                                        this.bind(
                                                          { blur: "blur", focus: "focus" },
                                                          (e, type, view, targetEl, phxEvent, phxTarget) => {
                                                            if (phxTarget === "window") {
                                                              const data = this.eventMeta(type, e, targetEl);
                                                              js_default.exec(e, type, phxEvent, view, targetEl, ["push", { data }]);
                                                            }
                                                          }
                                                        );
                                                        this.on("dragover", (e) => e.preventDefault());
                                                        this.on("dragenter", (e) => {
                                                          const dropzone = closestPhxBinding(
                                                            e.target,
                                                            this.binding(PHX_DROP_TARGET)
                                                          );
                                                          if (!dropzone || !(dropzone instanceof HTMLElement)) {
                                                            return;
                                                          }
                                                          if (eventContainsFiles(e)) {
                                                            this.js().addClass(dropzone, PHX_DROP_TARGET_ACTIVE_CLASS);
                                                          }
                                                        });
                                                        this.on("dragleave", (e) => {
                                                          const dropzone = closestPhxBinding(
                                                            e.target,
                                                            this.binding(PHX_DROP_TARGET)
                                                          );
                                                          if (!dropzone || !(dropzone instanceof HTMLElement)) {
                                                            return;
                                                          }
                                                          const rect = dropzone.getBoundingClientRect();
                                                          if (e.clientX <= rect.left || e.clientX >= rect.right || e.clientY <= rect.top || e.clientY >= rect.bottom) {
                                                            this.js().removeClass(dropzone, PHX_DROP_TARGET_ACTIVE_CLASS);
                                                          }
                                                        });
                                                        this.on("drop", (e) => {
                                                          e.preventDefault();
                                                          const dropzone = closestPhxBinding(
                                                            e.target,
                                                            this.binding(PHX_DROP_TARGET)
                                                          );
                                                          if (!dropzone || !(dropzone instanceof HTMLElement)) {
                                                            return;
                                                          }
                                                          this.js().removeClass(dropzone, PHX_DROP_TARGET_ACTIVE_CLASS);
                                                          const dropTargetId = dropzone.getAttribute(this.binding(PHX_DROP_TARGET));
                                                          const dropTarget = dropTargetId && document.getElementById(dropTargetId);
                                                          const files = Array.from(e.dataTransfer.files || []);
                                                          if (!dropTarget || !(dropTarget instanceof HTMLInputElement) || dropTarget.disabled || files.length === 0 || !(dropTarget.files instanceof FileList)) {
                                                            return;
                                                          }
                                                          LiveUploader.trackFiles(dropTarget, files, e.dataTransfer);
                                                          dropTarget.dispatchEvent(new Event("input", { bubbles: true }));
                                                        });
                                                        this.on(PHX_TRACK_UPLOADS, (e) => {
                                                          const uploadTarget = e.target;
                                                          if (!dom_default.isUploadInput(uploadTarget)) {
                                                            return;
                                                          }
                                                          const files = Array.from(e.detail.files || []).filter(
                                                            (f) => f instanceof File || f instanceof Blob
                                                          );
                                                          LiveUploader.trackFiles(uploadTarget, files);
                                                          uploadTarget.dispatchEvent(new Event("input", { bubbles: true }));
                                                        });
                                                      }
                                                      eventMeta(eventName, e, targetEl) {
                                                        const callback = this.metadataCallbacks[eventName];
                                                        return callback ? callback(e, targetEl) : {};
                                                      }
                                                      setPendingLink(href) {
                                                        this.linkRef++;
                                                        this.pendingLink = href;
                                                        this.resetReloadStatus();
                                                        return this.linkRef;
                                                      }
                                                      // anytime we are navigating or connecting, drop reload cookie in case
                                                      // we issue the cookie but the next request was interrupted and the server never dropped it
                                                      resetReloadStatus() {
                                                        browser_default.deleteCookie(PHX_RELOAD_STATUS);
                                                      }
                                                      commitPendingLink(linkRef) {
                                                        if (this.linkRef !== linkRef) {
                                                          return false;
                                                        } else {
                                                          this.href = this.pendingLink;
                                                          this.pendingLink = null;
                                                          return true;
                                                        }
                                                      }
                                                      getHref() {
                                                        return this.href;
                                                      }
                                                      hasPendingLink() {
                                                        return !!this.pendingLink;
                                                      }
                                                      bind(events, callback) {
                                                        for (const event in events) {
                                                          const browserEventName = events[event];
                                                          this.on(browserEventName, (e) => {
                                                            const binding = this.binding(event);
                                                            const windowBinding = this.binding(`window-${event}`);
                                                            const targetPhxEvent = e.target.getAttribute && e.target.getAttribute(binding);
                                                            if (targetPhxEvent) {
                                                              this.debounce(e.target, e, browserEventName, () => {
                                                                this.withinOwners(e.target, (view) => {
                                                                  callback(e, event, view, e.target, targetPhxEvent, null);
                                                                });
                                                              });
                                                            } else {
                                                              dom_default.all(document, `[${windowBinding}]`, (el) => {
                                                                const phxEvent = el.getAttribute(windowBinding);
                                                                this.debounce(el, e, browserEventName, () => {
                                                                  this.withinOwners(el, (view) => {
                                                                    callback(e, event, view, el, phxEvent, "window");
                                                                  });
                                                                });
                                                              });
                                                            }
                                                          });
                                                        }
                                                      }
                                                      bindClicks() {
                                                        this.on("mousedown", (e) => this.clickStartedAtTarget = e.target);
                                                        this.bindClick("click", "click");
                                                      }
                                                      bindClick(eventName, bindingName) {
                                                        const click = this.binding(bindingName);
                                                        window.addEventListener(
                                                          eventName,
                                                          (e) => {
                                                            let target = null;
                                                            if (e.detail === 0)
                                                              this.clickStartedAtTarget = e.target;
                                                            const clickStartedAtTarget = this.clickStartedAtTarget || e.target;
                                                            target = closestPhxBinding(e.target, click);
                                                            this.dispatchClickAway(e, clickStartedAtTarget);
                                                            this.clickStartedAtTarget = null;
                                                            const phxEvent = target && target.getAttribute(click);
                                                            if (!phxEvent) {
                                                              if (dom_default.isNewPageClick(e, window.location)) {
                                                                this.unload();
                                                              }
                                                              return;
                                                            }
                                                            if (target.getAttribute("href") === "#") {
                                                              e.preventDefault();
                                                            }
                                                            if (target.hasAttribute(PHX_REF_SRC)) {
                                                              return;
                                                            }
                                                            this.debounce(target, e, "click", () => {
                                                              this.withinOwners(target, (view) => {
                                                                js_default.exec(e, "click", phxEvent, view, target, [
                                                                  "push",
                                                                  { data: this.eventMeta("click", e, target) }
                                                                ]);
                                                              });
                                                            });
                                                          },
                                                          false
                                                        );
                                                      }
                                                      dispatchClickAway(e, clickStartedAt) {
                                                        const phxClickAway = this.binding("click-away");
                                                        dom_default.all(document, `[${phxClickAway}]`, (el) => {
                                                          if (!(el.isSameNode(clickStartedAt) || el.contains(clickStartedAt) || // When clicking a link with custom method,
                                                          // phoenix_html triggers a click on a submit button
                                                          // of a hidden form appended to the body. For such cases
                                                          // where the clicked target is hidden, we skip click-away.
                                                          !js_default.isVisible(clickStartedAt))) {
                                                            this.withinOwners(el, (view) => {
                                                              const phxEvent = el.getAttribute(phxClickAway);
                                                              if (js_default.isVisible(el) && js_default.isInViewport(el)) {
                                                                js_default.exec(e, "click", phxEvent, view, el, [
                                                                  "push",
                                                                  { data: this.eventMeta("click", e, e.target) }
                                                                ]);
                                                              }
                                                            });
                                                          }
                                                        });
                                                      }
                                                      bindNav() {
                                                        if (!browser_default.canPushState()) {
                                                          return;
                                                        }
                                                        if (history.scrollRestoration) {
                                                          history.scrollRestoration = "manual";
                                                        }
                                                        let scrollTimer = null;
                                                        window.addEventListener("scroll", (_e) => {
                                                          clearTimeout(scrollTimer);
                                                          scrollTimer = setTimeout(() => {
                                                            browser_default.updateCurrentState(
                                                              (state) => Object.assign(state, { scroll: window.scrollY })
                                                            );
                                                          }, 100);
                                                        });
                                                        window.addEventListener(
                                                          "popstate",
                                                          (event) => {
                                                            if (!this.registerNewLocation(window.location)) {
                                                              return;
                                                            }
                                                            const { type, backType, id, scroll, position: position2 } = event.state || {};
                                                            const href = window.location.href;
                                                            const isForward = position2 > this.currentHistoryPosition;
                                                            const navType = isForward ? type : backType || type;
                                                            this.currentHistoryPosition = position2 || 0;
                                                            this.sessionStorage.setItem(
                                                              PHX_LV_HISTORY_POSITION,
                                                              this.currentHistoryPosition.toString()
                                                            );
                                                            dom_default.dispatchEvent(window, "phx:navigate", {
                                                              detail: {
                                                                href,
                                                                patch: navType === "patch",
                                                                pop: true,
                                                                direction: isForward ? "forward" : "backward"
                                                              }
                                                            });
                                                            this.requestDOMUpdate(() => {
                                                              const callback = () => {
                                                                this.maybeScroll(scroll);
                                                              };
                                                              if (this.main.isConnected() && navType === "patch" && id === this.main.id) {
                                                                this.main.pushLinkPatch(event, href, null, callback);
                                                              } else {
                                                                this.replaceMain(href, null, callback);
                                                              }
                                                            });
                                                          },
                                                          false
                                                        );
                                                        window.addEventListener(
                                                          "click",
                                                          (e) => {
                                                            const target = closestPhxBinding(e.target, PHX_LIVE_LINK);
                                                            const type = target && target.getAttribute(PHX_LIVE_LINK);
                                                            if (!type || !this.isConnected() || !this.main || dom_default.wantsNewTab(e)) {
                                                              return;
                                                            }
                                                            const href = target.href instanceof SVGAnimatedString ? target.href.baseVal : target.href;
                                                            const linkState = target.getAttribute(PHX_LINK_STATE);
                                                            e.preventDefault();
                                                            e.stopImmediatePropagation();
                                                            if (this.pendingLink === href) {
                                                              return;
                                                            }
                                                            this.requestDOMUpdate(() => {
                                                              if (type === "patch") {
                                                                this.pushHistoryPatch(e, href, linkState, target);
                                                              } else if (type === "redirect") {
                                                                this.historyRedirect(e, href, linkState, null, target);
                                                              } else {
                                                                throw new Error(
                                                                  `expected ${PHX_LIVE_LINK} to be "patch" or "redirect", got: ${type}`
                                                                );
                                                              }
                                                              const phxClick = target.getAttribute(this.binding("click"));
                                                              if (phxClick) {
                                                                this.requestDOMUpdate(() => this.execJS(target, phxClick, "click"));
                                                              }
                                                            });
                                                          },
                                                          false
                                                        );
                                                      }
                                                      maybeScroll(scroll) {
                                                        if (typeof scroll === "number") {
                                                          requestAnimationFrame(() => {
                                                            window.scrollTo(0, scroll);
                                                          });
                                                        }
                                                      }
                                                      dispatchEvent(event, payload = {}) {
                                                        dom_default.dispatchEvent(window, `phx:${event}`, { detail: payload });
                                                      }
                                                      dispatchEvents(events) {
                                                        events.forEach(([event, payload]) => this.dispatchEvent(event, payload));
                                                      }
                                                      withPageLoading(info, callback) {
                                                        dom_default.dispatchEvent(window, "phx:page-loading-start", { detail: info });
                                                        const done = () => dom_default.dispatchEvent(window, "phx:page-loading-stop", { detail: info });
                                                        return callback ? callback(done) : done;
                                                      }
                                                      pushHistoryPatch(e, href, linkState, targetEl) {
                                                        if (!this.isConnected() || !this.main.isMain()) {
                                                          return browser_default.redirect(href);
                                                        }
                                                        this.withPageLoading({ to: href, kind: "patch" }, (done) => {
                                                          this.main.pushLinkPatch(e, href, targetEl, (linkRef) => {
                                                            this.historyPatch(href, linkState, linkRef);
                                                            done();
                                                          });
                                                        });
                                                      }
                                                      historyPatch(href, linkState, linkRef = this.setPendingLink(href)) {
                                                        if (!this.commitPendingLink(linkRef)) {
                                                          return;
                                                        }
                                                        this.currentHistoryPosition++;
                                                        this.sessionStorage.setItem(
                                                          PHX_LV_HISTORY_POSITION,
                                                          this.currentHistoryPosition.toString()
                                                        );
                                                        browser_default.updateCurrentState((state) => ({ ...state, backType: "patch" }));
                                                        browser_default.pushState(
                                                          linkState,
                                                          {
                                                            type: "patch",
                                                            id: this.main.id,
                                                            position: this.currentHistoryPosition
                                                          },
                                                          href
                                                        );
                                                        dom_default.dispatchEvent(window, "phx:navigate", {
                                                          detail: { patch: true, href, pop: false, direction: "forward" }
                                                        });
                                                        this.registerNewLocation(window.location);
                                                      }
                                                      historyRedirect(e, href, linkState, flash, targetEl) {
                                                        const clickLoading = targetEl && e.isTrusted && e.type !== "popstate";
                                                        if (clickLoading) {
                                                          targetEl.classList.add("phx-click-loading");
                                                        }
                                                        if (!this.isConnected() || !this.main.isMain()) {
                                                          return browser_default.redirect(href, flash);
                                                        }
                                                        if (/^\/$|^\/[^\/]+.*$/.test(href)) {
                                                          const { protocol, host } = window.location;
                                                          href = `${protocol}//${host}${href}`;
                                                        }
                                                        const scroll = window.scrollY;
                                                        this.withPageLoading({ to: href, kind: "redirect" }, (done) => {
                                                          this.replaceMain(href, flash, (linkRef) => {
                                                            if (linkRef === this.linkRef) {
                                                              this.currentHistoryPosition++;
                                                              this.sessionStorage.setItem(
                                                                PHX_LV_HISTORY_POSITION,
                                                                this.currentHistoryPosition.toString()
                                                              );
                                                              browser_default.updateCurrentState((state) => ({
                                                                ...state,
                                                                backType: "redirect"
                                                              }));
                                                              browser_default.pushState(
                                                                linkState,
                                                                {
                                                                  type: "redirect",
                                                                  id: this.main.id,
                                                                  scroll,
                                                                  position: this.currentHistoryPosition
                                                                },
                                                                href
                                                              );
                                                              dom_default.dispatchEvent(window, "phx:navigate", {
                                                                detail: { href, patch: false, pop: false, direction: "forward" }
                                                              });
                                                              this.registerNewLocation(window.location);
                                                            }
                                                            if (clickLoading) {
                                                              targetEl.classList.remove("phx-click-loading");
                                                            }
                                                            done();
                                                          });
                                                        });
                                                      }
                                                      registerNewLocation(newLocation) {
                                                        const { pathname, search } = this.currentLocation;
                                                        if (pathname + search === newLocation.pathname + newLocation.search) {
                                                          return false;
                                                        } else {
                                                          this.currentLocation = clone(newLocation);
                                                          return true;
                                                        }
                                                      }
                                                      bindForms() {
                                                        let iterations = 0;
                                                        let externalFormSubmitted = false;
                                                        this.on("submit", (e) => {
                                                          const phxSubmit = e.target.getAttribute(this.binding("submit"));
                                                          const phxChange = e.target.getAttribute(this.binding("change"));
                                                          if (!externalFormSubmitted && phxChange && !phxSubmit) {
                                                            externalFormSubmitted = true;
                                                            e.preventDefault();
                                                            this.withinOwners(e.target, (view) => {
                                                              view.disableForm(e.target);
                                                              window.requestAnimationFrame(() => {
                                                                if (dom_default.isUnloadableFormSubmit(e)) {
                                                                  this.unload();
                                                                }
                                                                e.target.submit();
                                                              });
                                                            });
                                                          }
                                                        });
                                                        this.on("submit", (e) => {
                                                          const phxEvent = e.target.getAttribute(this.binding("submit"));
                                                          if (!phxEvent) {
                                                            if (dom_default.isUnloadableFormSubmit(e)) {
                                                              this.unload();
                                                            }
                                                            return;
                                                          }
                                                          e.preventDefault();
                                                          e.target.disabled = true;
                                                          this.withinOwners(e.target, (view) => {
                                                            js_default.exec(e, "submit", phxEvent, view, e.target, [
                                                              "push",
                                                              { submitter: e.submitter }
                                                            ]);
                                                          });
                                                        });
                                                        for (const type of ["change", "input"]) {
                                                          this.on(type, (e) => {
                                                            if (e instanceof CustomEvent && (e.target instanceof HTMLInputElement || e.target instanceof HTMLSelectElement || e.target instanceof HTMLTextAreaElement) && e.target.form === void 0) {
                                                              if (e.detail && e.detail.dispatcher) {
                                                                throw new Error(
                                                                  `dispatching a custom ${type} event is only supported on input elements inside a form`
                                                                );
                                                              }
                                                              return;
                                                            }
                                                            const phxChange = this.binding("change");
                                                            const input = e.target;
                                                            if (this.blockPhxChangeWhileComposing && e.isComposing) {
                                                              const key = `composition-listener-${type}`;
                                                              if (!dom_default.private(input, key)) {
                                                                dom_default.putPrivate(input, key, true);
                                                                input.addEventListener(
                                                                  "compositionend",
                                                                  () => {
                                                                    input.dispatchEvent(new Event(type, { bubbles: true }));
                                                                    dom_default.deletePrivate(input, key);
                                                                  },
                                                                  { once: true }
                                                                );
                                                              }
                                                              return;
                                                            }
                                                            const inputEvent = input.getAttribute(phxChange);
                                                            const formEvent = input.form && input.form.getAttribute(phxChange);
                                                            const phxEvent = inputEvent || formEvent;
                                                            if (!phxEvent) {
                                                              return;
                                                            }
                                                            if (input.type === "number" && input.validity && input.validity.badInput) {
                                                              return;
                                                            }
                                                            const dispatcher = inputEvent ? input : input.form;
                                                            const currentIterations = iterations;
                                                            iterations++;
                                                            const { at, type: lastType } = dom_default.private(input, "prev-iteration") || {};
                                                            if (at === currentIterations - 1 && type === "change" && lastType === "input") {
                                                              return;
                                                            }
                                                            dom_default.putPrivate(input, "prev-iteration", {
                                                              at: currentIterations,
                                                              type
                                                            });
                                                            this.debounce(input, e, type, () => {
                                                              this.withinOwners(dispatcher, (view) => {
                                                                dom_default.putPrivate(input, PHX_HAS_FOCUSED, true);
                                                                js_default.exec(e, "change", phxEvent, view, input, [
                                                                  "push",
                                                                  { _target: e.target.name, dispatcher }
                                                                ]);
                                                              });
                                                            });
                                                          });
                                                        }
                                                        this.on("reset", (e) => {
                                                          const form = e.target;
                                                          dom_default.resetForm(form);
                                                          const input = Array.from(form.elements).find((el) => el.type === "reset");
                                                          if (input) {
                                                            window.requestAnimationFrame(() => {
                                                              input.dispatchEvent(
                                                                new Event("input", { bubbles: true, cancelable: false })
                                                              );
                                                            });
                                                          }
                                                        });
                                                      }
                                                      debounce(el, event, eventType, callback) {
                                                        if (eventType === "blur" || eventType === "focusout") {
                                                          return callback();
                                                        }
                                                        const phxDebounce = this.binding(PHX_DEBOUNCE);
                                                        const phxThrottle = this.binding(PHX_THROTTLE);
                                                        const defaultDebounce = this.defaults.debounce.toString();
                                                        const defaultThrottle = this.defaults.throttle.toString();
                                                        this.withinOwners(el, (view) => {
                                                          const asyncFilter = () => !view.isDestroyed() && document.body.contains(el);
                                                          dom_default.debounce(
                                                            el,
                                                            event,
                                                            phxDebounce,
                                                            defaultDebounce,
                                                            phxThrottle,
                                                            defaultThrottle,
                                                            asyncFilter,
                                                            () => {
                                                              callback();
                                                            }
                                                          );
                                                        });
                                                      }
                                                      silenceEvents(callback) {
                                                        this.silenced = true;
                                                        callback();
                                                        this.silenced = false;
                                                      }
                                                      on(event, callback) {
                                                        this.boundEventNames.add(event);
                                                        window.addEventListener(event, (e) => {
                                                          if (!this.silenced) {
                                                            callback(e);
                                                          }
                                                        });
                                                      }
                                                      jsQuerySelectorAll(sourceEl, query, defaultQuery) {
                                                        const all = this.domCallbacks.jsQuerySelectorAll;
                                                        return all ? all(sourceEl, query, defaultQuery) : defaultQuery();
                                                      }
                                                    };
                                                    var TransitionSet = class {
                                                      constructor() {
                                                        this.transitions = /* @__PURE__ */ new Set();
                                                        this.promises = /* @__PURE__ */ new Set();
                                                        this.pendingOps = [];
                                                      }
                                                      reset() {
                                                        this.transitions.forEach((timer) => {
                                                          clearTimeout(timer);
                                                          this.transitions.delete(timer);
                                                        });
                                                        this.promises.clear();
                                                        this.flushPendingOps();
                                                      }
                                                      after(callback) {
                                                        if (this.size() === 0) {
                                                          callback();
                                                        } else {
                                                          this.pushPendingOp(callback);
                                                        }
                                                      }
                                                      addTransition(time, onStart, onDone) {
                                                        onStart();
                                                        const timer = setTimeout(() => {
                                                          this.transitions.delete(timer);
                                                          onDone();
                                                          this.flushPendingOps();
                                                        }, time);
                                                        this.transitions.add(timer);
                                                      }
                                                      addAsyncTransition(promise) {
                                                        this.promises.add(promise);
                                                        promise.then(() => {
                                                          this.promises.delete(promise);
                                                          this.flushPendingOps();
                                                        });
                                                      }
                                                      pushPendingOp(op) {
                                                        this.pendingOps.push(op);
                                                      }
                                                      size() {
                                                        return this.transitions.size + this.promises.size;
                                                      }
                                                      flushPendingOps() {
                                                        if (this.size() > 0) {
                                                          return;
                                                        }
                                                        const op = this.pendingOps.shift();
                                                        if (op) {
                                                          op();
                                                          this.flushPendingOps();
                                                        }
                                                      }
                                                    };
                                                    var LiveSocket2 = LiveSocket;
                                                    $(function() {
                                                      $("a[href^=#]").click(function() {
                                                        const speed = 400;
                                                        let href = $(this).attr("href");
                                                        const target = $(href === "#" || href === "" ? "html" : href);
                                                        $($.browser.safari ? "body" : "html").animate({
                                                          scrollTop: position
                                                        }, speed, "swing");
                                                        let body = "body";
                                                        const userAgent = window.navigator.userAgent.toLowerCase();
                                                        if (userAgent.indexOf("msie") > -1 || userAgent.indexOf("trident") > -1 || userAgent.indexOf("firefox") > -1) {
                                                          body = "html";
                                                        }
                                                        $(body).animate({
                                                          scrollTop: position
                                                        }, speed, "swing");
                                                        return false;
                                                      });
                                                    });
                                                    var csrfToken = document.querySelector("meta[name='csrf-token']").getAttribute("content");
                                                    var liveSocket = new LiveSocket2("/live", Socket, {
                                                      longPollFallbackMs: 2500,
                                                      params: { _csrf_token: csrfToken },
                                                      hooks: { ...colocatedHooks }
                                                    });
                                                    topbar.config({ barColors: { 0: "#29d" }, shadowColor: "rgba(0, 0, 0, .3)" });
                                                    window.addEventListener("phx:page-loading-start", (_info) => topbar.show(300));
                                                    window.addEventListener("phx:page-loading-stop", (_info) => topbar.hide());
                                                    liveSocket.connect();
                                                    window.liveSocket = liveSocket;
                                                    if (true) {
                                                      window.addEventListener("phx:live_reload:attached", ({ detail: reloader }) => {
                                                        reloader.enableServerLogs();
                                                        let keyDown;
                                                        window.addEventListener("keydown", (e) => keyDown = e.key);
                                                        window.addEventListener("keyup", (_e) => keyDown = null);
                                                        window.addEventListener("click", (e) => {
                                                          if (keyDown === "c") {
                                                            e.preventDefault();
                                                            e.stopImmediatePropagation();
                                                            reloader.openEditorAtCaller(e.target);
                                                          } else if (keyDown === "d") {
                                                            e.preventDefault();
                                                            e.stopImmediatePropagation();
                                                            reloader.openEditorAtDef(e.target);
                                                          }
                                                        }, true);
                                                        window.liveReloader = reloader;
                                                      });
                                                    }
                                                  })();
                                                })();
                                              })();
                                            })();
                                          })();
                                        })();
                                      })();
                                    })();
                                  })();
                                })();
                              })();
                            })();
                          })();
                        })();
                      })();
                    })();
                  })();
                })();
              })();
            })();
          })();
        })();
      })();
    })();
  })();
})();
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vZGVwcy9waG9lbml4X2h0bWwvcHJpdi9zdGF0aWMvcGhvZW5peF9odG1sLmpzIiwgIi4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC91dGlscy5qcyIsICIuLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvY29uc3RhbnRzLmpzIiwgIi4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9wdXNoLmpzIiwgIi4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC90aW1lci5qcyIsICIuLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvY2hhbm5lbC5qcyIsICIuLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvYWpheC5qcyIsICIuLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvbG9uZ3BvbGwuanMiLCAiLi4vLi4vZGVwcy9waG9lbml4L2Fzc2V0cy9qcy9waG9lbml4L3ByZXNlbmNlLmpzIiwgIi4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9zZXJpYWxpemVyLmpzIiwgIi4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9zb2NrZXQuanMiLCAiLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvY29uc3RhbnRzLmpzIiwgIi4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2VudHJ5X3VwbG9hZGVyLmpzIiwgIi4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L3V0aWxzLmpzIiwgIi4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2Jyb3dzZXIuanMiLCAiLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvZG9tLmpzIiwgIi4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L3VwbG9hZF9lbnRyeS5qcyIsICIuLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9saXZlX3VwbG9hZGVyLmpzIiwgIi4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2FyaWEuanMiLCAiLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvaG9va3MuanMiLCAiLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvZWxlbWVudF9yZWYuanMiLCAiLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvZG9tX3Bvc3RfbW9ycGhfcmVzdG9yZXIuanMiLCAiLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9ub2RlX21vZHVsZXMvbW9ycGhkb20vZGlzdC9tb3JwaGRvbS1lc20uanMiLCAiLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvZG9tX3BhdGNoLmpzIiwgIi4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L3JlbmRlcmVkLmpzIiwgIi4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2pzLmpzIiwgIi4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2pzX2NvbW1hbmRzLnRzIiwgIi4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L3ZpZXdfaG9vay50cyIsICIuLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy92aWV3LmpzIiwgIi4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2xpdmVfc29ja2V0LmpzIiwgIi4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2luZGV4LnRzIiwgImNhaXJvLmpzIiwgImFwcC5qcyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiXCJ1c2Ugc3RyaWN0XCI7XG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIFBvbHlmaWxsRXZlbnQgPSBldmVudENvbnN0cnVjdG9yKCk7XG5cbiAgZnVuY3Rpb24gZXZlbnRDb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gd2luZG93LkN1c3RvbUV2ZW50O1xuICAgIC8vIElFPD05IFN1cHBvcnRcbiAgICBmdW5jdGlvbiBDdXN0b21FdmVudChldmVudCwgcGFyYW1zKSB7XG4gICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge2J1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSwgZGV0YWlsOiB1bmRlZmluZWR9O1xuICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldmVudCwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKTtcbiAgICAgIHJldHVybiBldnQ7XG4gICAgfVxuICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGU7XG4gICAgcmV0dXJuIEN1c3RvbUV2ZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRIaWRkZW5JbnB1dChuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBpbnB1dC50eXBlID0gXCJoaWRkZW5cIjtcbiAgICBpbnB1dC5uYW1lID0gbmFtZTtcbiAgICBpbnB1dC52YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGVsZW1lbnQsIHRhcmdldE1vZGlmaWVyS2V5KSB7XG4gICAgdmFyIHRvID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRvXCIpLFxuICAgICAgICBtZXRob2QgPSBidWlsZEhpZGRlbklucHV0KFwiX21ldGhvZFwiLCBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtbWV0aG9kXCIpKSxcbiAgICAgICAgY3NyZiA9IGJ1aWxkSGlkZGVuSW5wdXQoXCJfY3NyZl90b2tlblwiLCBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtY3NyZlwiKSksXG4gICAgICAgIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiKSxcbiAgICAgICAgc3VibWl0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpLFxuICAgICAgICB0YXJnZXQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcInRhcmdldFwiKTtcblxuICAgIGZvcm0ubWV0aG9kID0gKGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1tZXRob2RcIikgPT09IFwiZ2V0XCIpID8gXCJnZXRcIiA6IFwicG9zdFwiO1xuICAgIGZvcm0uYWN0aW9uID0gdG87XG4gICAgZm9ybS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cbiAgICBpZiAodGFyZ2V0KSBmb3JtLnRhcmdldCA9IHRhcmdldDtcbiAgICBlbHNlIGlmICh0YXJnZXRNb2RpZmllcktleSkgZm9ybS50YXJnZXQgPSBcIl9ibGFua1wiO1xuXG4gICAgZm9ybS5hcHBlbmRDaGlsZChjc3JmKTtcbiAgICBmb3JtLmFwcGVuZENoaWxkKG1ldGhvZCk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcblxuICAgIC8vIEluc2VydCBhIGJ1dHRvbiBhbmQgY2xpY2sgaXQgaW5zdGVhZCBvZiB1c2luZyBgZm9ybS5zdWJtaXRgXG4gICAgLy8gYmVjYXVzZSB0aGUgYHN1Ym1pdGAgZnVuY3Rpb24gZG9lcyBub3QgZW1pdCBhIGBzdWJtaXRgIGV2ZW50LlxuICAgIHN1Ym1pdC50eXBlID0gXCJzdWJtaXRcIjtcbiAgICBmb3JtLmFwcGVuZENoaWxkKHN1Ym1pdCk7XG4gICAgc3VibWl0LmNsaWNrKCk7XG4gIH1cblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWxlbWVudCA9IGUudGFyZ2V0O1xuICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcblxuICAgIHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKSB7XG4gICAgICB2YXIgcGhvZW5peExpbmtFdmVudCA9IG5ldyBQb2x5ZmlsbEV2ZW50KCdwaG9lbml4LmxpbmsuY2xpY2snLCB7XG4gICAgICAgIFwiYnViYmxlc1wiOiB0cnVlLCBcImNhbmNlbGFibGVcIjogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghZWxlbWVudC5kaXNwYXRjaEV2ZW50KHBob2VuaXhMaW5rRXZlbnQpKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1ldGhvZFwiKSAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdG9cIikpIHtcbiAgICAgICAgaGFuZGxlQ2xpY2soZWxlbWVudCwgZS5tZXRhS2V5IHx8IGUuc2hpZnRLZXkpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9LCBmYWxzZSk7XG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Bob2VuaXgubGluay5jbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbmZpcm1cIik7XG4gICAgaWYobWVzc2FnZSAmJiAhd2luZG93LmNvbmZpcm0obWVzc2FnZSkpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sIGZhbHNlKTtcbn0pKCk7XG4iLCAiLy8gd3JhcHMgdmFsdWUgaW4gY2xvc3VyZSBvciByZXR1cm5zIGNsb3N1cmVcbmV4cG9ydCBsZXQgY2xvc3VyZSA9ICh2YWx1ZSkgPT4ge1xuICBpZih0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIil7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgbGV0IGNsb3N1cmUgPSBmdW5jdGlvbiAoKXsgcmV0dXJuIHZhbHVlIH1cbiAgICByZXR1cm4gY2xvc3VyZVxuICB9XG59XG4iLCAiZXhwb3J0IGNvbnN0IGdsb2JhbFNlbGYgPSB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiBudWxsXG5leHBvcnQgY29uc3QgcGh4V2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IG51bGxcbmV4cG9ydCBjb25zdCBnbG9iYWwgPSBnbG9iYWxTZWxmIHx8IHBoeFdpbmRvdyB8fCBnbG9iYWxUaGlzXG5leHBvcnQgY29uc3QgREVGQVVMVF9WU04gPSBcIjIuMC4wXCJcbmV4cG9ydCBjb25zdCBTT0NLRVRfU1RBVEVTID0ge2Nvbm5lY3Rpbmc6IDAsIG9wZW46IDEsIGNsb3Npbmc6IDIsIGNsb3NlZDogM31cbmV4cG9ydCBjb25zdCBERUZBVUxUX1RJTUVPVVQgPSAxMDAwMFxuZXhwb3J0IGNvbnN0IFdTX0NMT1NFX05PUk1BTCA9IDEwMDBcbmV4cG9ydCBjb25zdCBDSEFOTkVMX1NUQVRFUyA9IHtcbiAgY2xvc2VkOiBcImNsb3NlZFwiLFxuICBlcnJvcmVkOiBcImVycm9yZWRcIixcbiAgam9pbmVkOiBcImpvaW5lZFwiLFxuICBqb2luaW5nOiBcImpvaW5pbmdcIixcbiAgbGVhdmluZzogXCJsZWF2aW5nXCIsXG59XG5leHBvcnQgY29uc3QgQ0hBTk5FTF9FVkVOVFMgPSB7XG4gIGNsb3NlOiBcInBoeF9jbG9zZVwiLFxuICBlcnJvcjogXCJwaHhfZXJyb3JcIixcbiAgam9pbjogXCJwaHhfam9pblwiLFxuICByZXBseTogXCJwaHhfcmVwbHlcIixcbiAgbGVhdmU6IFwicGh4X2xlYXZlXCJcbn1cblxuZXhwb3J0IGNvbnN0IFRSQU5TUE9SVFMgPSB7XG4gIGxvbmdwb2xsOiBcImxvbmdwb2xsXCIsXG4gIHdlYnNvY2tldDogXCJ3ZWJzb2NrZXRcIlxufVxuZXhwb3J0IGNvbnN0IFhIUl9TVEFURVMgPSB7XG4gIGNvbXBsZXRlOiA0XG59XG5leHBvcnQgY29uc3QgQVVUSF9UT0tFTl9QUkVGSVggPSBcImJhc2U2NHVybC5iZWFyZXIucGh4LlwiXG4iLCAiLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgUHVzaFxuICogQHBhcmFtIHtDaGFubmVsfSBjaGFubmVsIC0gVGhlIENoYW5uZWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCAtIFRoZSBldmVudCwgZm9yIGV4YW1wbGUgYFwicGh4X2pvaW5cImBcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkIC0gVGhlIHBheWxvYWQsIGZvciBleGFtcGxlIGB7dXNlcl9pZDogMTIzfWBcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0IC0gVGhlIHB1c2ggdGltZW91dCBpbiBtaWxsaXNlY29uZHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHVzaCB7XG4gIGNvbnN0cnVjdG9yKGNoYW5uZWwsIGV2ZW50LCBwYXlsb2FkLCB0aW1lb3V0KXtcbiAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsXG4gICAgdGhpcy5ldmVudCA9IGV2ZW50XG4gICAgdGhpcy5wYXlsb2FkID0gcGF5bG9hZCB8fCBmdW5jdGlvbiAoKXsgcmV0dXJuIHt9IH1cbiAgICB0aGlzLnJlY2VpdmVkUmVzcCA9IG51bGxcbiAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0XG4gICAgdGhpcy50aW1lb3V0VGltZXIgPSBudWxsXG4gICAgdGhpcy5yZWNIb29rcyA9IFtdXG4gICAgdGhpcy5zZW50ID0gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dFxuICAgKi9cbiAgcmVzZW5kKHRpbWVvdXQpe1xuICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXRcbiAgICB0aGlzLnJlc2V0KClcbiAgICB0aGlzLnNlbmQoKVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqL1xuICBzZW5kKCl7XG4gICAgaWYodGhpcy5oYXNSZWNlaXZlZChcInRpbWVvdXRcIikpeyByZXR1cm4gfVxuICAgIHRoaXMuc3RhcnRUaW1lb3V0KClcbiAgICB0aGlzLnNlbnQgPSB0cnVlXG4gICAgdGhpcy5jaGFubmVsLnNvY2tldC5wdXNoKHtcbiAgICAgIHRvcGljOiB0aGlzLmNoYW5uZWwudG9waWMsXG4gICAgICBldmVudDogdGhpcy5ldmVudCxcbiAgICAgIHBheWxvYWQ6IHRoaXMucGF5bG9hZCgpLFxuICAgICAgcmVmOiB0aGlzLnJlZixcbiAgICAgIGpvaW5fcmVmOiB0aGlzLmNoYW5uZWwuam9pblJlZigpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHN0YXR1c1xuICAgKiBAcGFyYW0geyp9IGNhbGxiYWNrXG4gICAqL1xuICByZWNlaXZlKHN0YXR1cywgY2FsbGJhY2spe1xuICAgIGlmKHRoaXMuaGFzUmVjZWl2ZWQoc3RhdHVzKSl7XG4gICAgICBjYWxsYmFjayh0aGlzLnJlY2VpdmVkUmVzcC5yZXNwb25zZSlcbiAgICB9XG5cbiAgICB0aGlzLnJlY0hvb2tzLnB1c2goe3N0YXR1cywgY2FsbGJhY2t9KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlc2V0KCl7XG4gICAgdGhpcy5jYW5jZWxSZWZFdmVudCgpXG4gICAgdGhpcy5yZWYgPSBudWxsXG4gICAgdGhpcy5yZWZFdmVudCA9IG51bGxcbiAgICB0aGlzLnJlY2VpdmVkUmVzcCA9IG51bGxcbiAgICB0aGlzLnNlbnQgPSBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBtYXRjaFJlY2VpdmUoe3N0YXR1cywgcmVzcG9uc2UsIF9yZWZ9KXtcbiAgICB0aGlzLnJlY0hvb2tzLmZpbHRlcihoID0+IGguc3RhdHVzID09PSBzdGF0dXMpXG4gICAgICAuZm9yRWFjaChoID0+IGguY2FsbGJhY2socmVzcG9uc2UpKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjYW5jZWxSZWZFdmVudCgpe1xuICAgIGlmKCF0aGlzLnJlZkV2ZW50KXsgcmV0dXJuIH1cbiAgICB0aGlzLmNoYW5uZWwub2ZmKHRoaXMucmVmRXZlbnQpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhbmNlbFRpbWVvdXQoKXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0VGltZXIpXG4gICAgdGhpcy50aW1lb3V0VGltZXIgPSBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXJ0VGltZW91dCgpe1xuICAgIGlmKHRoaXMudGltZW91dFRpbWVyKXsgdGhpcy5jYW5jZWxUaW1lb3V0KCkgfVxuICAgIHRoaXMucmVmID0gdGhpcy5jaGFubmVsLnNvY2tldC5tYWtlUmVmKClcbiAgICB0aGlzLnJlZkV2ZW50ID0gdGhpcy5jaGFubmVsLnJlcGx5RXZlbnROYW1lKHRoaXMucmVmKVxuXG4gICAgdGhpcy5jaGFubmVsLm9uKHRoaXMucmVmRXZlbnQsIHBheWxvYWQgPT4ge1xuICAgICAgdGhpcy5jYW5jZWxSZWZFdmVudCgpXG4gICAgICB0aGlzLmNhbmNlbFRpbWVvdXQoKVxuICAgICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBwYXlsb2FkXG4gICAgICB0aGlzLm1hdGNoUmVjZWl2ZShwYXlsb2FkKVxuICAgIH0pXG5cbiAgICB0aGlzLnRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy50cmlnZ2VyKFwidGltZW91dFwiLCB7fSlcbiAgICB9LCB0aGlzLnRpbWVvdXQpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhc1JlY2VpdmVkKHN0YXR1cyl7XG4gICAgcmV0dXJuIHRoaXMucmVjZWl2ZWRSZXNwICYmIHRoaXMucmVjZWl2ZWRSZXNwLnN0YXR1cyA9PT0gc3RhdHVzXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRyaWdnZXIoc3RhdHVzLCByZXNwb25zZSl7XG4gICAgdGhpcy5jaGFubmVsLnRyaWdnZXIodGhpcy5yZWZFdmVudCwge3N0YXR1cywgcmVzcG9uc2V9KVxuICB9XG59XG4iLCAiLyoqXG4gKlxuICogQ3JlYXRlcyBhIHRpbWVyIHRoYXQgYWNjZXB0cyBhIGB0aW1lckNhbGNgIGZ1bmN0aW9uIHRvIHBlcmZvcm1cbiAqIGNhbGN1bGF0ZWQgdGltZW91dCByZXRyaWVzLCBzdWNoIGFzIGV4cG9uZW50aWFsIGJhY2tvZmYuXG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCByZWNvbm5lY3RUaW1lciA9IG5ldyBUaW1lcigoKSA9PiB0aGlzLmNvbm5lY3QoKSwgZnVuY3Rpb24odHJpZXMpe1xuICogICByZXR1cm4gWzEwMDAsIDUwMDAsIDEwMDAwXVt0cmllcyAtIDFdIHx8IDEwMDAwXG4gKiB9KVxuICogcmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgLy8gZmlyZXMgYWZ0ZXIgMTAwMFxuICogcmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgLy8gZmlyZXMgYWZ0ZXIgNTAwMFxuICogcmVjb25uZWN0VGltZXIucmVzZXQoKVxuICogcmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgLy8gZmlyZXMgYWZ0ZXIgMTAwMFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0aW1lckNhbGNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGltZXIge1xuICBjb25zdHJ1Y3RvcihjYWxsYmFjaywgdGltZXJDYWxjKXtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICB0aGlzLnRpbWVyQ2FsYyA9IHRpbWVyQ2FsY1xuICAgIHRoaXMudGltZXIgPSBudWxsXG4gICAgdGhpcy50cmllcyA9IDBcbiAgfVxuXG4gIHJlc2V0KCl7XG4gICAgdGhpcy50cmllcyA9IDBcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcilcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWxzIGFueSBwcmV2aW91cyBzY2hlZHVsZVRpbWVvdXQgYW5kIHNjaGVkdWxlcyBjYWxsYmFja1xuICAgKi9cbiAgc2NoZWR1bGVUaW1lb3V0KCl7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpXG5cbiAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnRyaWVzID0gdGhpcy50cmllcyArIDFcbiAgICAgIHRoaXMuY2FsbGJhY2soKVxuICAgIH0sIHRoaXMudGltZXJDYWxjKHRoaXMudHJpZXMgKyAxKSlcbiAgfVxufVxuIiwgImltcG9ydCB7Y2xvc3VyZX0gZnJvbSBcIi4vdXRpbHNcIlxuaW1wb3J0IHtcbiAgQ0hBTk5FTF9FVkVOVFMsXG4gIENIQU5ORUxfU1RBVEVTLFxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQgUHVzaCBmcm9tIFwiLi9wdXNoXCJcbmltcG9ydCBUaW1lciBmcm9tIFwiLi90aW1lclwiXG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BpY1xuICogQHBhcmFtIHsoT2JqZWN0fGZ1bmN0aW9uKX0gcGFyYW1zXG4gKiBAcGFyYW0ge1NvY2tldH0gc29ja2V0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENoYW5uZWwge1xuICBjb25zdHJ1Y3Rvcih0b3BpYywgcGFyYW1zLCBzb2NrZXQpe1xuICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5jbG9zZWRcbiAgICB0aGlzLnRvcGljID0gdG9waWNcbiAgICB0aGlzLnBhcmFtcyA9IGNsb3N1cmUocGFyYW1zIHx8IHt9KVxuICAgIHRoaXMuc29ja2V0ID0gc29ja2V0XG4gICAgdGhpcy5iaW5kaW5ncyA9IFtdXG4gICAgdGhpcy5iaW5kaW5nUmVmID0gMFxuICAgIHRoaXMudGltZW91dCA9IHRoaXMuc29ja2V0LnRpbWVvdXRcbiAgICB0aGlzLmpvaW5lZE9uY2UgPSBmYWxzZVxuICAgIHRoaXMuam9pblB1c2ggPSBuZXcgUHVzaCh0aGlzLCBDSEFOTkVMX0VWRU5UUy5qb2luLCB0aGlzLnBhcmFtcywgdGhpcy50aW1lb3V0KVxuICAgIHRoaXMucHVzaEJ1ZmZlciA9IFtdXG4gICAgdGhpcy5zdGF0ZUNoYW5nZVJlZnMgPSBbXVxuXG4gICAgdGhpcy5yZWpvaW5UaW1lciA9IG5ldyBUaW1lcigoKSA9PiB7XG4gICAgICBpZih0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKXsgdGhpcy5yZWpvaW4oKSB9XG4gICAgfSwgdGhpcy5zb2NrZXQucmVqb2luQWZ0ZXJNcylcbiAgICB0aGlzLnN0YXRlQ2hhbmdlUmVmcy5wdXNoKHRoaXMuc29ja2V0Lm9uRXJyb3IoKCkgPT4gdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpKSlcbiAgICB0aGlzLnN0YXRlQ2hhbmdlUmVmcy5wdXNoKHRoaXMuc29ja2V0Lm9uT3BlbigoKSA9PiB7XG4gICAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KClcbiAgICAgIGlmKHRoaXMuaXNFcnJvcmVkKCkpeyB0aGlzLnJlam9pbigpIH1cbiAgICB9KVxuICAgIClcbiAgICB0aGlzLmpvaW5QdXNoLnJlY2VpdmUoXCJva1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuam9pbmVkXG4gICAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KClcbiAgICAgIHRoaXMucHVzaEJ1ZmZlci5mb3JFYWNoKHB1c2hFdmVudCA9PiBwdXNoRXZlbnQuc2VuZCgpKVxuICAgICAgdGhpcy5wdXNoQnVmZmVyID0gW11cbiAgICB9KVxuICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZShcImVycm9yXCIsICgpID0+IHtcbiAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5lcnJvcmVkXG4gICAgICBpZih0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKXsgdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKSB9XG4gICAgfSlcbiAgICB0aGlzLm9uQ2xvc2UoKCkgPT4ge1xuICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpXG4gICAgICBpZih0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSkgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBgY2xvc2UgJHt0aGlzLnRvcGljfSAke3RoaXMuam9pblJlZigpfWApXG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkXG4gICAgICB0aGlzLnNvY2tldC5yZW1vdmUodGhpcylcbiAgICB9KVxuICAgIHRoaXMub25FcnJvcihyZWFzb24gPT4ge1xuICAgICAgaWYodGhpcy5zb2NrZXQuaGFzTG9nZ2VyKCkpIHRoaXMuc29ja2V0LmxvZyhcImNoYW5uZWxcIiwgYGVycm9yICR7dGhpcy50b3BpY31gLCByZWFzb24pXG4gICAgICBpZih0aGlzLmlzSm9pbmluZygpKXsgdGhpcy5qb2luUHVzaC5yZXNldCgpIH1cbiAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5lcnJvcmVkXG4gICAgICBpZih0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKXsgdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKSB9XG4gICAgfSlcbiAgICB0aGlzLmpvaW5QdXNoLnJlY2VpdmUoXCJ0aW1lb3V0XCIsICgpID0+IHtcbiAgICAgIGlmKHRoaXMuc29ja2V0Lmhhc0xvZ2dlcigpKSB0aGlzLnNvY2tldC5sb2coXCJjaGFubmVsXCIsIGB0aW1lb3V0ICR7dGhpcy50b3BpY30gKCR7dGhpcy5qb2luUmVmKCl9KWAsIHRoaXMuam9pblB1c2gudGltZW91dClcbiAgICAgIGxldCBsZWF2ZVB1c2ggPSBuZXcgUHVzaCh0aGlzLCBDSEFOTkVMX0VWRU5UUy5sZWF2ZSwgY2xvc3VyZSh7fSksIHRoaXMudGltZW91dClcbiAgICAgIGxlYXZlUHVzaC5zZW5kKClcbiAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5lcnJvcmVkXG4gICAgICB0aGlzLmpvaW5QdXNoLnJlc2V0KClcbiAgICAgIGlmKHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpeyB0aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpIH1cbiAgICB9KVxuICAgIHRoaXMub24oQ0hBTk5FTF9FVkVOVFMucmVwbHksIChwYXlsb2FkLCByZWYpID0+IHtcbiAgICAgIHRoaXMudHJpZ2dlcih0aGlzLnJlcGx5RXZlbnROYW1lKHJlZiksIHBheWxvYWQpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBKb2luIHRoZSBjaGFubmVsXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gdGltZW91dFxuICAgKiBAcmV0dXJucyB7UHVzaH1cbiAgICovXG4gIGpvaW4odGltZW91dCA9IHRoaXMudGltZW91dCl7XG4gICAgaWYodGhpcy5qb2luZWRPbmNlKXtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInRyaWVkIHRvIGpvaW4gbXVsdGlwbGUgdGltZXMuICdqb2luJyBjYW4gb25seSBiZSBjYWxsZWQgYSBzaW5nbGUgdGltZSBwZXIgY2hhbm5lbCBpbnN0YW5jZVwiKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0XG4gICAgICB0aGlzLmpvaW5lZE9uY2UgPSB0cnVlXG4gICAgICB0aGlzLnJlam9pbigpXG4gICAgICByZXR1cm4gdGhpcy5qb2luUHVzaFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIb29rIGludG8gY2hhbm5lbCBjbG9zZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25DbG9zZShjYWxsYmFjayl7XG4gICAgdGhpcy5vbihDSEFOTkVMX0VWRU5UUy5jbG9zZSwgY2FsbGJhY2spXG4gIH1cblxuICAvKipcbiAgICogSG9vayBpbnRvIGNoYW5uZWwgZXJyb3JzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBvbkVycm9yKGNhbGxiYWNrKXtcbiAgICByZXR1cm4gdGhpcy5vbihDSEFOTkVMX0VWRU5UUy5lcnJvciwgcmVhc29uID0+IGNhbGxiYWNrKHJlYXNvbikpXG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlcyBvbiBjaGFubmVsIGV2ZW50c1xuICAgKlxuICAgKiBTdWJzY3JpcHRpb24gcmV0dXJucyBhIHJlZiBjb3VudGVyLCB3aGljaCBjYW4gYmUgdXNlZCBsYXRlciB0b1xuICAgKiB1bnN1YnNjcmliZSB0aGUgZXhhY3QgZXZlbnQgbGlzdGVuZXJcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgcmVmMSA9IGNoYW5uZWwub24oXCJldmVudFwiLCBkb19zdHVmZilcbiAgICogY29uc3QgcmVmMiA9IGNoYW5uZWwub24oXCJldmVudFwiLCBkb19vdGhlcl9zdHVmZilcbiAgICogY2hhbm5lbC5vZmYoXCJldmVudFwiLCByZWYxKVxuICAgKiAvLyBTaW5jZSB1bnN1YnNjcmlwdGlvbiwgZG9fc3R1ZmYgd29uJ3QgZmlyZSxcbiAgICogLy8gd2hpbGUgZG9fb3RoZXJfc3R1ZmYgd2lsbCBrZWVwIGZpcmluZyBvbiB0aGUgXCJldmVudFwiXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7aW50ZWdlcn0gcmVmXG4gICAqL1xuICBvbihldmVudCwgY2FsbGJhY2spe1xuICAgIGxldCByZWYgPSB0aGlzLmJpbmRpbmdSZWYrK1xuICAgIHRoaXMuYmluZGluZ3MucHVzaCh7ZXZlbnQsIHJlZiwgY2FsbGJhY2t9KVxuICAgIHJldHVybiByZWZcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZXMgb2ZmIG9mIGNoYW5uZWwgZXZlbnRzXG4gICAqXG4gICAqIFVzZSB0aGUgcmVmIHJldHVybmVkIGZyb20gYSBjaGFubmVsLm9uKCkgdG8gdW5zdWJzY3JpYmUgb25lXG4gICAqIGhhbmRsZXIsIG9yIHBhc3Mgbm90aGluZyBmb3IgdGhlIHJlZiB0byB1bnN1YnNjcmliZSBhbGxcbiAgICogaGFuZGxlcnMgZm9yIHRoZSBnaXZlbiBldmVudC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gVW5zdWJzY3JpYmUgdGhlIGRvX3N0dWZmIGhhbmRsZXJcbiAgICogY29uc3QgcmVmMSA9IGNoYW5uZWwub24oXCJldmVudFwiLCBkb19zdHVmZilcbiAgICogY2hhbm5lbC5vZmYoXCJldmVudFwiLCByZWYxKVxuICAgKlxuICAgKiAvLyBVbnN1YnNjcmliZSBhbGwgaGFuZGxlcnMgZnJvbSBldmVudFxuICAgKiBjaGFubmVsLm9mZihcImV2ZW50XCIpXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHJlZlxuICAgKi9cbiAgb2ZmKGV2ZW50LCByZWYpe1xuICAgIHRoaXMuYmluZGluZ3MgPSB0aGlzLmJpbmRpbmdzLmZpbHRlcigoYmluZCkgPT4ge1xuICAgICAgcmV0dXJuICEoYmluZC5ldmVudCA9PT0gZXZlbnQgJiYgKHR5cGVvZiByZWYgPT09IFwidW5kZWZpbmVkXCIgfHwgcmVmID09PSBiaW5kLnJlZikpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2FuUHVzaCgpeyByZXR1cm4gdGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSAmJiB0aGlzLmlzSm9pbmVkKCkgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIG1lc3NhZ2UgYGV2ZW50YCB0byBwaG9lbml4IHdpdGggdGhlIHBheWxvYWQgYHBheWxvYWRgLlxuICAgKiBQaG9lbml4IHJlY2VpdmVzIHRoaXMgaW4gdGhlIGBoYW5kbGVfaW4oZXZlbnQsIHBheWxvYWQsIHNvY2tldClgXG4gICAqIGZ1bmN0aW9uLiBpZiBwaG9lbml4IHJlcGxpZXMgb3IgaXQgdGltZXMgb3V0IChkZWZhdWx0IDEwMDAwbXMpLFxuICAgKiB0aGVuIG9wdGlvbmFsbHkgdGhlIHJlcGx5IGNhbiBiZSByZWNlaXZlZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY2hhbm5lbC5wdXNoKFwiZXZlbnRcIilcbiAgICogICAucmVjZWl2ZShcIm9rXCIsIHBheWxvYWQgPT4gY29uc29sZS5sb2coXCJwaG9lbml4IHJlcGxpZWQ6XCIsIHBheWxvYWQpKVxuICAgKiAgIC5yZWNlaXZlKFwiZXJyb3JcIiwgZXJyID0+IGNvbnNvbGUubG9nKFwicGhvZW5peCBlcnJvcmVkXCIsIGVycikpXG4gICAqICAgLnJlY2VpdmUoXCJ0aW1lb3V0XCIsICgpID0+IGNvbnNvbGUubG9nKFwidGltZWQgb3V0IHB1c2hpbmdcIikpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWVvdXRdXG4gICAqIEByZXR1cm5zIHtQdXNofVxuICAgKi9cbiAgcHVzaChldmVudCwgcGF5bG9hZCwgdGltZW91dCA9IHRoaXMudGltZW91dCl7XG4gICAgcGF5bG9hZCA9IHBheWxvYWQgfHwge31cbiAgICBpZighdGhpcy5qb2luZWRPbmNlKXtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdHJpZWQgdG8gcHVzaCAnJHtldmVudH0nIHRvICcke3RoaXMudG9waWN9JyBiZWZvcmUgam9pbmluZy4gVXNlIGNoYW5uZWwuam9pbigpIGJlZm9yZSBwdXNoaW5nIGV2ZW50c2ApXG4gICAgfVxuICAgIGxldCBwdXNoRXZlbnQgPSBuZXcgUHVzaCh0aGlzLCBldmVudCwgZnVuY3Rpb24gKCl7IHJldHVybiBwYXlsb2FkIH0sIHRpbWVvdXQpXG4gICAgaWYodGhpcy5jYW5QdXNoKCkpe1xuICAgICAgcHVzaEV2ZW50LnNlbmQoKVxuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoRXZlbnQuc3RhcnRUaW1lb3V0KClcbiAgICAgIHRoaXMucHVzaEJ1ZmZlci5wdXNoKHB1c2hFdmVudClcbiAgICB9XG5cbiAgICByZXR1cm4gcHVzaEV2ZW50XG4gIH1cblxuICAvKiogTGVhdmVzIHRoZSBjaGFubmVsXG4gICAqXG4gICAqIFVuc3Vic2NyaWJlcyBmcm9tIHNlcnZlciBldmVudHMsIGFuZFxuICAgKiBpbnN0cnVjdHMgY2hhbm5lbCB0byB0ZXJtaW5hdGUgb24gc2VydmVyXG4gICAqXG4gICAqIFRyaWdnZXJzIG9uQ2xvc2UoKSBob29rc1xuICAgKlxuICAgKiBUbyByZWNlaXZlIGxlYXZlIGFja25vd2xlZGdlbWVudHMsIHVzZSB0aGUgYHJlY2VpdmVgXG4gICAqIGhvb2sgdG8gYmluZCB0byB0aGUgc2VydmVyIGFjaywgaWU6XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNoYW5uZWwubGVhdmUoKS5yZWNlaXZlKFwib2tcIiwgKCkgPT4gYWxlcnQoXCJsZWZ0IVwiKSApXG4gICAqXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gdGltZW91dFxuICAgKiBAcmV0dXJucyB7UHVzaH1cbiAgICovXG4gIGxlYXZlKHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpe1xuICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKVxuICAgIHRoaXMuam9pblB1c2guY2FuY2VsVGltZW91dCgpXG5cbiAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMubGVhdmluZ1xuICAgIGxldCBvbkNsb3NlID0gKCkgPT4ge1xuICAgICAgaWYodGhpcy5zb2NrZXQuaGFzTG9nZ2VyKCkpIHRoaXMuc29ja2V0LmxvZyhcImNoYW5uZWxcIiwgYGxlYXZlICR7dGhpcy50b3BpY31gKVxuICAgICAgdGhpcy50cmlnZ2VyKENIQU5ORUxfRVZFTlRTLmNsb3NlLCBcImxlYXZlXCIpXG4gICAgfVxuICAgIGxldCBsZWF2ZVB1c2ggPSBuZXcgUHVzaCh0aGlzLCBDSEFOTkVMX0VWRU5UUy5sZWF2ZSwgY2xvc3VyZSh7fSksIHRpbWVvdXQpXG4gICAgbGVhdmVQdXNoLnJlY2VpdmUoXCJva1wiLCAoKSA9PiBvbkNsb3NlKCkpXG4gICAgICAucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4gb25DbG9zZSgpKVxuICAgIGxlYXZlUHVzaC5zZW5kKClcbiAgICBpZighdGhpcy5jYW5QdXNoKCkpeyBsZWF2ZVB1c2gudHJpZ2dlcihcIm9rXCIsIHt9KSB9XG5cbiAgICByZXR1cm4gbGVhdmVQdXNoXG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGFibGUgbWVzc2FnZSBob29rXG4gICAqXG4gICAqIFJlY2VpdmVzIGFsbCBldmVudHMgZm9yIHNwZWNpYWxpemVkIG1lc3NhZ2UgaGFuZGxpbmdcbiAgICogYmVmb3JlIGRpc3BhdGNoaW5nIHRvIHRoZSBjaGFubmVsIGNhbGxiYWNrcy5cbiAgICpcbiAgICogTXVzdCByZXR1cm4gdGhlIHBheWxvYWQsIG1vZGlmaWVkIG9yIHVubW9kaWZpZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gcmVmXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICBvbk1lc3NhZ2UoX2V2ZW50LCBwYXlsb2FkLCBfcmVmKXsgcmV0dXJuIHBheWxvYWQgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNNZW1iZXIodG9waWMsIGV2ZW50LCBwYXlsb2FkLCBqb2luUmVmKXtcbiAgICBpZih0aGlzLnRvcGljICE9PSB0b3BpYyl7IHJldHVybiBmYWxzZSB9XG5cbiAgICBpZihqb2luUmVmICYmIGpvaW5SZWYgIT09IHRoaXMuam9pblJlZigpKXtcbiAgICAgIGlmKHRoaXMuc29ja2V0Lmhhc0xvZ2dlcigpKSB0aGlzLnNvY2tldC5sb2coXCJjaGFubmVsXCIsIFwiZHJvcHBpbmcgb3V0ZGF0ZWQgbWVzc2FnZVwiLCB7dG9waWMsIGV2ZW50LCBwYXlsb2FkLCBqb2luUmVmfSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgam9pblJlZigpeyByZXR1cm4gdGhpcy5qb2luUHVzaC5yZWYgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVqb2luKHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpe1xuICAgIGlmKHRoaXMuaXNMZWF2aW5nKCkpeyByZXR1cm4gfVxuICAgIHRoaXMuc29ja2V0LmxlYXZlT3BlblRvcGljKHRoaXMudG9waWMpXG4gICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmpvaW5pbmdcbiAgICB0aGlzLmpvaW5QdXNoLnJlc2VuZCh0aW1lb3V0KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0cmlnZ2VyKGV2ZW50LCBwYXlsb2FkLCByZWYsIGpvaW5SZWYpe1xuICAgIGxldCBoYW5kbGVkUGF5bG9hZCA9IHRoaXMub25NZXNzYWdlKGV2ZW50LCBwYXlsb2FkLCByZWYsIGpvaW5SZWYpXG4gICAgaWYocGF5bG9hZCAmJiAhaGFuZGxlZFBheWxvYWQpeyB0aHJvdyBuZXcgRXJyb3IoXCJjaGFubmVsIG9uTWVzc2FnZSBjYWxsYmFja3MgbXVzdCByZXR1cm4gdGhlIHBheWxvYWQsIG1vZGlmaWVkIG9yIHVubW9kaWZpZWRcIikgfVxuXG4gICAgbGV0IGV2ZW50QmluZGluZ3MgPSB0aGlzLmJpbmRpbmdzLmZpbHRlcihiaW5kID0+IGJpbmQuZXZlbnQgPT09IGV2ZW50KVxuXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGV2ZW50QmluZGluZ3MubGVuZ3RoOyBpKyspe1xuICAgICAgbGV0IGJpbmQgPSBldmVudEJpbmRpbmdzW2ldXG4gICAgICBiaW5kLmNhbGxiYWNrKGhhbmRsZWRQYXlsb2FkLCByZWYsIGpvaW5SZWYgfHwgdGhpcy5qb2luUmVmKCkpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZXBseUV2ZW50TmFtZShyZWYpeyByZXR1cm4gYGNoYW5fcmVwbHlfJHtyZWZ9YCB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc0Nsb3NlZCgpeyByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzRXJyb3JlZCgpeyByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZCB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc0pvaW5lZCgpeyByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMuam9pbmVkIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzSm9pbmluZygpeyByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMuam9pbmluZyB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc0xlYXZpbmcoKXsgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmxlYXZpbmcgfVxufVxuIiwgImltcG9ydCB7XG4gIGdsb2JhbCxcbiAgWEhSX1NUQVRFU1xufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBamF4IHtcblxuICBzdGF0aWMgcmVxdWVzdChtZXRob2QsIGVuZFBvaW50LCBoZWFkZXJzLCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKXtcbiAgICBpZihnbG9iYWwuWERvbWFpblJlcXVlc3Qpe1xuICAgICAgbGV0IHJlcSA9IG5ldyBnbG9iYWwuWERvbWFpblJlcXVlc3QoKSAvLyBJRTgsIElFOVxuICAgICAgcmV0dXJuIHRoaXMueGRvbWFpblJlcXVlc3QocmVxLCBtZXRob2QsIGVuZFBvaW50LCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKVxuICAgIH0gZWxzZSBpZihnbG9iYWwuWE1MSHR0cFJlcXVlc3Qpe1xuICAgICAgbGV0IHJlcSA9IG5ldyBnbG9iYWwuWE1MSHR0cFJlcXVlc3QoKSAvLyBJRTcrLCBGaXJlZm94LCBDaHJvbWUsIE9wZXJhLCBTYWZhcmlcbiAgICAgIHJldHVybiB0aGlzLnhoclJlcXVlc3QocmVxLCBtZXRob2QsIGVuZFBvaW50LCBoZWFkZXJzLCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKVxuICAgIH0gZWxzZSBpZihnbG9iYWwuZmV0Y2ggJiYgZ2xvYmFsLkFib3J0Q29udHJvbGxlcil7XG4gICAgICAvLyBGZXRjaCB3aXRoIEFib3J0Q29udHJvbGxlciBmb3IgbW9kZXJuIGJyb3dzZXJzXG4gICAgICByZXR1cm4gdGhpcy5mZXRjaFJlcXVlc3QobWV0aG9kLCBlbmRQb2ludCwgaGVhZGVycywgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjaylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3VpdGFibGUgWE1MSHR0cFJlcXVlc3QgaW1wbGVtZW50YXRpb24gZm91bmRcIilcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZmV0Y2hSZXF1ZXN0KG1ldGhvZCwgZW5kUG9pbnQsIGhlYWRlcnMsIGJvZHksIHRpbWVvdXQsIG9udGltZW91dCwgY2FsbGJhY2spe1xuICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgbWV0aG9kLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHksXG4gICAgfVxuICAgIGxldCBjb250cm9sbGVyID0gbnVsbFxuICAgIGlmKHRpbWVvdXQpe1xuICAgICAgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgICAgY29uc3QgX3RpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCB0aW1lb3V0KVxuICAgICAgb3B0aW9ucy5zaWduYWwgPSBjb250cm9sbGVyLnNpZ25hbFxuICAgIH1cbiAgICBnbG9iYWwuZmV0Y2goZW5kUG9pbnQsIG9wdGlvbnMpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS50ZXh0KCkpXG4gICAgICAudGhlbihkYXRhID0+IHRoaXMucGFyc2VKU09OKGRhdGEpKVxuICAgICAgLnRoZW4oZGF0YSA9PiBjYWxsYmFjayAmJiBjYWxsYmFjayhkYXRhKSlcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICBpZihlcnIubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIgJiYgb250aW1lb3V0KXtcbiAgICAgICAgICBvbnRpbWVvdXQoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG51bGwpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgcmV0dXJuIGNvbnRyb2xsZXJcbiAgfVxuXG4gIHN0YXRpYyB4ZG9tYWluUmVxdWVzdChyZXEsIG1ldGhvZCwgZW5kUG9pbnQsIGJvZHksIHRpbWVvdXQsIG9udGltZW91dCwgY2FsbGJhY2spe1xuICAgIHJlcS50aW1lb3V0ID0gdGltZW91dFxuICAgIHJlcS5vcGVuKG1ldGhvZCwgZW5kUG9pbnQpXG4gICAgcmVxLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIGxldCByZXNwb25zZSA9IHRoaXMucGFyc2VKU09OKHJlcS5yZXNwb25zZVRleHQpXG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhyZXNwb25zZSlcbiAgICB9XG4gICAgaWYob250aW1lb3V0KXsgcmVxLm9udGltZW91dCA9IG9udGltZW91dCB9XG5cbiAgICAvLyBXb3JrIGFyb3VuZCBidWcgaW4gSUU5IHRoYXQgcmVxdWlyZXMgYW4gYXR0YWNoZWQgb25wcm9ncmVzcyBoYW5kbGVyXG4gICAgcmVxLm9ucHJvZ3Jlc3MgPSAoKSA9PiB7IH1cblxuICAgIHJlcS5zZW5kKGJvZHkpXG4gICAgcmV0dXJuIHJlcVxuICB9XG5cbiAgc3RhdGljIHhoclJlcXVlc3QocmVxLCBtZXRob2QsIGVuZFBvaW50LCBoZWFkZXJzLCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKXtcbiAgICByZXEub3BlbihtZXRob2QsIGVuZFBvaW50LCB0cnVlKVxuICAgIHJlcS50aW1lb3V0ID0gdGltZW91dFxuICAgIGZvcihsZXQgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGhlYWRlcnMpKXtcbiAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsdWUpXG4gICAgfVxuICAgIHJlcS5vbmVycm9yID0gKCkgPT4gY2FsbGJhY2sgJiYgY2FsbGJhY2sobnVsbClcbiAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgaWYocmVxLnJlYWR5U3RhdGUgPT09IFhIUl9TVEFURVMuY29tcGxldGUgJiYgY2FsbGJhY2spe1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSB0aGlzLnBhcnNlSlNPTihyZXEucmVzcG9uc2VUZXh0KVxuICAgICAgICBjYWxsYmFjayhyZXNwb25zZSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYob250aW1lb3V0KXsgcmVxLm9udGltZW91dCA9IG9udGltZW91dCB9XG5cbiAgICByZXEuc2VuZChib2R5KVxuICAgIHJldHVybiByZXFcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZUpTT04ocmVzcCl7XG4gICAgaWYoIXJlc3AgfHwgcmVzcCA9PT0gXCJcIil7IHJldHVybiBudWxsIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShyZXNwKVxuICAgIH0gY2F0Y2gge1xuICAgICAgY29uc29sZSAmJiBjb25zb2xlLmxvZyhcImZhaWxlZCB0byBwYXJzZSBKU09OIHJlc3BvbnNlXCIsIHJlc3ApXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBzZXJpYWxpemUob2JqLCBwYXJlbnRLZXkpe1xuICAgIGxldCBxdWVyeVN0ciA9IFtdXG4gICAgZm9yKHZhciBrZXkgaW4gb2JqKXtcbiAgICAgIGlmKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKXsgY29udGludWUgfVxuICAgICAgbGV0IHBhcmFtS2V5ID0gcGFyZW50S2V5ID8gYCR7cGFyZW50S2V5fVske2tleX1dYCA6IGtleVxuICAgICAgbGV0IHBhcmFtVmFsID0gb2JqW2tleV1cbiAgICAgIGlmKHR5cGVvZiBwYXJhbVZhbCA9PT0gXCJvYmplY3RcIil7XG4gICAgICAgIHF1ZXJ5U3RyLnB1c2godGhpcy5zZXJpYWxpemUocGFyYW1WYWwsIHBhcmFtS2V5KSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXJ5U3RyLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtS2V5KSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtVmFsKSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5U3RyLmpvaW4oXCImXCIpXG4gIH1cblxuICBzdGF0aWMgYXBwZW5kUGFyYW1zKHVybCwgcGFyYW1zKXtcbiAgICBpZihPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCA9PT0gMCl7IHJldHVybiB1cmwgfVxuXG4gICAgbGV0IHByZWZpeCA9IHVybC5tYXRjaCgvXFw/LykgPyBcIiZcIiA6IFwiP1wiXG4gICAgcmV0dXJuIGAke3VybH0ke3ByZWZpeH0ke3RoaXMuc2VyaWFsaXplKHBhcmFtcyl9YFxuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgU09DS0VUX1NUQVRFUyxcbiAgVFJBTlNQT1JUUyxcbiAgQVVUSF9UT0tFTl9QUkVGSVhcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IEFqYXggZnJvbSBcIi4vYWpheFwiXG5cbmxldCBhcnJheUJ1ZmZlclRvQmFzZTY0ID0gKGJ1ZmZlcikgPT4ge1xuICBsZXQgYmluYXJ5ID0gXCJcIlxuICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheShidWZmZXIpXG4gIGxldCBsZW4gPSBieXRlcy5ieXRlTGVuZ3RoXG4gIGZvcihsZXQgaSA9IDA7IGkgPCBsZW47IGkrKyl7IGJpbmFyeSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKSB9XG4gIHJldHVybiBidG9hKGJpbmFyeSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9uZ1BvbGwge1xuXG4gIGNvbnN0cnVjdG9yKGVuZFBvaW50LCBwcm90b2NvbHMpe1xuICAgIC8vIHdlIG9ubHkgc3VwcG9ydCBzdWJwcm90b2NvbHMgZm9yIGF1dGhUb2tlblxuICAgIC8vIFtcInBob2VuaXhcIiwgXCJiYXNlNjR1cmwuYmVhcmVyLnBoeC5CQVNFNjRfRU5DT0RFRF9UT0tFTlwiXVxuICAgIGlmKHByb3RvY29scyAmJiBwcm90b2NvbHMubGVuZ3RoID09PSAyICYmIHByb3RvY29sc1sxXS5zdGFydHNXaXRoKEFVVEhfVE9LRU5fUFJFRklYKSl7XG4gICAgICB0aGlzLmF1dGhUb2tlbiA9IGF0b2IocHJvdG9jb2xzWzFdLnNsaWNlKEFVVEhfVE9LRU5fUFJFRklYLmxlbmd0aCkpXG4gICAgfVxuICAgIHRoaXMuZW5kUG9pbnQgPSBudWxsXG4gICAgdGhpcy50b2tlbiA9IG51bGxcbiAgICB0aGlzLnNraXBIZWFydGJlYXQgPSB0cnVlXG4gICAgdGhpcy5yZXFzID0gbmV3IFNldCgpXG4gICAgdGhpcy5hd2FpdGluZ0JhdGNoQWNrID0gZmFsc2VcbiAgICB0aGlzLmN1cnJlbnRCYXRjaCA9IG51bGxcbiAgICB0aGlzLmN1cnJlbnRCYXRjaFRpbWVyID0gbnVsbFxuICAgIHRoaXMuYmF0Y2hCdWZmZXIgPSBbXVxuICAgIHRoaXMub25vcGVuID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgIHRoaXMub25lcnJvciA9IGZ1bmN0aW9uICgpeyB9IC8vIG5vb3BcbiAgICB0aGlzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uICgpeyB9IC8vIG5vb3BcbiAgICB0aGlzLm9uY2xvc2UgPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgdGhpcy5wb2xsRW5kcG9pbnQgPSB0aGlzLm5vcm1hbGl6ZUVuZHBvaW50KGVuZFBvaW50KVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZ1xuICAgIC8vIHdlIG11c3Qgd2FpdCBmb3IgdGhlIGNhbGxlciB0byBmaW5pc2ggc2V0dGluZyB1cCBvdXIgY2FsbGJhY2tzIGFuZCB0aW1lb3V0IHByb3BlcnRpZXNcbiAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMucG9sbCgpLCAwKVxuICB9XG5cbiAgbm9ybWFsaXplRW5kcG9pbnQoZW5kUG9pbnQpe1xuICAgIHJldHVybiAoZW5kUG9pbnRcbiAgICAgIC5yZXBsYWNlKFwid3M6Ly9cIiwgXCJodHRwOi8vXCIpXG4gICAgICAucmVwbGFjZShcIndzczovL1wiLCBcImh0dHBzOi8vXCIpXG4gICAgICAucmVwbGFjZShuZXcgUmVnRXhwKFwiKC4qKVxcL1wiICsgVFJBTlNQT1JUUy53ZWJzb2NrZXQpLCBcIiQxL1wiICsgVFJBTlNQT1JUUy5sb25ncG9sbCkpXG4gIH1cblxuICBlbmRwb2ludFVSTCgpe1xuICAgIHJldHVybiBBamF4LmFwcGVuZFBhcmFtcyh0aGlzLnBvbGxFbmRwb2ludCwge3Rva2VuOiB0aGlzLnRva2VufSlcbiAgfVxuXG4gIGNsb3NlQW5kUmV0cnkoY29kZSwgcmVhc29uLCB3YXNDbGVhbil7XG4gICAgdGhpcy5jbG9zZShjb2RlLCByZWFzb24sIHdhc0NsZWFuKVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZ1xuICB9XG5cbiAgb250aW1lb3V0KCl7XG4gICAgdGhpcy5vbmVycm9yKFwidGltZW91dFwiKVxuICAgIHRoaXMuY2xvc2VBbmRSZXRyeSgxMDA1LCBcInRpbWVvdXRcIiwgZmFsc2UpXG4gIH1cblxuICBpc0FjdGl2ZSgpeyByZXR1cm4gdGhpcy5yZWFkeVN0YXRlID09PSBTT0NLRVRfU1RBVEVTLm9wZW4gfHwgdGhpcy5yZWFkeVN0YXRlID09PSBTT0NLRVRfU1RBVEVTLmNvbm5lY3RpbmcgfVxuXG4gIHBvbGwoKXtcbiAgICBjb25zdCBoZWFkZXJzID0ge1wiQWNjZXB0XCI6IFwiYXBwbGljYXRpb24vanNvblwifVxuICAgIGlmKHRoaXMuYXV0aFRva2VuKXtcbiAgICAgIGhlYWRlcnNbXCJYLVBob2VuaXgtQXV0aFRva2VuXCJdID0gdGhpcy5hdXRoVG9rZW5cbiAgICB9XG4gICAgdGhpcy5hamF4KFwiR0VUXCIsIGhlYWRlcnMsIG51bGwsICgpID0+IHRoaXMub250aW1lb3V0KCksIHJlc3AgPT4ge1xuICAgICAgaWYocmVzcCl7XG4gICAgICAgIHZhciB7c3RhdHVzLCB0b2tlbiwgbWVzc2FnZXN9ID0gcmVzcFxuICAgICAgICBpZihzdGF0dXMgPT09IDQxMCAmJiB0aGlzLnRva2VuICE9PSBudWxsKXtcbiAgICAgICAgICAvLyBJbiBjYXNlIHdlIGFscmVhZHkgaGF2ZSBhIHRva2VuLCB0aGlzIG1lYW5zIHRoYXQgb3VyIGV4aXN0aW5nIHNlc3Npb25cbiAgICAgICAgICAvLyBpcyBnb25lLiBXZSBmYWlsIHNvIHRoYXQgdGhlIGNsaWVudCByZWpvaW5zIGl0cyBjaGFubmVscy5cbiAgICAgICAgICB0aGlzLm9uZXJyb3IoNDEwKVxuICAgICAgICAgIHRoaXMuY2xvc2VBbmRSZXRyeSgzNDEwLCBcInNlc3Npb25fZ29uZVwiLCBmYWxzZSlcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXR1cyA9IDBcbiAgICAgIH1cblxuICAgICAgc3dpdGNoKHN0YXR1cyl7XG4gICAgICAgIGNhc2UgMjAwOlxuICAgICAgICAgIG1lc3NhZ2VzLmZvckVhY2gobXNnID0+IHtcbiAgICAgICAgICAgIC8vIFRhc2tzIGFyZSB3aGF0IHRoaW5ncyBsaWtlIGV2ZW50IGhhbmRsZXJzLCBzZXRUaW1lb3V0IGNhbGxiYWNrcyxcbiAgICAgICAgICAgIC8vIHByb21pc2UgcmVzb2x2ZXMgYW5kIG1vcmUgYXJlIHJ1biB3aXRoaW4uXG4gICAgICAgICAgICAvLyBJbiBtb2Rlcm4gYnJvd3NlcnMsIHRoZXJlIGFyZSB0d28gZGlmZmVyZW50IGtpbmRzIG9mIHRhc2tzLFxuICAgICAgICAgICAgLy8gbWljcm90YXNrcyBhbmQgbWFjcm90YXNrcy5cbiAgICAgICAgICAgIC8vIE1pY3JvdGFza3MgYXJlIG1haW5seSB1c2VkIGZvciBQcm9taXNlcywgd2hpbGUgbWFjcm90YXNrcyBhcmVcbiAgICAgICAgICAgIC8vIHVzZWQgZm9yIGV2ZXJ5dGhpbmcgZWxzZS5cbiAgICAgICAgICAgIC8vIE1pY3JvdGFza3MgYWx3YXlzIGhhdmUgcHJpb3JpdHkgb3ZlciBtYWNyb3Rhc2tzLiBJZiB0aGUgSlMgZW5naW5lXG4gICAgICAgICAgICAvLyBpcyBsb29raW5nIGZvciBhIHRhc2sgdG8gcnVuLCBpdCB3aWxsIGFsd2F5cyB0cnkgdG8gZW1wdHkgdGhlXG4gICAgICAgICAgICAvLyBtaWNyb3Rhc2sgcXVldWUgYmVmb3JlIGF0dGVtcHRpbmcgdG8gcnVuIGFueXRoaW5nIGZyb20gdGhlXG4gICAgICAgICAgICAvLyBtYWNyb3Rhc2sgcXVldWUuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gRm9yIHRoZSBXZWJTb2NrZXQgdHJhbnNwb3J0LCBtZXNzYWdlcyBhbHdheXMgYXJyaXZlIGluIHRoZWlyIG93blxuICAgICAgICAgICAgLy8gZXZlbnQuIFRoaXMgbWVhbnMgdGhhdCBpZiBhbnkgcHJvbWlzZXMgYXJlIHJlc29sdmVkIGZyb20gd2l0aGluLFxuICAgICAgICAgICAgLy8gdGhlaXIgY2FsbGJhY2tzIHdpbGwgYWx3YXlzIGZpbmlzaCBleGVjdXRpb24gYnkgdGhlIHRpbWUgdGhlXG4gICAgICAgICAgICAvLyBuZXh0IG1lc3NhZ2UgZXZlbnQgaGFuZGxlciBpcyBydW4uXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gSW4gb3JkZXIgdG8gZW11bGF0ZSB0aGlzIGJlaGF2aW91ciwgd2UgbmVlZCB0byBtYWtlIHN1cmUgZWFjaFxuICAgICAgICAgICAgLy8gb25tZXNzYWdlIGhhbmRsZXIgaXMgcnVuIHdpdGhpbiBpdHMgb3duIG1hY3JvdGFzay5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5vbm1lc3NhZ2Uoe2RhdGE6IG1zZ30pLCAwKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgdGhpcy5wb2xsKClcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDIwNDpcbiAgICAgICAgICB0aGlzLnBvbGwoKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDEwOlxuICAgICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNPQ0tFVF9TVEFURVMub3BlblxuICAgICAgICAgIHRoaXMub25vcGVuKHt9KVxuICAgICAgICAgIHRoaXMucG9sbCgpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0MDM6XG4gICAgICAgICAgdGhpcy5vbmVycm9yKDQwMylcbiAgICAgICAgICB0aGlzLmNsb3NlKDEwMDgsIFwiZm9yYmlkZGVuXCIsIGZhbHNlKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSA1MDA6XG4gICAgICAgICAgdGhpcy5vbmVycm9yKDUwMClcbiAgICAgICAgICB0aGlzLmNsb3NlQW5kUmV0cnkoMTAxMSwgXCJpbnRlcm5hbCBzZXJ2ZXIgZXJyb3JcIiwgNTAwKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIHBvbGwgc3RhdHVzICR7c3RhdHVzfWApXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8vIHdlIGNvbGxlY3QgYWxsIHB1c2hlcyB3aXRoaW4gdGhlIGN1cnJlbnQgZXZlbnQgbG9vcCBieVxuICAvLyBzZXRUaW1lb3V0IDAsIHdoaWNoIG9wdGltaXplcyBiYWNrLXRvLWJhY2sgcHJvY2VkdXJhbFxuICAvLyBwdXNoZXMgYWdhaW5zdCBhbiBlbXB0eSBidWZmZXJcblxuICBzZW5kKGJvZHkpe1xuICAgIGlmKHR5cGVvZihib2R5KSAhPT0gXCJzdHJpbmdcIil7IGJvZHkgPSBhcnJheUJ1ZmZlclRvQmFzZTY0KGJvZHkpIH1cbiAgICBpZih0aGlzLmN1cnJlbnRCYXRjaCl7XG4gICAgICB0aGlzLmN1cnJlbnRCYXRjaC5wdXNoKGJvZHkpXG4gICAgfSBlbHNlIGlmKHRoaXMuYXdhaXRpbmdCYXRjaEFjayl7XG4gICAgICB0aGlzLmJhdGNoQnVmZmVyLnB1c2goYm9keSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdXJyZW50QmF0Y2ggPSBbYm9keV1cbiAgICAgIHRoaXMuY3VycmVudEJhdGNoVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5iYXRjaFNlbmQodGhpcy5jdXJyZW50QmF0Y2gpXG4gICAgICAgIHRoaXMuY3VycmVudEJhdGNoID0gbnVsbFxuICAgICAgfSwgMClcbiAgICB9XG4gIH1cblxuICBiYXRjaFNlbmQobWVzc2FnZXMpe1xuICAgIHRoaXMuYXdhaXRpbmdCYXRjaEFjayA9IHRydWVcbiAgICB0aGlzLmFqYXgoXCJQT1NUXCIsIHtcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL3gtbmRqc29uXCJ9LCBtZXNzYWdlcy5qb2luKFwiXFxuXCIpLCAoKSA9PiB0aGlzLm9uZXJyb3IoXCJ0aW1lb3V0XCIpLCByZXNwID0+IHtcbiAgICAgIHRoaXMuYXdhaXRpbmdCYXRjaEFjayA9IGZhbHNlXG4gICAgICBpZighcmVzcCB8fCByZXNwLnN0YXR1cyAhPT0gMjAwKXtcbiAgICAgICAgdGhpcy5vbmVycm9yKHJlc3AgJiYgcmVzcC5zdGF0dXMpXG4gICAgICAgIHRoaXMuY2xvc2VBbmRSZXRyeSgxMDExLCBcImludGVybmFsIHNlcnZlciBlcnJvclwiLCBmYWxzZSlcbiAgICAgIH0gZWxzZSBpZih0aGlzLmJhdGNoQnVmZmVyLmxlbmd0aCA+IDApe1xuICAgICAgICB0aGlzLmJhdGNoU2VuZCh0aGlzLmJhdGNoQnVmZmVyKVxuICAgICAgICB0aGlzLmJhdGNoQnVmZmVyID0gW11cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgY2xvc2UoY29kZSwgcmVhc29uLCB3YXNDbGVhbil7XG4gICAgZm9yKGxldCByZXEgb2YgdGhpcy5yZXFzKXsgcmVxLmFib3J0KCkgfVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNPQ0tFVF9TVEFURVMuY2xvc2VkXG4gICAgbGV0IG9wdHMgPSBPYmplY3QuYXNzaWduKHtjb2RlOiAxMDAwLCByZWFzb246IHVuZGVmaW5lZCwgd2FzQ2xlYW46IHRydWV9LCB7Y29kZSwgcmVhc29uLCB3YXNDbGVhbn0pXG4gICAgdGhpcy5iYXRjaEJ1ZmZlciA9IFtdXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuY3VycmVudEJhdGNoVGltZXIpXG4gICAgdGhpcy5jdXJyZW50QmF0Y2hUaW1lciA9IG51bGxcbiAgICBpZih0eXBlb2YoQ2xvc2VFdmVudCkgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgdGhpcy5vbmNsb3NlKG5ldyBDbG9zZUV2ZW50KFwiY2xvc2VcIiwgb3B0cykpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub25jbG9zZShvcHRzKVxuICAgIH1cbiAgfVxuXG4gIGFqYXgobWV0aG9kLCBoZWFkZXJzLCBib2R5LCBvbkNhbGxlclRpbWVvdXQsIGNhbGxiYWNrKXtcbiAgICBsZXQgcmVxXG4gICAgbGV0IG9udGltZW91dCA9ICgpID0+IHtcbiAgICAgIHRoaXMucmVxcy5kZWxldGUocmVxKVxuICAgICAgb25DYWxsZXJUaW1lb3V0KClcbiAgICB9XG4gICAgcmVxID0gQWpheC5yZXF1ZXN0KG1ldGhvZCwgdGhpcy5lbmRwb2ludFVSTCgpLCBoZWFkZXJzLCBib2R5LCB0aGlzLnRpbWVvdXQsIG9udGltZW91dCwgcmVzcCA9PiB7XG4gICAgICB0aGlzLnJlcXMuZGVsZXRlKHJlcSlcbiAgICAgIGlmKHRoaXMuaXNBY3RpdmUoKSl7IGNhbGxiYWNrKHJlc3ApIH1cbiAgICB9KVxuICAgIHRoaXMucmVxcy5hZGQocmVxKVxuICB9XG59XG4iLCAiLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgUHJlc2VuY2VcbiAqIEBwYXJhbSB7Q2hhbm5lbH0gY2hhbm5lbCAtIFRoZSBDaGFubmVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBvcHRpb25zLFxuICogICAgICAgIGZvciBleGFtcGxlIGB7ZXZlbnRzOiB7c3RhdGU6IFwic3RhdGVcIiwgZGlmZjogXCJkaWZmXCJ9fWBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJlc2VuY2Uge1xuXG4gIGNvbnN0cnVjdG9yKGNoYW5uZWwsIG9wdHMgPSB7fSl7XG4gICAgbGV0IGV2ZW50cyA9IG9wdHMuZXZlbnRzIHx8IHtzdGF0ZTogXCJwcmVzZW5jZV9zdGF0ZVwiLCBkaWZmOiBcInByZXNlbmNlX2RpZmZcIn1cbiAgICB0aGlzLnN0YXRlID0ge31cbiAgICB0aGlzLnBlbmRpbmdEaWZmcyA9IFtdXG4gICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbFxuICAgIHRoaXMuam9pblJlZiA9IG51bGxcbiAgICB0aGlzLmNhbGxlciA9IHtcbiAgICAgIG9uSm9pbjogZnVuY3Rpb24gKCl7IH0sXG4gICAgICBvbkxlYXZlOiBmdW5jdGlvbiAoKXsgfSxcbiAgICAgIG9uU3luYzogZnVuY3Rpb24gKCl7IH1cbiAgICB9XG5cbiAgICB0aGlzLmNoYW5uZWwub24oZXZlbnRzLnN0YXRlLCBuZXdTdGF0ZSA9PiB7XG4gICAgICBsZXQge29uSm9pbiwgb25MZWF2ZSwgb25TeW5jfSA9IHRoaXMuY2FsbGVyXG5cbiAgICAgIHRoaXMuam9pblJlZiA9IHRoaXMuY2hhbm5lbC5qb2luUmVmKClcbiAgICAgIHRoaXMuc3RhdGUgPSBQcmVzZW5jZS5zeW5jU3RhdGUodGhpcy5zdGF0ZSwgbmV3U3RhdGUsIG9uSm9pbiwgb25MZWF2ZSlcblxuICAgICAgdGhpcy5wZW5kaW5nRGlmZnMuZm9yRWFjaChkaWZmID0+IHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFByZXNlbmNlLnN5bmNEaWZmKHRoaXMuc3RhdGUsIGRpZmYsIG9uSm9pbiwgb25MZWF2ZSlcbiAgICAgIH0pXG4gICAgICB0aGlzLnBlbmRpbmdEaWZmcyA9IFtdXG4gICAgICBvblN5bmMoKVxuICAgIH0pXG5cbiAgICB0aGlzLmNoYW5uZWwub24oZXZlbnRzLmRpZmYsIGRpZmYgPT4ge1xuICAgICAgbGV0IHtvbkpvaW4sIG9uTGVhdmUsIG9uU3luY30gPSB0aGlzLmNhbGxlclxuXG4gICAgICBpZih0aGlzLmluUGVuZGluZ1N5bmNTdGF0ZSgpKXtcbiAgICAgICAgdGhpcy5wZW5kaW5nRGlmZnMucHVzaChkaWZmKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFByZXNlbmNlLnN5bmNEaWZmKHRoaXMuc3RhdGUsIGRpZmYsIG9uSm9pbiwgb25MZWF2ZSlcbiAgICAgICAgb25TeW5jKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgb25Kb2luKGNhbGxiYWNrKXsgdGhpcy5jYWxsZXIub25Kb2luID0gY2FsbGJhY2sgfVxuXG4gIG9uTGVhdmUoY2FsbGJhY2speyB0aGlzLmNhbGxlci5vbkxlYXZlID0gY2FsbGJhY2sgfVxuXG4gIG9uU3luYyhjYWxsYmFjayl7IHRoaXMuY2FsbGVyLm9uU3luYyA9IGNhbGxiYWNrIH1cblxuICBsaXN0KGJ5KXsgcmV0dXJuIFByZXNlbmNlLmxpc3QodGhpcy5zdGF0ZSwgYnkpIH1cblxuICBpblBlbmRpbmdTeW5jU3RhdGUoKXtcbiAgICByZXR1cm4gIXRoaXMuam9pblJlZiB8fCAodGhpcy5qb2luUmVmICE9PSB0aGlzLmNoYW5uZWwuam9pblJlZigpKVxuICB9XG5cbiAgLy8gbG93ZXItbGV2ZWwgcHVibGljIHN0YXRpYyBBUElcblxuICAvKipcbiAgICogVXNlZCB0byBzeW5jIHRoZSBsaXN0IG9mIHByZXNlbmNlcyBvbiB0aGUgc2VydmVyXG4gICAqIHdpdGggdGhlIGNsaWVudCdzIHN0YXRlLiBBbiBvcHRpb25hbCBgb25Kb2luYCBhbmQgYG9uTGVhdmVgIGNhbGxiYWNrIGNhblxuICAgKiBiZSBwcm92aWRlZCB0byByZWFjdCB0byBjaGFuZ2VzIGluIHRoZSBjbGllbnQncyBsb2NhbCBwcmVzZW5jZXMgYWNyb3NzXG4gICAqIGRpc2Nvbm5lY3RzIGFuZCByZWNvbm5lY3RzIHdpdGggdGhlIHNlcnZlci5cbiAgICpcbiAgICogQHJldHVybnMge1ByZXNlbmNlfVxuICAgKi9cbiAgc3RhdGljIHN5bmNTdGF0ZShjdXJyZW50U3RhdGUsIG5ld1N0YXRlLCBvbkpvaW4sIG9uTGVhdmUpe1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuY2xvbmUoY3VycmVudFN0YXRlKVxuICAgIGxldCBqb2lucyA9IHt9XG4gICAgbGV0IGxlYXZlcyA9IHt9XG5cbiAgICB0aGlzLm1hcChzdGF0ZSwgKGtleSwgcHJlc2VuY2UpID0+IHtcbiAgICAgIGlmKCFuZXdTdGF0ZVtrZXldKXtcbiAgICAgICAgbGVhdmVzW2tleV0gPSBwcmVzZW5jZVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5tYXAobmV3U3RhdGUsIChrZXksIG5ld1ByZXNlbmNlKSA9PiB7XG4gICAgICBsZXQgY3VycmVudFByZXNlbmNlID0gc3RhdGVba2V5XVxuICAgICAgaWYoY3VycmVudFByZXNlbmNlKXtcbiAgICAgICAgbGV0IG5ld1JlZnMgPSBuZXdQcmVzZW5jZS5tZXRhcy5tYXAobSA9PiBtLnBoeF9yZWYpXG4gICAgICAgIGxldCBjdXJSZWZzID0gY3VycmVudFByZXNlbmNlLm1ldGFzLm1hcChtID0+IG0ucGh4X3JlZilcbiAgICAgICAgbGV0IGpvaW5lZE1ldGFzID0gbmV3UHJlc2VuY2UubWV0YXMuZmlsdGVyKG0gPT4gY3VyUmVmcy5pbmRleE9mKG0ucGh4X3JlZikgPCAwKVxuICAgICAgICBsZXQgbGVmdE1ldGFzID0gY3VycmVudFByZXNlbmNlLm1ldGFzLmZpbHRlcihtID0+IG5ld1JlZnMuaW5kZXhPZihtLnBoeF9yZWYpIDwgMClcbiAgICAgICAgaWYoam9pbmVkTWV0YXMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgam9pbnNba2V5XSA9IG5ld1ByZXNlbmNlXG4gICAgICAgICAgam9pbnNba2V5XS5tZXRhcyA9IGpvaW5lZE1ldGFzXG4gICAgICAgIH1cbiAgICAgICAgaWYobGVmdE1ldGFzLmxlbmd0aCA+IDApe1xuICAgICAgICAgIGxlYXZlc1trZXldID0gdGhpcy5jbG9uZShjdXJyZW50UHJlc2VuY2UpXG4gICAgICAgICAgbGVhdmVzW2tleV0ubWV0YXMgPSBsZWZ0TWV0YXNcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgam9pbnNba2V5XSA9IG5ld1ByZXNlbmNlXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gdGhpcy5zeW5jRGlmZihzdGF0ZSwge2pvaW5zOiBqb2lucywgbGVhdmVzOiBsZWF2ZXN9LCBvbkpvaW4sIG9uTGVhdmUpXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogVXNlZCB0byBzeW5jIGEgZGlmZiBvZiBwcmVzZW5jZSBqb2luIGFuZCBsZWF2ZVxuICAgKiBldmVudHMgZnJvbSB0aGUgc2VydmVyLCBhcyB0aGV5IGhhcHBlbi4gTGlrZSBgc3luY1N0YXRlYCwgYHN5bmNEaWZmYFxuICAgKiBhY2NlcHRzIG9wdGlvbmFsIGBvbkpvaW5gIGFuZCBgb25MZWF2ZWAgY2FsbGJhY2tzIHRvIHJlYWN0IHRvIGEgdXNlclxuICAgKiBqb2luaW5nIG9yIGxlYXZpbmcgZnJvbSBhIGRldmljZS5cbiAgICpcbiAgICogQHJldHVybnMge1ByZXNlbmNlfVxuICAgKi9cbiAgc3RhdGljIHN5bmNEaWZmKHN0YXRlLCBkaWZmLCBvbkpvaW4sIG9uTGVhdmUpe1xuICAgIGxldCB7am9pbnMsIGxlYXZlc30gPSB0aGlzLmNsb25lKGRpZmYpXG4gICAgaWYoIW9uSm9pbil7IG9uSm9pbiA9IGZ1bmN0aW9uICgpeyB9IH1cbiAgICBpZighb25MZWF2ZSl7IG9uTGVhdmUgPSBmdW5jdGlvbiAoKXsgfSB9XG5cbiAgICB0aGlzLm1hcChqb2lucywgKGtleSwgbmV3UHJlc2VuY2UpID0+IHtcbiAgICAgIGxldCBjdXJyZW50UHJlc2VuY2UgPSBzdGF0ZVtrZXldXG4gICAgICBzdGF0ZVtrZXldID0gdGhpcy5jbG9uZShuZXdQcmVzZW5jZSlcbiAgICAgIGlmKGN1cnJlbnRQcmVzZW5jZSl7XG4gICAgICAgIGxldCBqb2luZWRSZWZzID0gc3RhdGVba2V5XS5tZXRhcy5tYXAobSA9PiBtLnBoeF9yZWYpXG4gICAgICAgIGxldCBjdXJNZXRhcyA9IGN1cnJlbnRQcmVzZW5jZS5tZXRhcy5maWx0ZXIobSA9PiBqb2luZWRSZWZzLmluZGV4T2YobS5waHhfcmVmKSA8IDApXG4gICAgICAgIHN0YXRlW2tleV0ubWV0YXMudW5zaGlmdCguLi5jdXJNZXRhcylcbiAgICAgIH1cbiAgICAgIG9uSm9pbihrZXksIGN1cnJlbnRQcmVzZW5jZSwgbmV3UHJlc2VuY2UpXG4gICAgfSlcbiAgICB0aGlzLm1hcChsZWF2ZXMsIChrZXksIGxlZnRQcmVzZW5jZSkgPT4ge1xuICAgICAgbGV0IGN1cnJlbnRQcmVzZW5jZSA9IHN0YXRlW2tleV1cbiAgICAgIGlmKCFjdXJyZW50UHJlc2VuY2UpeyByZXR1cm4gfVxuICAgICAgbGV0IHJlZnNUb1JlbW92ZSA9IGxlZnRQcmVzZW5jZS5tZXRhcy5tYXAobSA9PiBtLnBoeF9yZWYpXG4gICAgICBjdXJyZW50UHJlc2VuY2UubWV0YXMgPSBjdXJyZW50UHJlc2VuY2UubWV0YXMuZmlsdGVyKHAgPT4ge1xuICAgICAgICByZXR1cm4gcmVmc1RvUmVtb3ZlLmluZGV4T2YocC5waHhfcmVmKSA8IDBcbiAgICAgIH0pXG4gICAgICBvbkxlYXZlKGtleSwgY3VycmVudFByZXNlbmNlLCBsZWZ0UHJlc2VuY2UpXG4gICAgICBpZihjdXJyZW50UHJlc2VuY2UubWV0YXMubGVuZ3RoID09PSAwKXtcbiAgICAgICAgZGVsZXRlIHN0YXRlW2tleV1cbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBzdGF0ZVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFycmF5IG9mIHByZXNlbmNlcywgd2l0aCBzZWxlY3RlZCBtZXRhZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHByZXNlbmNlc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjaG9vc2VyXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcmVzZW5jZX1cbiAgICovXG4gIHN0YXRpYyBsaXN0KHByZXNlbmNlcywgY2hvb3Nlcil7XG4gICAgaWYoIWNob29zZXIpeyBjaG9vc2VyID0gZnVuY3Rpb24gKGtleSwgcHJlcyl7IHJldHVybiBwcmVzIH0gfVxuXG4gICAgcmV0dXJuIHRoaXMubWFwKHByZXNlbmNlcywgKGtleSwgcHJlc2VuY2UpID0+IHtcbiAgICAgIHJldHVybiBjaG9vc2VyKGtleSwgcHJlc2VuY2UpXG4gICAgfSlcbiAgfVxuXG4gIC8vIHByaXZhdGVcblxuICBzdGF0aWMgbWFwKG9iaiwgZnVuYyl7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubWFwKGtleSA9PiBmdW5jKGtleSwgb2JqW2tleV0pKVxuICB9XG5cbiAgc3RhdGljIGNsb25lKG9iail7IHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpIH1cbn1cbiIsICIvKiBUaGUgZGVmYXVsdCBzZXJpYWxpemVyIGZvciBlbmNvZGluZyBhbmQgZGVjb2RpbmcgbWVzc2FnZXMgKi9cbmltcG9ydCB7XG4gIENIQU5ORUxfRVZFTlRTXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgSEVBREVSX0xFTkdUSDogMSxcbiAgTUVUQV9MRU5HVEg6IDQsXG4gIEtJTkRTOiB7cHVzaDogMCwgcmVwbHk6IDEsIGJyb2FkY2FzdDogMn0sXG5cbiAgZW5jb2RlKG1zZywgY2FsbGJhY2spe1xuICAgIGlmKG1zZy5wYXlsb2FkLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcil7XG4gICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5iaW5hcnlFbmNvZGUobXNnKSlcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHBheWxvYWQgPSBbbXNnLmpvaW5fcmVmLCBtc2cucmVmLCBtc2cudG9waWMsIG1zZy5ldmVudCwgbXNnLnBheWxvYWRdXG4gICAgICByZXR1cm4gY2FsbGJhY2soSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpXG4gICAgfVxuICB9LFxuXG4gIGRlY29kZShyYXdQYXlsb2FkLCBjYWxsYmFjayl7XG4gICAgaWYocmF3UGF5bG9hZC5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpe1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuYmluYXJ5RGVjb2RlKHJhd1BheWxvYWQpKVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgW2pvaW5fcmVmLCByZWYsIHRvcGljLCBldmVudCwgcGF5bG9hZF0gPSBKU09OLnBhcnNlKHJhd1BheWxvYWQpXG4gICAgICByZXR1cm4gY2FsbGJhY2soe2pvaW5fcmVmLCByZWYsIHRvcGljLCBldmVudCwgcGF5bG9hZH0pXG4gICAgfVxuICB9LFxuXG4gIC8vIHByaXZhdGVcblxuICBiaW5hcnlFbmNvZGUobWVzc2FnZSl7XG4gICAgbGV0IHtqb2luX3JlZiwgcmVmLCBldmVudCwgdG9waWMsIHBheWxvYWR9ID0gbWVzc2FnZVxuICAgIGxldCBtZXRhTGVuZ3RoID0gdGhpcy5NRVRBX0xFTkdUSCArIGpvaW5fcmVmLmxlbmd0aCArIHJlZi5sZW5ndGggKyB0b3BpYy5sZW5ndGggKyBldmVudC5sZW5ndGhcbiAgICBsZXQgaGVhZGVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuSEVBREVSX0xFTkdUSCArIG1ldGFMZW5ndGgpXG4gICAgbGV0IHZpZXcgPSBuZXcgRGF0YVZpZXcoaGVhZGVyKVxuICAgIGxldCBvZmZzZXQgPSAwXG5cbiAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCB0aGlzLktJTkRTLnB1c2gpIC8vIGtpbmRcbiAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBqb2luX3JlZi5sZW5ndGgpXG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgcmVmLmxlbmd0aClcbiAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCB0b3BpYy5sZW5ndGgpXG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgZXZlbnQubGVuZ3RoKVxuICAgIEFycmF5LmZyb20oam9pbl9yZWYsIGNoYXIgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSlcbiAgICBBcnJheS5mcm9tKHJlZiwgY2hhciA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKVxuICAgIEFycmF5LmZyb20odG9waWMsIGNoYXIgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSlcbiAgICBBcnJheS5mcm9tKGV2ZW50LCBjaGFyID0+IHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNoYXIuY2hhckNvZGVBdCgwKSkpXG5cbiAgICB2YXIgY29tYmluZWQgPSBuZXcgVWludDhBcnJheShoZWFkZXIuYnl0ZUxlbmd0aCArIHBheWxvYWQuYnl0ZUxlbmd0aClcbiAgICBjb21iaW5lZC5zZXQobmV3IFVpbnQ4QXJyYXkoaGVhZGVyKSwgMClcbiAgICBjb21iaW5lZC5zZXQobmV3IFVpbnQ4QXJyYXkocGF5bG9hZCksIGhlYWRlci5ieXRlTGVuZ3RoKVxuXG4gICAgcmV0dXJuIGNvbWJpbmVkLmJ1ZmZlclxuICB9LFxuXG4gIGJpbmFyeURlY29kZShidWZmZXIpe1xuICAgIGxldCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcilcbiAgICBsZXQga2luZCA9IHZpZXcuZ2V0VWludDgoMClcbiAgICBsZXQgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpXG4gICAgc3dpdGNoKGtpbmQpe1xuICAgICAgY2FzZSB0aGlzLktJTkRTLnB1c2g6IHJldHVybiB0aGlzLmRlY29kZVB1c2goYnVmZmVyLCB2aWV3LCBkZWNvZGVyKVxuICAgICAgY2FzZSB0aGlzLktJTkRTLnJlcGx5OiByZXR1cm4gdGhpcy5kZWNvZGVSZXBseShidWZmZXIsIHZpZXcsIGRlY29kZXIpXG4gICAgICBjYXNlIHRoaXMuS0lORFMuYnJvYWRjYXN0OiByZXR1cm4gdGhpcy5kZWNvZGVCcm9hZGNhc3QoYnVmZmVyLCB2aWV3LCBkZWNvZGVyKVxuICAgIH1cbiAgfSxcblxuICBkZWNvZGVQdXNoKGJ1ZmZlciwgdmlldywgZGVjb2Rlcil7XG4gICAgbGV0IGpvaW5SZWZTaXplID0gdmlldy5nZXRVaW50OCgxKVxuICAgIGxldCB0b3BpY1NpemUgPSB2aWV3LmdldFVpbnQ4KDIpXG4gICAgbGV0IGV2ZW50U2l6ZSA9IHZpZXcuZ2V0VWludDgoMylcbiAgICBsZXQgb2Zmc2V0ID0gdGhpcy5IRUFERVJfTEVOR1RIICsgdGhpcy5NRVRBX0xFTkdUSCAtIDEgLy8gcHVzaGVzIGhhdmUgbm8gcmVmXG4gICAgbGV0IGpvaW5SZWYgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBqb2luUmVmU2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgam9pblJlZlNpemVcbiAgICBsZXQgdG9waWMgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0b3BpY1NpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIHRvcGljU2l6ZVxuICAgIGxldCBldmVudCA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGV2ZW50U2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgZXZlbnRTaXplXG4gICAgbGV0IGRhdGEgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aClcbiAgICByZXR1cm4ge2pvaW5fcmVmOiBqb2luUmVmLCByZWY6IG51bGwsIHRvcGljOiB0b3BpYywgZXZlbnQ6IGV2ZW50LCBwYXlsb2FkOiBkYXRhfVxuICB9LFxuXG4gIGRlY29kZVJlcGx5KGJ1ZmZlciwgdmlldywgZGVjb2Rlcil7XG4gICAgbGV0IGpvaW5SZWZTaXplID0gdmlldy5nZXRVaW50OCgxKVxuICAgIGxldCByZWZTaXplID0gdmlldy5nZXRVaW50OCgyKVxuICAgIGxldCB0b3BpY1NpemUgPSB2aWV3LmdldFVpbnQ4KDMpXG4gICAgbGV0IGV2ZW50U2l6ZSA9IHZpZXcuZ2V0VWludDgoNClcbiAgICBsZXQgb2Zmc2V0ID0gdGhpcy5IRUFERVJfTEVOR1RIICsgdGhpcy5NRVRBX0xFTkdUSFxuICAgIGxldCBqb2luUmVmID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgam9pblJlZlNpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIGpvaW5SZWZTaXplXG4gICAgbGV0IHJlZiA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHJlZlNpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIHJlZlNpemVcbiAgICBsZXQgdG9waWMgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0b3BpY1NpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIHRvcGljU2l6ZVxuICAgIGxldCBldmVudCA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGV2ZW50U2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgZXZlbnRTaXplXG4gICAgbGV0IGRhdGEgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aClcbiAgICBsZXQgcGF5bG9hZCA9IHtzdGF0dXM6IGV2ZW50LCByZXNwb25zZTogZGF0YX1cbiAgICByZXR1cm4ge2pvaW5fcmVmOiBqb2luUmVmLCByZWY6IHJlZiwgdG9waWM6IHRvcGljLCBldmVudDogQ0hBTk5FTF9FVkVOVFMucmVwbHksIHBheWxvYWQ6IHBheWxvYWR9XG4gIH0sXG5cbiAgZGVjb2RlQnJvYWRjYXN0KGJ1ZmZlciwgdmlldywgZGVjb2Rlcil7XG4gICAgbGV0IHRvcGljU2l6ZSA9IHZpZXcuZ2V0VWludDgoMSlcbiAgICBsZXQgZXZlbnRTaXplID0gdmlldy5nZXRVaW50OCgyKVxuICAgIGxldCBvZmZzZXQgPSB0aGlzLkhFQURFUl9MRU5HVEggKyAyXG4gICAgbGV0IHRvcGljID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdG9waWNTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyB0b3BpY1NpemVcbiAgICBsZXQgZXZlbnQgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBldmVudFNpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIGV2ZW50U2l6ZVxuICAgIGxldCBkYXRhID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgYnVmZmVyLmJ5dGVMZW5ndGgpXG5cbiAgICByZXR1cm4ge2pvaW5fcmVmOiBudWxsLCByZWY6IG51bGwsIHRvcGljOiB0b3BpYywgZXZlbnQ6IGV2ZW50LCBwYXlsb2FkOiBkYXRhfVxuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgZ2xvYmFsLFxuICBwaHhXaW5kb3csXG4gIENIQU5ORUxfRVZFTlRTLFxuICBERUZBVUxUX1RJTUVPVVQsXG4gIERFRkFVTFRfVlNOLFxuICBTT0NLRVRfU1RBVEVTLFxuICBUUkFOU1BPUlRTLFxuICBXU19DTE9TRV9OT1JNQUwsXG4gIEFVVEhfVE9LRU5fUFJFRklYXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG4gIGNsb3N1cmVcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5pbXBvcnQgQWpheCBmcm9tIFwiLi9hamF4XCJcbmltcG9ydCBDaGFubmVsIGZyb20gXCIuL2NoYW5uZWxcIlxuaW1wb3J0IExvbmdQb2xsIGZyb20gXCIuL2xvbmdwb2xsXCJcbmltcG9ydCBTZXJpYWxpemVyIGZyb20gXCIuL3NlcmlhbGl6ZXJcIlxuaW1wb3J0IFRpbWVyIGZyb20gXCIuL3RpbWVyXCJcblxuLyoqIEluaXRpYWxpemVzIHRoZSBTb2NrZXQgKlxuICpcbiAqIEZvciBJRTggc3VwcG9ydCB1c2UgYW4gRVM1LXNoaW0gKGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbSlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5kUG9pbnQgLSBUaGUgc3RyaW5nIFdlYlNvY2tldCBlbmRwb2ludCwgaWUsIGBcIndzOi8vZXhhbXBsZS5jb20vc29ja2V0XCJgLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcIndzczovL2V4YW1wbGUuY29tXCJgXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFwiL3NvY2tldFwiYCAoaW5oZXJpdGVkIGhvc3QgJiBwcm90b2NvbClcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBPcHRpb25hbCBjb25maWd1cmF0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy50cmFuc3BvcnRdIC0gVGhlIFdlYnNvY2tldCBUcmFuc3BvcnQsIGZvciBleGFtcGxlIFdlYlNvY2tldCBvciBQaG9lbml4LkxvbmdQb2xsLlxuICpcbiAqIERlZmF1bHRzIHRvIFdlYlNvY2tldCB3aXRoIGF1dG9tYXRpYyBMb25nUG9sbCBmYWxsYmFjayBpZiBXZWJTb2NrZXQgaXMgbm90IGRlZmluZWQuXG4gKiBUbyBmYWxsYmFjayB0byBMb25nUG9sbCB3aGVuIFdlYlNvY2tldCBhdHRlbXB0cyBmYWlsLCB1c2UgYGxvbmdQb2xsRmFsbGJhY2tNczogMjUwMGAuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmxvbmdQb2xsRmFsbGJhY2tNc10gLSBUaGUgbWlsbGlzZWNvbmQgdGltZSB0byBhdHRlbXB0IHRoZSBwcmltYXJ5IHRyYW5zcG9ydFxuICogYmVmb3JlIGZhbGxpbmcgYmFjayB0byB0aGUgTG9uZ1BvbGwgdHJhbnNwb3J0LiBEaXNhYmxlZCBieSBkZWZhdWx0LlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZGVidWddIC0gV2hlbiB0cnVlLCBlbmFibGVzIGRlYnVnIGxvZ2dpbmcuIERlZmF1bHQgZmFsc2UuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMuZW5jb2RlXSAtIFRoZSBmdW5jdGlvbiB0byBlbmNvZGUgb3V0Z29pbmcgbWVzc2FnZXMuXG4gKlxuICogRGVmYXVsdHMgdG8gSlNPTiBlbmNvZGVyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLmRlY29kZV0gLSBUaGUgZnVuY3Rpb24gdG8gZGVjb2RlIGluY29taW5nIG1lc3NhZ2VzLlxuICpcbiAqIERlZmF1bHRzIHRvIEpTT046XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogKHBheWxvYWQsIGNhbGxiYWNrKSA9PiBjYWxsYmFjayhKU09OLnBhcnNlKHBheWxvYWQpKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnRpbWVvdXRdIC0gVGhlIGRlZmF1bHQgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gdHJpZ2dlciBwdXNoIHRpbWVvdXRzLlxuICpcbiAqIERlZmF1bHRzIGBERUZBVUxUX1RJTUVPVVRgXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMuaGVhcnRiZWF0SW50ZXJ2YWxNc10gLSBUaGUgbWlsbGlzZWMgaW50ZXJ2YWwgdG8gc2VuZCBhIGhlYXJ0YmVhdCBtZXNzYWdlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy5yZWNvbm5lY3RBZnRlck1zXSAtIFRoZSBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gKiBzb2NrZXQgcmVjb25uZWN0IGludGVydmFsLCBpbiBtaWxsaXNlY29uZHMuXG4gKlxuICogRGVmYXVsdHMgdG8gc3RlcHBlZCBiYWNrb2ZmIG9mOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGZ1bmN0aW9uKHRyaWVzKXtcbiAqICAgcmV0dXJuIFsxMCwgNTAsIDEwMCwgMTUwLCAyMDAsIDI1MCwgNTAwLCAxMDAwLCAyMDAwXVt0cmllcyAtIDFdIHx8IDUwMDBcbiAqIH1cbiAqIGBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy5yZWpvaW5BZnRlck1zXSAtIFRoZSBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG1pbGxpc2VjXG4gKiByZWpvaW4gaW50ZXJ2YWwgZm9yIGluZGl2aWR1YWwgY2hhbm5lbHMuXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogZnVuY3Rpb24odHJpZXMpe1xuICogICByZXR1cm4gWzEwMDAsIDIwMDAsIDUwMDBdW3RyaWVzIC0gMV0gfHwgMTAwMDBcbiAqIH1cbiAqIGBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy5sb2dnZXJdIC0gVGhlIG9wdGlvbmFsIGZ1bmN0aW9uIGZvciBzcGVjaWFsaXplZCBsb2dnaW5nLCBpZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBmdW5jdGlvbihraW5kLCBtc2csIGRhdGEpIHtcbiAqICAgY29uc29sZS5sb2coYCR7a2luZH06ICR7bXNnfWAsIGRhdGEpXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMubG9uZ3BvbGxlclRpbWVvdXRdIC0gVGhlIG1heGltdW0gdGltZW91dCBvZiBhIGxvbmcgcG9sbCBBSkFYIHJlcXVlc3QuXG4gKlxuICogRGVmYXVsdHMgdG8gMjBzIChkb3VibGUgdGhlIHNlcnZlciBsb25nIHBvbGwgdGltZXIpLlxuICpcbiAqIEBwYXJhbSB7KE9iamVjdHxmdW5jdGlvbil9IFtvcHRzLnBhcmFtc10gLSBUaGUgb3B0aW9uYWwgcGFyYW1zIHRvIHBhc3Mgd2hlbiBjb25uZWN0aW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYXV0aFRva2VuXSAtIHRoZSBvcHRpb25hbCBhdXRoZW50aWNhdGlvbiB0b2tlbiB0byBiZSBleHBvc2VkIG9uIHRoZSBzZXJ2ZXJcbiAqIHVuZGVyIHRoZSBgOmF1dGhfdG9rZW5gIGNvbm5lY3RfaW5mbyBrZXkuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmluYXJ5VHlwZV0gLSBUaGUgYmluYXJ5IHR5cGUgdG8gdXNlIGZvciBiaW5hcnkgV2ViU29ja2V0IGZyYW1lcy5cbiAqXG4gKiBEZWZhdWx0cyB0byBcImFycmF5YnVmZmVyXCJcbiAqXG4gKiBAcGFyYW0ge3Zzbn0gW29wdHMudnNuXSAtIFRoZSBzZXJpYWxpemVyJ3MgcHJvdG9jb2wgdmVyc2lvbiB0byBzZW5kIG9uIGNvbm5lY3QuXG4gKlxuICogRGVmYXVsdHMgdG8gREVGQVVMVF9WU04uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLnNlc3Npb25TdG9yYWdlXSAtIEFuIG9wdGlvbmFsIFN0b3JhZ2UgY29tcGF0aWJsZSBvYmplY3RcbiAqIFBob2VuaXggdXNlcyBzZXNzaW9uU3RvcmFnZSBmb3IgbG9uZ3BvbGwgZmFsbGJhY2sgaGlzdG9yeS4gT3ZlcnJpZGluZyB0aGUgc3RvcmUgaXNcbiAqIHVzZWZ1bCB3aGVuIFBob2VuaXggd29uJ3QgaGF2ZSBhY2Nlc3MgdG8gYHNlc3Npb25TdG9yYWdlYC4gRm9yIGV4YW1wbGUsIFRoaXMgY291bGRcbiAqIGhhcHBlbiBpZiBhIHNpdGUgbG9hZHMgYSBjcm9zcy1kb21haW4gY2hhbm5lbCBpbiBhbiBpZnJhbWUuIEV4YW1wbGUgdXNhZ2U6XG4gKlxuICogICAgIGNsYXNzIEluTWVtb3J5U3RvcmFnZSB7XG4gKiAgICAgICBjb25zdHJ1Y3RvcigpIHsgdGhpcy5zdG9yYWdlID0ge30gfVxuICogICAgICAgZ2V0SXRlbShrZXlOYW1lKSB7IHJldHVybiB0aGlzLnN0b3JhZ2Vba2V5TmFtZV0gfHwgbnVsbCB9XG4gKiAgICAgICByZW1vdmVJdGVtKGtleU5hbWUpIHsgZGVsZXRlIHRoaXMuc3RvcmFnZVtrZXlOYW1lXSB9XG4gKiAgICAgICBzZXRJdGVtKGtleU5hbWUsIGtleVZhbHVlKSB7IHRoaXMuc3RvcmFnZVtrZXlOYW1lXSA9IGtleVZhbHVlIH1cbiAqICAgICB9XG4gKlxuKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNvY2tldCB7XG4gIGNvbnN0cnVjdG9yKGVuZFBvaW50LCBvcHRzID0ge30pe1xuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MgPSB7b3BlbjogW10sIGNsb3NlOiBbXSwgZXJyb3I6IFtdLCBtZXNzYWdlOiBbXX1cbiAgICB0aGlzLmNoYW5uZWxzID0gW11cbiAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXVxuICAgIHRoaXMucmVmID0gMFxuICAgIHRoaXMuZmFsbGJhY2tSZWYgPSBudWxsXG4gICAgdGhpcy50aW1lb3V0ID0gb3B0cy50aW1lb3V0IHx8IERFRkFVTFRfVElNRU9VVFxuICAgIHRoaXMudHJhbnNwb3J0ID0gb3B0cy50cmFuc3BvcnQgfHwgZ2xvYmFsLldlYlNvY2tldCB8fCBMb25nUG9sbFxuICAgIHRoaXMucHJpbWFyeVBhc3NlZEhlYWx0aENoZWNrID0gZmFsc2VcbiAgICB0aGlzLmxvbmdQb2xsRmFsbGJhY2tNcyA9IG9wdHMubG9uZ1BvbGxGYWxsYmFja01zXG4gICAgdGhpcy5mYWxsYmFja1RpbWVyID0gbnVsbFxuICAgIHRoaXMuc2Vzc2lvblN0b3JlID0gb3B0cy5zZXNzaW9uU3RvcmFnZSB8fCAoZ2xvYmFsICYmIGdsb2JhbC5zZXNzaW9uU3RvcmFnZSlcbiAgICB0aGlzLmVzdGFibGlzaGVkQ29ubmVjdGlvbnMgPSAwXG4gICAgdGhpcy5kZWZhdWx0RW5jb2RlciA9IFNlcmlhbGl6ZXIuZW5jb2RlLmJpbmQoU2VyaWFsaXplcilcbiAgICB0aGlzLmRlZmF1bHREZWNvZGVyID0gU2VyaWFsaXplci5kZWNvZGUuYmluZChTZXJpYWxpemVyKVxuICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IGZhbHNlXG4gICAgdGhpcy5kaXNjb25uZWN0aW5nID0gZmFsc2VcbiAgICB0aGlzLmJpbmFyeVR5cGUgPSBvcHRzLmJpbmFyeVR5cGUgfHwgXCJhcnJheWJ1ZmZlclwiXG4gICAgdGhpcy5jb25uZWN0Q2xvY2sgPSAxXG4gICAgdGhpcy5wYWdlSGlkZGVuID0gZmFsc2VcbiAgICBpZih0aGlzLnRyYW5zcG9ydCAhPT0gTG9uZ1BvbGwpe1xuICAgICAgdGhpcy5lbmNvZGUgPSBvcHRzLmVuY29kZSB8fCB0aGlzLmRlZmF1bHRFbmNvZGVyXG4gICAgICB0aGlzLmRlY29kZSA9IG9wdHMuZGVjb2RlIHx8IHRoaXMuZGVmYXVsdERlY29kZXJcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbmNvZGUgPSB0aGlzLmRlZmF1bHRFbmNvZGVyXG4gICAgICB0aGlzLmRlY29kZSA9IHRoaXMuZGVmYXVsdERlY29kZXJcbiAgICB9XG4gICAgbGV0IGF3YWl0aW5nQ29ubmVjdGlvbk9uUGFnZVNob3cgPSBudWxsXG4gICAgaWYocGh4V2luZG93ICYmIHBoeFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKXtcbiAgICAgIHBoeFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgX2UgPT4ge1xuICAgICAgICBpZih0aGlzLmNvbm4pe1xuICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpXG4gICAgICAgICAgYXdhaXRpbmdDb25uZWN0aW9uT25QYWdlU2hvdyA9IHRoaXMuY29ubmVjdENsb2NrXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBwaHhXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VzaG93XCIsIF9lID0+IHtcbiAgICAgICAgaWYoYXdhaXRpbmdDb25uZWN0aW9uT25QYWdlU2hvdyA9PT0gdGhpcy5jb25uZWN0Q2xvY2spe1xuICAgICAgICAgIGF3YWl0aW5nQ29ubmVjdGlvbk9uUGFnZVNob3cgPSBudWxsXG4gICAgICAgICAgdGhpcy5jb25uZWN0KClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHBoeFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICAgIGlmKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gXCJoaWRkZW5cIil7XG4gICAgICAgICAgdGhpcy5wYWdlSGlkZGVuID0gdHJ1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGFnZUhpZGRlbiA9IGZhbHNlXG4gICAgICAgICAgLy8gcmVjb25uZWN0IGltbWVkaWF0ZWx5XG4gICAgICAgICAgaWYoIXRoaXMuaXNDb25uZWN0ZWQoKSl7XG4gICAgICAgICAgICB0aGlzLnRlYXJkb3duKCgpID0+IHRoaXMuY29ubmVjdCgpKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zID0gb3B0cy5oZWFydGJlYXRJbnRlcnZhbE1zIHx8IDMwMDAwXG4gICAgdGhpcy5yZWpvaW5BZnRlck1zID0gKHRyaWVzKSA9PiB7XG4gICAgICBpZihvcHRzLnJlam9pbkFmdGVyTXMpe1xuICAgICAgICByZXR1cm4gb3B0cy5yZWpvaW5BZnRlck1zKHRyaWVzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFsxMDAwLCAyMDAwLCA1MDAwXVt0cmllcyAtIDFdIHx8IDEwMDAwXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVjb25uZWN0QWZ0ZXJNcyA9ICh0cmllcykgPT4ge1xuICAgICAgaWYob3B0cy5yZWNvbm5lY3RBZnRlck1zKXtcbiAgICAgICAgcmV0dXJuIG9wdHMucmVjb25uZWN0QWZ0ZXJNcyh0cmllcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbMTAsIDUwLCAxMDAsIDE1MCwgMjAwLCAyNTAsIDUwMCwgMTAwMCwgMjAwMF1bdHJpZXMgLSAxXSB8fCA1MDAwXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyID0gb3B0cy5sb2dnZXIgfHwgbnVsbFxuICAgIGlmKCF0aGlzLmxvZ2dlciAmJiBvcHRzLmRlYnVnKXtcbiAgICAgIHRoaXMubG9nZ2VyID0gKGtpbmQsIG1zZywgZGF0YSkgPT4geyBjb25zb2xlLmxvZyhgJHtraW5kfTogJHttc2d9YCwgZGF0YSkgfVxuICAgIH1cbiAgICB0aGlzLmxvbmdwb2xsZXJUaW1lb3V0ID0gb3B0cy5sb25ncG9sbGVyVGltZW91dCB8fCAyMDAwMFxuICAgIHRoaXMucGFyYW1zID0gY2xvc3VyZShvcHRzLnBhcmFtcyB8fCB7fSlcbiAgICB0aGlzLmVuZFBvaW50ID0gYCR7ZW5kUG9pbnR9LyR7VFJBTlNQT1JUUy53ZWJzb2NrZXR9YFxuICAgIHRoaXMudnNuID0gb3B0cy52c24gfHwgREVGQVVMVF9WU05cbiAgICB0aGlzLmhlYXJ0YmVhdFRpbWVvdXRUaW1lciA9IG51bGxcbiAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyID0gbnVsbFxuICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGxcbiAgICB0aGlzLnJlY29ubmVjdFRpbWVyID0gbmV3IFRpbWVyKCgpID0+IHtcbiAgICAgIGlmKHRoaXMucGFnZUhpZGRlbil7XG4gICAgICAgIHRoaXMubG9nKFwiTm90IHJlY29ubmVjdGluZyBhcyBwYWdlIGlzIGhpZGRlbiFcIilcbiAgICAgICAgdGhpcy50ZWFyZG93bigpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdGhpcy50ZWFyZG93bigoKSA9PiB0aGlzLmNvbm5lY3QoKSlcbiAgICB9LCB0aGlzLnJlY29ubmVjdEFmdGVyTXMpXG4gICAgdGhpcy5hdXRoVG9rZW4gPSBvcHRzLmF1dGhUb2tlblxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIExvbmdQb2xsIHRyYW5zcG9ydCByZWZlcmVuY2VcbiAgICovXG4gIGdldExvbmdQb2xsVHJhbnNwb3J0KCl7IHJldHVybiBMb25nUG9sbCB9XG5cbiAgLyoqXG4gICAqIERpc2Nvbm5lY3RzIGFuZCByZXBsYWNlcyB0aGUgYWN0aXZlIHRyYW5zcG9ydFxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXdUcmFuc3BvcnQgLSBUaGUgbmV3IHRyYW5zcG9ydCBjbGFzcyB0byBpbnN0YW50aWF0ZVxuICAgKlxuICAgKi9cbiAgcmVwbGFjZVRyYW5zcG9ydChuZXdUcmFuc3BvcnQpe1xuICAgIHRoaXMuY29ubmVjdENsb2NrKytcbiAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSB0cnVlXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuZmFsbGJhY2tUaW1lcilcbiAgICB0aGlzLnJlY29ubmVjdFRpbWVyLnJlc2V0KClcbiAgICBpZih0aGlzLmNvbm4pe1xuICAgICAgdGhpcy5jb25uLmNsb3NlKClcbiAgICAgIHRoaXMuY29ubiA9IG51bGxcbiAgICB9XG4gICAgdGhpcy50cmFuc3BvcnQgPSBuZXdUcmFuc3BvcnRcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzb2NrZXQgcHJvdG9jb2xcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHByb3RvY29sKCl7IHJldHVybiBsb2NhdGlvbi5wcm90b2NvbC5tYXRjaCgvXmh0dHBzLykgPyBcIndzc1wiIDogXCJ3c1wiIH1cblxuICAvKipcbiAgICogVGhlIGZ1bGx5IHF1YWxpZmllZCBzb2NrZXQgdXJsXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBlbmRQb2ludFVSTCgpe1xuICAgIGxldCB1cmkgPSBBamF4LmFwcGVuZFBhcmFtcyhcbiAgICAgIEFqYXguYXBwZW5kUGFyYW1zKHRoaXMuZW5kUG9pbnQsIHRoaXMucGFyYW1zKCkpLCB7dnNuOiB0aGlzLnZzbn0pXG4gICAgaWYodXJpLmNoYXJBdCgwKSAhPT0gXCIvXCIpeyByZXR1cm4gdXJpIH1cbiAgICBpZih1cmkuY2hhckF0KDEpID09PSBcIi9cIil7IHJldHVybiBgJHt0aGlzLnByb3RvY29sKCl9OiR7dXJpfWAgfVxuXG4gICAgcmV0dXJuIGAke3RoaXMucHJvdG9jb2woKX06Ly8ke2xvY2F0aW9uLmhvc3R9JHt1cml9YFxuICB9XG5cbiAgLyoqXG4gICAqIERpc2Nvbm5lY3RzIHRoZSBzb2NrZXRcbiAgICpcbiAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DbG9zZUV2ZW50I1N0YXR1c19jb2RlcyBmb3IgdmFsaWQgc3RhdHVzIGNvZGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIE9wdGlvbmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBzb2NrZXQgaXMgZGlzY29ubmVjdGVkLlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IGNvZGUgLSBBIHN0YXR1cyBjb2RlIGZvciBkaXNjb25uZWN0aW9uIChPcHRpb25hbCkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gLSBBIHRleHR1YWwgZGVzY3JpcHRpb24gb2YgdGhlIHJlYXNvbiB0byBkaXNjb25uZWN0LiAoT3B0aW9uYWwpXG4gICAqL1xuICBkaXNjb25uZWN0KGNhbGxiYWNrLCBjb2RlLCByZWFzb24pe1xuICAgIHRoaXMuY29ubmVjdENsb2NrKytcbiAgICB0aGlzLmRpc2Nvbm5lY3RpbmcgPSB0cnVlXG4gICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gdHJ1ZVxuICAgIGNsZWFyVGltZW91dCh0aGlzLmZhbGxiYWNrVGltZXIpXG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lci5yZXNldCgpXG4gICAgdGhpcy50ZWFyZG93bigoKSA9PiB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3RpbmcgPSBmYWxzZVxuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuICAgIH0sIGNvZGUsIHJlYXNvbilcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtcyB0byBzZW5kIHdoZW4gY29ubmVjdGluZywgZm9yIGV4YW1wbGUgYHt1c2VyX2lkOiB1c2VyVG9rZW59YFxuICAgKlxuICAgKiBQYXNzaW5nIHBhcmFtcyB0byBjb25uZWN0IGlzIGRlcHJlY2F0ZWQ7IHBhc3MgdGhlbSBpbiB0aGUgU29ja2V0IGNvbnN0cnVjdG9yIGluc3RlYWQ6XG4gICAqIGBuZXcgU29ja2V0KFwiL3NvY2tldFwiLCB7cGFyYW1zOiB7dXNlcl9pZDogdXNlclRva2VufX0pYC5cbiAgICovXG4gIGNvbm5lY3QocGFyYW1zKXtcbiAgICBpZihwYXJhbXMpe1xuICAgICAgY29uc29sZSAmJiBjb25zb2xlLmxvZyhcInBhc3NpbmcgcGFyYW1zIHRvIGNvbm5lY3QgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCBwYXNzIDpwYXJhbXMgdG8gdGhlIFNvY2tldCBjb25zdHJ1Y3RvclwiKVxuICAgICAgdGhpcy5wYXJhbXMgPSBjbG9zdXJlKHBhcmFtcylcbiAgICB9XG4gICAgaWYodGhpcy5jb25uICYmICF0aGlzLmRpc2Nvbm5lY3RpbmcpeyByZXR1cm4gfVxuICAgIGlmKHRoaXMubG9uZ1BvbGxGYWxsYmFja01zICYmIHRoaXMudHJhbnNwb3J0ICE9PSBMb25nUG9sbCl7XG4gICAgICB0aGlzLmNvbm5lY3RXaXRoRmFsbGJhY2soTG9uZ1BvbGwsIHRoaXMubG9uZ1BvbGxGYWxsYmFja01zKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRyYW5zcG9ydENvbm5lY3QoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIHRoZSBtZXNzYWdlLiBPdmVycmlkZSBgdGhpcy5sb2dnZXJgIGZvciBzcGVjaWFsaXplZCBsb2dnaW5nLiBub29wcyBieSBkZWZhdWx0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBraW5kXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtc2dcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICovXG4gIGxvZyhraW5kLCBtc2csIGRhdGEpeyB0aGlzLmxvZ2dlciAmJiB0aGlzLmxvZ2dlcihraW5kLCBtc2csIGRhdGEpIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGEgbG9nZ2VyIGhhcyBiZWVuIHNldCBvbiB0aGlzIHNvY2tldC5cbiAgICovXG4gIGhhc0xvZ2dlcigpeyByZXR1cm4gdGhpcy5sb2dnZXIgIT09IG51bGwgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgY2FsbGJhY2tzIGZvciBjb25uZWN0aW9uIG9wZW4gZXZlbnRzXG4gICAqXG4gICAqIEBleGFtcGxlIHNvY2tldC5vbk9wZW4oZnVuY3Rpb24oKXsgY29uc29sZS5pbmZvKFwidGhlIHNvY2tldCB3YXMgb3BlbmVkXCIpIH0pXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBvbk9wZW4oY2FsbGJhY2spe1xuICAgIGxldCByZWYgPSB0aGlzLm1ha2VSZWYoKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Mub3Blbi5wdXNoKFtyZWYsIGNhbGxiYWNrXSlcbiAgICByZXR1cm4gcmVmXG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGNhbGxiYWNrcyBmb3IgY29ubmVjdGlvbiBjbG9zZSBldmVudHNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIG9uQ2xvc2UoY2FsbGJhY2spe1xuICAgIGxldCByZWYgPSB0aGlzLm1ha2VSZWYoKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuY2xvc2UucHVzaChbcmVmLCBjYWxsYmFja10pXG4gICAgcmV0dXJuIHJlZlxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBjYWxsYmFja3MgZm9yIGNvbm5lY3Rpb24gZXJyb3IgZXZlbnRzXG4gICAqXG4gICAqIEBleGFtcGxlIHNvY2tldC5vbkVycm9yKGZ1bmN0aW9uKGVycm9yKXsgYWxlcnQoXCJBbiBlcnJvciBvY2N1cnJlZFwiKSB9KVxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25FcnJvcihjYWxsYmFjayl7XG4gICAgbGV0IHJlZiA9IHRoaXMubWFrZVJlZigpXG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5lcnJvci5wdXNoKFtyZWYsIGNhbGxiYWNrXSlcbiAgICByZXR1cm4gcmVmXG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGNhbGxiYWNrcyBmb3IgY29ubmVjdGlvbiBtZXNzYWdlIGV2ZW50c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25NZXNzYWdlKGNhbGxiYWNrKXtcbiAgICBsZXQgcmVmID0gdGhpcy5tYWtlUmVmKClcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm1lc3NhZ2UucHVzaChbcmVmLCBjYWxsYmFja10pXG4gICAgcmV0dXJuIHJlZlxuICB9XG5cbiAgLyoqXG4gICAqIFBpbmdzIHRoZSBzZXJ2ZXIgYW5kIGludm9rZXMgdGhlIGNhbGxiYWNrIHdpdGggdGhlIFJUVCBpbiBtaWxsaXNlY29uZHNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwaW5nIHdhcyBwdXNoZWQgb3IgZmFsc2UgaWYgdW5hYmxlIHRvIGJlIHB1c2hlZC5cbiAgICovXG4gIHBpbmcoY2FsbGJhY2spe1xuICAgIGlmKCF0aGlzLmlzQ29ubmVjdGVkKCkpeyByZXR1cm4gZmFsc2UgfVxuICAgIGxldCByZWYgPSB0aGlzLm1ha2VSZWYoKVxuICAgIGxldCBzdGFydFRpbWUgPSBEYXRlLm5vdygpXG4gICAgdGhpcy5wdXNoKHt0b3BpYzogXCJwaG9lbml4XCIsIGV2ZW50OiBcImhlYXJ0YmVhdFwiLCBwYXlsb2FkOiB7fSwgcmVmOiByZWZ9KVxuICAgIGxldCBvbk1zZ1JlZiA9IHRoaXMub25NZXNzYWdlKG1zZyA9PiB7XG4gICAgICBpZihtc2cucmVmID09PSByZWYpe1xuICAgICAgICB0aGlzLm9mZihbb25Nc2dSZWZdKVxuICAgICAgICBjYWxsYmFjayhEYXRlLm5vdygpIC0gc3RhcnRUaW1lKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0cmFuc3BvcnRDb25uZWN0KCl7XG4gICAgdGhpcy5jb25uZWN0Q2xvY2srK1xuICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IGZhbHNlXG4gICAgbGV0IHByb3RvY29scyA9IHVuZGVmaW5lZFxuICAgIC8vIFNlYy1XZWJTb2NrZXQtUHJvdG9jb2wgYmFzZWQgdG9rZW5cbiAgICAvLyAobG9uZ3BvbGwgdXNlcyBBdXRob3JpemF0aW9uIGhlYWRlciBpbnN0ZWFkKVxuICAgIGlmKHRoaXMuYXV0aFRva2VuKXtcbiAgICAgIHByb3RvY29scyA9IFtcInBob2VuaXhcIiwgYCR7QVVUSF9UT0tFTl9QUkVGSVh9JHtidG9hKHRoaXMuYXV0aFRva2VuKS5yZXBsYWNlKC89L2csIFwiXCIpfWBdXG4gICAgfVxuICAgIHRoaXMuY29ubiA9IG5ldyB0aGlzLnRyYW5zcG9ydCh0aGlzLmVuZFBvaW50VVJMKCksIHByb3RvY29scylcbiAgICB0aGlzLmNvbm4uYmluYXJ5VHlwZSA9IHRoaXMuYmluYXJ5VHlwZVxuICAgIHRoaXMuY29ubi50aW1lb3V0ID0gdGhpcy5sb25ncG9sbGVyVGltZW91dFxuICAgIHRoaXMuY29ubi5vbm9wZW4gPSAoKSA9PiB0aGlzLm9uQ29ubk9wZW4oKVxuICAgIHRoaXMuY29ubi5vbmVycm9yID0gZXJyb3IgPT4gdGhpcy5vbkNvbm5FcnJvcihlcnJvcilcbiAgICB0aGlzLmNvbm4ub25tZXNzYWdlID0gZXZlbnQgPT4gdGhpcy5vbkNvbm5NZXNzYWdlKGV2ZW50KVxuICAgIHRoaXMuY29ubi5vbmNsb3NlID0gZXZlbnQgPT4gdGhpcy5vbkNvbm5DbG9zZShldmVudClcbiAgfVxuXG4gIGdldFNlc3Npb24oa2V5KXsgcmV0dXJuIHRoaXMuc2Vzc2lvblN0b3JlICYmIHRoaXMuc2Vzc2lvblN0b3JlLmdldEl0ZW0oa2V5KSB9XG5cbiAgc3RvcmVTZXNzaW9uKGtleSwgdmFsKXsgdGhpcy5zZXNzaW9uU3RvcmUgJiYgdGhpcy5zZXNzaW9uU3RvcmUuc2V0SXRlbShrZXksIHZhbCkgfVxuXG4gIGNvbm5lY3RXaXRoRmFsbGJhY2soZmFsbGJhY2tUcmFuc3BvcnQsIGZhbGxiYWNrVGhyZXNob2xkID0gMjUwMCl7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuZmFsbGJhY2tUaW1lcilcbiAgICBsZXQgZXN0YWJsaXNoZWQgPSBmYWxzZVxuICAgIGxldCBwcmltYXJ5VHJhbnNwb3J0ID0gdHJ1ZVxuICAgIGxldCBvcGVuUmVmLCBlcnJvclJlZlxuICAgIGxldCBmYWxsYmFjayA9IChyZWFzb24pID0+IHtcbiAgICAgIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIGBmYWxsaW5nIGJhY2sgdG8gJHtmYWxsYmFja1RyYW5zcG9ydC5uYW1lfS4uLmAsIHJlYXNvbilcbiAgICAgIHRoaXMub2ZmKFtvcGVuUmVmLCBlcnJvclJlZl0pXG4gICAgICBwcmltYXJ5VHJhbnNwb3J0ID0gZmFsc2VcbiAgICAgIHRoaXMucmVwbGFjZVRyYW5zcG9ydChmYWxsYmFja1RyYW5zcG9ydClcbiAgICAgIHRoaXMudHJhbnNwb3J0Q29ubmVjdCgpXG4gICAgfVxuICAgIGlmKHRoaXMuZ2V0U2Vzc2lvbihgcGh4OmZhbGxiYWNrOiR7ZmFsbGJhY2tUcmFuc3BvcnQubmFtZX1gKSl7IHJldHVybiBmYWxsYmFjayhcIm1lbW9yaXplZFwiKSB9XG5cbiAgICB0aGlzLmZhbGxiYWNrVGltZXIgPSBzZXRUaW1lb3V0KGZhbGxiYWNrLCBmYWxsYmFja1RocmVzaG9sZClcblxuICAgIGVycm9yUmVmID0gdGhpcy5vbkVycm9yKHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBcImVycm9yXCIsIHJlYXNvbilcbiAgICAgIGlmKHByaW1hcnlUcmFuc3BvcnQgJiYgIWVzdGFibGlzaGVkKXtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZmFsbGJhY2tUaW1lcilcbiAgICAgICAgZmFsbGJhY2socmVhc29uKVxuICAgICAgfVxuICAgIH0pXG4gICAgaWYodGhpcy5mYWxsYmFja1JlZil7XG4gICAgICB0aGlzLm9mZihbdGhpcy5mYWxsYmFja1JlZl0pXG4gICAgfVxuICAgIHRoaXMuZmFsbGJhY2tSZWYgPSB0aGlzLm9uT3BlbigoKSA9PiB7XG4gICAgICBlc3RhYmxpc2hlZCA9IHRydWVcbiAgICAgIGlmKCFwcmltYXJ5VHJhbnNwb3J0KXtcbiAgICAgICAgLy8gb25seSBtZW1vcml6ZSBMUCBpZiB3ZSBuZXZlciBjb25uZWN0ZWQgdG8gcHJpbWFyeVxuICAgICAgICBpZighdGhpcy5wcmltYXJ5UGFzc2VkSGVhbHRoQ2hlY2speyB0aGlzLnN0b3JlU2Vzc2lvbihgcGh4OmZhbGxiYWNrOiR7ZmFsbGJhY2tUcmFuc3BvcnQubmFtZX1gLCBcInRydWVcIikgfVxuICAgICAgICByZXR1cm4gdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgYGVzdGFibGlzaGVkICR7ZmFsbGJhY2tUcmFuc3BvcnQubmFtZX0gZmFsbGJhY2tgKVxuICAgICAgfVxuICAgICAgLy8gaWYgd2UndmUgZXN0YWJsaXNoZWQgcHJpbWFyeSwgZ2l2ZSB0aGUgZmFsbGJhY2sgYSBuZXcgcGVyaW9kIHRvIGF0dGVtcHQgcGluZ1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZmFsbGJhY2tUaW1lcilcbiAgICAgIHRoaXMuZmFsbGJhY2tUaW1lciA9IHNldFRpbWVvdXQoZmFsbGJhY2ssIGZhbGxiYWNrVGhyZXNob2xkKVxuICAgICAgdGhpcy5waW5nKHJ0dCA9PiB7XG4gICAgICAgIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIFwiY29ubmVjdGVkIHRvIHByaW1hcnkgYWZ0ZXJcIiwgcnR0KVxuICAgICAgICB0aGlzLnByaW1hcnlQYXNzZWRIZWFsdGhDaGVjayA9IHRydWVcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZmFsbGJhY2tUaW1lcilcbiAgICAgIH0pXG4gICAgfSlcbiAgICB0aGlzLnRyYW5zcG9ydENvbm5lY3QoKVxuICB9XG5cbiAgY2xlYXJIZWFydGJlYXRzKCl7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVhcnRiZWF0VGltZXIpXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVhcnRiZWF0VGltZW91dFRpbWVyKVxuICB9XG5cbiAgb25Db25uT3Blbigpe1xuICAgIGlmKHRoaXMuaGFzTG9nZ2VyKCkpIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIGAke3RoaXMudHJhbnNwb3J0Lm5hbWV9IGNvbm5lY3RlZCB0byAke3RoaXMuZW5kUG9pbnRVUkwoKX1gKVxuICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IGZhbHNlXG4gICAgdGhpcy5kaXNjb25uZWN0aW5nID0gZmFsc2VcbiAgICB0aGlzLmVzdGFibGlzaGVkQ29ubmVjdGlvbnMrK1xuICAgIHRoaXMuZmx1c2hTZW5kQnVmZmVyKClcbiAgICB0aGlzLnJlY29ubmVjdFRpbWVyLnJlc2V0KClcbiAgICB0aGlzLnJlc2V0SGVhcnRiZWF0KClcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm9wZW4uZm9yRWFjaCgoWywgY2FsbGJhY2tdKSA9PiBjYWxsYmFjaygpKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIGhlYXJ0YmVhdFRpbWVvdXQoKXtcbiAgICBpZih0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYpe1xuICAgICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gbnVsbFxuICAgICAgaWYodGhpcy5oYXNMb2dnZXIoKSl7IHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIFwiaGVhcnRiZWF0IHRpbWVvdXQuIEF0dGVtcHRpbmcgdG8gcmUtZXN0YWJsaXNoIGNvbm5lY3Rpb25cIikgfVxuICAgICAgdGhpcy50cmlnZ2VyQ2hhbkVycm9yKClcbiAgICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IGZhbHNlXG4gICAgICB0aGlzLnRlYXJkb3duKCgpID0+IHRoaXMucmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCksIFdTX0NMT1NFX05PUk1BTCwgXCJoZWFydGJlYXQgdGltZW91dFwiKVxuICAgIH1cbiAgfVxuXG4gIHJlc2V0SGVhcnRiZWF0KCl7XG4gICAgaWYodGhpcy5jb25uICYmIHRoaXMuY29ubi5za2lwSGVhcnRiZWF0KXsgcmV0dXJuIH1cbiAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsXG4gICAgdGhpcy5jbGVhckhlYXJ0YmVhdHMoKVxuICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VuZEhlYXJ0YmVhdCgpLCB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMpXG4gIH1cblxuICB0ZWFyZG93bihjYWxsYmFjaywgY29kZSwgcmVhc29uKXtcbiAgICBpZighdGhpcy5jb25uKXtcbiAgICAgIHJldHVybiBjYWxsYmFjayAmJiBjYWxsYmFjaygpXG4gICAgfVxuICAgIGxldCBjb25uZWN0Q2xvY2sgPSB0aGlzLmNvbm5lY3RDbG9ja1xuXG4gICAgdGhpcy53YWl0Rm9yQnVmZmVyRG9uZSgoKSA9PiB7XG4gICAgICBpZihjb25uZWN0Q2xvY2sgIT09IHRoaXMuY29ubmVjdENsb2NrKXsgcmV0dXJuIH1cbiAgICAgIGlmKHRoaXMuY29ubil7XG4gICAgICAgIGlmKGNvZGUpeyB0aGlzLmNvbm4uY2xvc2UoY29kZSwgcmVhc29uIHx8IFwiXCIpIH0gZWxzZSB7IHRoaXMuY29ubi5jbG9zZSgpIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy53YWl0Rm9yU29ja2V0Q2xvc2VkKCgpID0+IHtcbiAgICAgICAgaWYoY29ubmVjdENsb2NrICE9PSB0aGlzLmNvbm5lY3RDbG9jayl7IHJldHVybiB9XG4gICAgICAgIGlmKHRoaXMuY29ubil7XG4gICAgICAgICAgdGhpcy5jb25uLm9ub3BlbiA9IGZ1bmN0aW9uICgpeyB9IC8vIG5vb3BcbiAgICAgICAgICB0aGlzLmNvbm4ub25lcnJvciA9IGZ1bmN0aW9uICgpeyB9IC8vIG5vb3BcbiAgICAgICAgICB0aGlzLmNvbm4ub25tZXNzYWdlID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgICAgICAgIHRoaXMuY29ubi5vbmNsb3NlID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgICAgICAgIHRoaXMuY29ubiA9IG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHdhaXRGb3JCdWZmZXJEb25lKGNhbGxiYWNrLCB0cmllcyA9IDEpe1xuICAgIGlmKHRyaWVzID09PSA1IHx8ICF0aGlzLmNvbm4gfHwgIXRoaXMuY29ubi5idWZmZXJlZEFtb3VudCl7XG4gICAgICBjYWxsYmFjaygpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMud2FpdEZvckJ1ZmZlckRvbmUoY2FsbGJhY2ssIHRyaWVzICsgMSlcbiAgICB9LCAxNTAgKiB0cmllcylcbiAgfVxuXG4gIHdhaXRGb3JTb2NrZXRDbG9zZWQoY2FsbGJhY2ssIHRyaWVzID0gMSl7XG4gICAgaWYodHJpZXMgPT09IDUgfHwgIXRoaXMuY29ubiB8fCB0aGlzLmNvbm4ucmVhZHlTdGF0ZSA9PT0gU09DS0VUX1NUQVRFUy5jbG9zZWQpe1xuICAgICAgY2FsbGJhY2soKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLndhaXRGb3JTb2NrZXRDbG9zZWQoY2FsbGJhY2ssIHRyaWVzICsgMSlcbiAgICB9LCAxNTAgKiB0cmllcylcbiAgfVxuXG4gIG9uQ29ubkNsb3NlKGV2ZW50KXtcbiAgICBpZih0aGlzLmNvbm4pIHRoaXMuY29ubi5vbmNsb3NlID0gKCkgPT4ge30gLy8gbm9vcCB0byBwcmV2ZW50IHJlY3Vyc2l2ZSBjYWxscyBpbiB0ZWFyZG93blxuICAgIGxldCBjbG9zZUNvZGUgPSBldmVudCAmJiBldmVudC5jb2RlXG4gICAgaWYodGhpcy5oYXNMb2dnZXIoKSkgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgXCJjbG9zZVwiLCBldmVudClcbiAgICB0aGlzLnRyaWdnZXJDaGFuRXJyb3IoKVxuICAgIHRoaXMuY2xlYXJIZWFydGJlYXRzKClcbiAgICBpZighdGhpcy5jbG9zZVdhc0NsZWFuICYmIGNsb3NlQ29kZSAhPT0gMTAwMCl7XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpXG4gICAgfVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuY2xvc2UuZm9yRWFjaCgoWywgY2FsbGJhY2tdKSA9PiBjYWxsYmFjayhldmVudCkpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uQ29ubkVycm9yKGVycm9yKXtcbiAgICBpZih0aGlzLmhhc0xvZ2dlcigpKSB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBlcnJvcilcbiAgICBsZXQgdHJhbnNwb3J0QmVmb3JlID0gdGhpcy50cmFuc3BvcnRcbiAgICBsZXQgZXN0YWJsaXNoZWRCZWZvcmUgPSB0aGlzLmVzdGFibGlzaGVkQ29ubmVjdGlvbnNcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmVycm9yLmZvckVhY2goKFssIGNhbGxiYWNrXSkgPT4ge1xuICAgICAgY2FsbGJhY2soZXJyb3IsIHRyYW5zcG9ydEJlZm9yZSwgZXN0YWJsaXNoZWRCZWZvcmUpXG4gICAgfSlcbiAgICBpZih0cmFuc3BvcnRCZWZvcmUgPT09IHRoaXMudHJhbnNwb3J0IHx8IGVzdGFibGlzaGVkQmVmb3JlID4gMCl7XG4gICAgICB0aGlzLnRyaWdnZXJDaGFuRXJyb3IoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdHJpZ2dlckNoYW5FcnJvcigpe1xuICAgIHRoaXMuY2hhbm5lbHMuZm9yRWFjaChjaGFubmVsID0+IHtcbiAgICAgIGlmKCEoY2hhbm5lbC5pc0Vycm9yZWQoKSB8fCBjaGFubmVsLmlzTGVhdmluZygpIHx8IGNoYW5uZWwuaXNDbG9zZWQoKSkpe1xuICAgICAgICBjaGFubmVsLnRyaWdnZXIoQ0hBTk5FTF9FVkVOVFMuZXJyb3IpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgY29ubmVjdGlvblN0YXRlKCl7XG4gICAgc3dpdGNoKHRoaXMuY29ubiAmJiB0aGlzLmNvbm4ucmVhZHlTdGF0ZSl7XG4gICAgICBjYXNlIFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZzogcmV0dXJuIFwiY29ubmVjdGluZ1wiXG4gICAgICBjYXNlIFNPQ0tFVF9TVEFURVMub3BlbjogcmV0dXJuIFwib3BlblwiXG4gICAgICBjYXNlIFNPQ0tFVF9TVEFURVMuY2xvc2luZzogcmV0dXJuIFwiY2xvc2luZ1wiXG4gICAgICBkZWZhdWx0OiByZXR1cm4gXCJjbG9zZWRcIlxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ29ubmVjdGVkKCl7IHJldHVybiB0aGlzLmNvbm5lY3Rpb25TdGF0ZSgpID09PSBcIm9wZW5cIiB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7Q2hhbm5lbH1cbiAgICovXG4gIHJlbW92ZShjaGFubmVsKXtcbiAgICB0aGlzLm9mZihjaGFubmVsLnN0YXRlQ2hhbmdlUmVmcylcbiAgICB0aGlzLmNoYW5uZWxzID0gdGhpcy5jaGFubmVscy5maWx0ZXIoYyA9PiBjICE9PSBjaGFubmVsKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYG9uT3BlbmAsIGBvbkNsb3NlYCwgYG9uRXJyb3IsYCBhbmQgYG9uTWVzc2FnZWAgcmVnaXN0cmF0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtyZWZzfSAtIGxpc3Qgb2YgcmVmcyByZXR1cm5lZCBieSBjYWxscyB0b1xuICAgKiAgICAgICAgICAgICAgICAgYG9uT3BlbmAsIGBvbkNsb3NlYCwgYG9uRXJyb3IsYCBhbmQgYG9uTWVzc2FnZWBcbiAgICovXG4gIG9mZihyZWZzKXtcbiAgICBmb3IobGV0IGtleSBpbiB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzKXtcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Nba2V5XSA9IHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Nba2V5XS5maWx0ZXIoKFtyZWZdKSA9PiB7XG4gICAgICAgIHJldHVybiByZWZzLmluZGV4T2YocmVmKSA9PT0gLTFcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYXRlcyBhIG5ldyBjaGFubmVsIGZvciB0aGUgZ2l2ZW4gdG9waWNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjaGFuUGFyYW1zIC0gUGFyYW1ldGVycyBmb3IgdGhlIGNoYW5uZWxcbiAgICogQHJldHVybnMge0NoYW5uZWx9XG4gICAqL1xuICBjaGFubmVsKHRvcGljLCBjaGFuUGFyYW1zID0ge30pe1xuICAgIGxldCBjaGFuID0gbmV3IENoYW5uZWwodG9waWMsIGNoYW5QYXJhbXMsIHRoaXMpXG4gICAgdGhpcy5jaGFubmVscy5wdXNoKGNoYW4pXG4gICAgcmV0dXJuIGNoYW5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKi9cbiAgcHVzaChkYXRhKXtcbiAgICBpZih0aGlzLmhhc0xvZ2dlcigpKXtcbiAgICAgIGxldCB7dG9waWMsIGV2ZW50LCBwYXlsb2FkLCByZWYsIGpvaW5fcmVmfSA9IGRhdGFcbiAgICAgIHRoaXMubG9nKFwicHVzaFwiLCBgJHt0b3BpY30gJHtldmVudH0gKCR7am9pbl9yZWZ9LCAke3JlZn0pYCwgcGF5bG9hZClcbiAgICB9XG5cbiAgICBpZih0aGlzLmlzQ29ubmVjdGVkKCkpe1xuICAgICAgdGhpcy5lbmNvZGUoZGF0YSwgcmVzdWx0ID0+IHRoaXMuY29ubi5zZW5kKHJlc3VsdCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEJ1ZmZlci5wdXNoKCgpID0+IHRoaXMuZW5jb2RlKGRhdGEsIHJlc3VsdCA9PiB0aGlzLmNvbm4uc2VuZChyZXN1bHQpKSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBuZXh0IG1lc3NhZ2UgcmVmLCBhY2NvdW50aW5nIGZvciBvdmVyZmxvd3NcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIG1ha2VSZWYoKXtcbiAgICBsZXQgbmV3UmVmID0gdGhpcy5yZWYgKyAxXG4gICAgaWYobmV3UmVmID09PSB0aGlzLnJlZil7IHRoaXMucmVmID0gMCB9IGVsc2UgeyB0aGlzLnJlZiA9IG5ld1JlZiB9XG5cbiAgICByZXR1cm4gdGhpcy5yZWYudG9TdHJpbmcoKVxuICB9XG5cbiAgc2VuZEhlYXJ0YmVhdCgpe1xuICAgIGlmKHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiAmJiAhdGhpcy5pc0Nvbm5lY3RlZCgpKXsgcmV0dXJuIH1cbiAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSB0aGlzLm1ha2VSZWYoKVxuICAgIHRoaXMucHVzaCh7dG9waWM6IFwicGhvZW5peFwiLCBldmVudDogXCJoZWFydGJlYXRcIiwgcGF5bG9hZDoge30sIHJlZjogdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmfSlcbiAgICB0aGlzLmhlYXJ0YmVhdFRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5oZWFydGJlYXRUaW1lb3V0KCksIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcylcbiAgfVxuXG4gIGZsdXNoU2VuZEJ1ZmZlcigpe1xuICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQoKSAmJiB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoID4gMCl7XG4gICAgICB0aGlzLnNlbmRCdWZmZXIuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjaygpKVxuICAgICAgdGhpcy5zZW5kQnVmZmVyID0gW11cbiAgICB9XG4gIH1cblxuICBvbkNvbm5NZXNzYWdlKHJhd01lc3NhZ2Upe1xuICAgIHRoaXMuZGVjb2RlKHJhd01lc3NhZ2UuZGF0YSwgbXNnID0+IHtcbiAgICAgIGxldCB7dG9waWMsIGV2ZW50LCBwYXlsb2FkLCByZWYsIGpvaW5fcmVmfSA9IG1zZ1xuICAgICAgaWYocmVmICYmIHJlZiA9PT0gdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmKXtcbiAgICAgICAgdGhpcy5jbGVhckhlYXJ0YmVhdHMoKVxuICAgICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsXG4gICAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VuZEhlYXJ0YmVhdCgpLCB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMpXG4gICAgICB9XG5cbiAgICAgIGlmKHRoaXMuaGFzTG9nZ2VyKCkpIHRoaXMubG9nKFwicmVjZWl2ZVwiLCBgJHtwYXlsb2FkLnN0YXR1cyB8fCBcIlwifSAke3RvcGljfSAke2V2ZW50fSAke3JlZiAmJiBcIihcIiArIHJlZiArIFwiKVwiIHx8IFwiXCJ9YCwgcGF5bG9hZClcblxuICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuY2hhbm5lbHMubGVuZ3RoOyBpKyspe1xuICAgICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tpXVxuICAgICAgICBpZighY2hhbm5lbC5pc01lbWJlcih0b3BpYywgZXZlbnQsIHBheWxvYWQsIGpvaW5fcmVmKSl7IGNvbnRpbnVlIH1cbiAgICAgICAgY2hhbm5lbC50cmlnZ2VyKGV2ZW50LCBwYXlsb2FkLCByZWYsIGpvaW5fcmVmKVxuICAgICAgfVxuXG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5tZXNzYWdlLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgbGV0IFssIGNhbGxiYWNrXSA9IHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MubWVzc2FnZVtpXVxuICAgICAgICBjYWxsYmFjayhtc2cpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGxlYXZlT3BlblRvcGljKHRvcGljKXtcbiAgICBsZXQgZHVwQ2hhbm5lbCA9IHRoaXMuY2hhbm5lbHMuZmluZChjID0+IGMudG9waWMgPT09IHRvcGljICYmIChjLmlzSm9pbmVkKCkgfHwgYy5pc0pvaW5pbmcoKSkpXG4gICAgaWYoZHVwQ2hhbm5lbCl7XG4gICAgICBpZih0aGlzLmhhc0xvZ2dlcigpKSB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBgbGVhdmluZyBkdXBsaWNhdGUgdG9waWMgXCIke3RvcGljfVwiYClcbiAgICAgIGR1cENoYW5uZWwubGVhdmUoKVxuICAgIH1cbiAgfVxufVxuIiwgImV4cG9ydCBjb25zdCBDT05TRUNVVElWRV9SRUxPQURTID0gXCJjb25zZWN1dGl2ZS1yZWxvYWRzXCI7XG5leHBvcnQgY29uc3QgTUFYX1JFTE9BRFMgPSAxMDtcbmV4cG9ydCBjb25zdCBSRUxPQURfSklUVEVSX01JTiA9IDUwMDA7XG5leHBvcnQgY29uc3QgUkVMT0FEX0pJVFRFUl9NQVggPSAxMDAwMDtcbmV4cG9ydCBjb25zdCBGQUlMU0FGRV9KSVRURVIgPSAzMDAwMDtcbmV4cG9ydCBjb25zdCBQSFhfRVZFTlRfQ0xBU1NFUyA9IFtcbiAgXCJwaHgtY2xpY2stbG9hZGluZ1wiLFxuICBcInBoeC1jaGFuZ2UtbG9hZGluZ1wiLFxuICBcInBoeC1zdWJtaXQtbG9hZGluZ1wiLFxuICBcInBoeC1rZXlkb3duLWxvYWRpbmdcIixcbiAgXCJwaHgta2V5dXAtbG9hZGluZ1wiLFxuICBcInBoeC1ibHVyLWxvYWRpbmdcIixcbiAgXCJwaHgtZm9jdXMtbG9hZGluZ1wiLFxuICBcInBoeC1ob29rLWxvYWRpbmdcIixcbl07XG5leHBvcnQgY29uc3QgUEhYX0RST1BfVEFSR0VUX0FDVElWRV9DTEFTUyA9IFwicGh4LWRyb3AtdGFyZ2V0LWFjdGl2ZVwiO1xuZXhwb3J0IGNvbnN0IFBIWF9DT01QT05FTlQgPSBcImRhdGEtcGh4LWNvbXBvbmVudFwiO1xuZXhwb3J0IGNvbnN0IFBIWF9WSUVXX1JFRiA9IFwiZGF0YS1waHgtdmlld1wiO1xuZXhwb3J0IGNvbnN0IFBIWF9MSVZFX0xJTksgPSBcImRhdGEtcGh4LWxpbmtcIjtcbmV4cG9ydCBjb25zdCBQSFhfVFJBQ0tfU1RBVElDID0gXCJ0cmFjay1zdGF0aWNcIjtcbmV4cG9ydCBjb25zdCBQSFhfTElOS19TVEFURSA9IFwiZGF0YS1waHgtbGluay1zdGF0ZVwiO1xuZXhwb3J0IGNvbnN0IFBIWF9SRUZfTE9BRElORyA9IFwiZGF0YS1waHgtcmVmLWxvYWRpbmdcIjtcbmV4cG9ydCBjb25zdCBQSFhfUkVGX1NSQyA9IFwiZGF0YS1waHgtcmVmLXNyY1wiO1xuZXhwb3J0IGNvbnN0IFBIWF9SRUZfTE9DSyA9IFwiZGF0YS1waHgtcmVmLWxvY2tcIjtcbmV4cG9ydCBjb25zdCBQSFhfUEVORElOR19SRUZTID0gXCJwaHgtcGVuZGluZy1yZWZzXCI7XG5leHBvcnQgY29uc3QgUEhYX1RSQUNLX1VQTE9BRFMgPSBcInRyYWNrLXVwbG9hZHNcIjtcbmV4cG9ydCBjb25zdCBQSFhfVVBMT0FEX1JFRiA9IFwiZGF0YS1waHgtdXBsb2FkLXJlZlwiO1xuZXhwb3J0IGNvbnN0IFBIWF9QUkVGTElHSFRFRF9SRUZTID0gXCJkYXRhLXBoeC1wcmVmbGlnaHRlZC1yZWZzXCI7XG5leHBvcnQgY29uc3QgUEhYX0RPTkVfUkVGUyA9IFwiZGF0YS1waHgtZG9uZS1yZWZzXCI7XG5leHBvcnQgY29uc3QgUEhYX0RST1BfVEFSR0VUID0gXCJkcm9wLXRhcmdldFwiO1xuZXhwb3J0IGNvbnN0IFBIWF9BQ1RJVkVfRU5UUllfUkVGUyA9IFwiZGF0YS1waHgtYWN0aXZlLXJlZnNcIjtcbmV4cG9ydCBjb25zdCBQSFhfTElWRV9GSUxFX1VQREFURUQgPSBcInBoeDpsaXZlLWZpbGU6dXBkYXRlZFwiO1xuZXhwb3J0IGNvbnN0IFBIWF9TS0lQID0gXCJkYXRhLXBoeC1za2lwXCI7XG5leHBvcnQgY29uc3QgUEhYX01BR0lDX0lEID0gXCJkYXRhLXBoeC1pZFwiO1xuZXhwb3J0IGNvbnN0IFBIWF9QUlVORSA9IFwiZGF0YS1waHgtcHJ1bmVcIjtcbmV4cG9ydCBjb25zdCBQSFhfQ09OTkVDVEVEX0NMQVNTID0gXCJwaHgtY29ubmVjdGVkXCI7XG5leHBvcnQgY29uc3QgUEhYX0xPQURJTkdfQ0xBU1MgPSBcInBoeC1sb2FkaW5nXCI7XG5leHBvcnQgY29uc3QgUEhYX0VSUk9SX0NMQVNTID0gXCJwaHgtZXJyb3JcIjtcbmV4cG9ydCBjb25zdCBQSFhfQ0xJRU5UX0VSUk9SX0NMQVNTID0gXCJwaHgtY2xpZW50LWVycm9yXCI7XG5leHBvcnQgY29uc3QgUEhYX1NFUlZFUl9FUlJPUl9DTEFTUyA9IFwicGh4LXNlcnZlci1lcnJvclwiO1xuZXhwb3J0IGNvbnN0IFBIWF9QQVJFTlRfSUQgPSBcImRhdGEtcGh4LXBhcmVudC1pZFwiO1xuZXhwb3J0IGNvbnN0IFBIWF9NQUlOID0gXCJkYXRhLXBoeC1tYWluXCI7XG5leHBvcnQgY29uc3QgUEhYX1JPT1RfSUQgPSBcImRhdGEtcGh4LXJvb3QtaWRcIjtcbmV4cG9ydCBjb25zdCBQSFhfVklFV1BPUlRfVE9QID0gXCJ2aWV3cG9ydC10b3BcIjtcbmV4cG9ydCBjb25zdCBQSFhfVklFV1BPUlRfQk9UVE9NID0gXCJ2aWV3cG9ydC1ib3R0b21cIjtcbmV4cG9ydCBjb25zdCBQSFhfVklFV1BPUlRfT1ZFUlJVTl9UQVJHRVQgPSBcInZpZXdwb3J0LW92ZXJydW4tdGFyZ2V0XCI7XG5leHBvcnQgY29uc3QgUEhYX1RSSUdHRVJfQUNUSU9OID0gXCJ0cmlnZ2VyLWFjdGlvblwiO1xuZXhwb3J0IGNvbnN0IFBIWF9IQVNfRk9DVVNFRCA9IFwicGh4LWhhcy1mb2N1c2VkXCI7XG5leHBvcnQgY29uc3QgRk9DVVNBQkxFX0lOUFVUUyA9IFtcbiAgXCJ0ZXh0XCIsXG4gIFwidGV4dGFyZWFcIixcbiAgXCJudW1iZXJcIixcbiAgXCJlbWFpbFwiLFxuICBcInBhc3N3b3JkXCIsXG4gIFwic2VhcmNoXCIsXG4gIFwidGVsXCIsXG4gIFwidXJsXCIsXG4gIFwiZGF0ZVwiLFxuICBcInRpbWVcIixcbiAgXCJkYXRldGltZS1sb2NhbFwiLFxuICBcImNvbG9yXCIsXG4gIFwicmFuZ2VcIixcbl07XG5leHBvcnQgY29uc3QgQ0hFQ0tBQkxFX0lOUFVUUyA9IFtcImNoZWNrYm94XCIsIFwicmFkaW9cIl07XG5leHBvcnQgY29uc3QgUEhYX0hBU19TVUJNSVRURUQgPSBcInBoeC1oYXMtc3VibWl0dGVkXCI7XG5leHBvcnQgY29uc3QgUEhYX1NFU1NJT04gPSBcImRhdGEtcGh4LXNlc3Npb25cIjtcbmV4cG9ydCBjb25zdCBQSFhfVklFV19TRUxFQ1RPUiA9IGBbJHtQSFhfU0VTU0lPTn1dYDtcbmV4cG9ydCBjb25zdCBQSFhfU1RJQ0tZID0gXCJkYXRhLXBoeC1zdGlja3lcIjtcbmV4cG9ydCBjb25zdCBQSFhfU1RBVElDID0gXCJkYXRhLXBoeC1zdGF0aWNcIjtcbmV4cG9ydCBjb25zdCBQSFhfUkVBRE9OTFkgPSBcImRhdGEtcGh4LXJlYWRvbmx5XCI7XG5leHBvcnQgY29uc3QgUEhYX0RJU0FCTEVEID0gXCJkYXRhLXBoeC1kaXNhYmxlZFwiO1xuZXhwb3J0IGNvbnN0IFBIWF9ESVNBQkxFX1dJVEggPSBcImRpc2FibGUtd2l0aFwiO1xuZXhwb3J0IGNvbnN0IFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSA9IFwiZGF0YS1waHgtZGlzYWJsZS13aXRoLXJlc3RvcmVcIjtcbmV4cG9ydCBjb25zdCBQSFhfSE9PSyA9IFwiaG9va1wiO1xuZXhwb3J0IGNvbnN0IFBIWF9ERUJPVU5DRSA9IFwiZGVib3VuY2VcIjtcbmV4cG9ydCBjb25zdCBQSFhfVEhST1RUTEUgPSBcInRocm90dGxlXCI7XG5leHBvcnQgY29uc3QgUEhYX1VQREFURSA9IFwidXBkYXRlXCI7XG5leHBvcnQgY29uc3QgUEhYX1NUUkVBTSA9IFwic3RyZWFtXCI7XG5leHBvcnQgY29uc3QgUEhYX1NUUkVBTV9SRUYgPSBcImRhdGEtcGh4LXN0cmVhbVwiO1xuZXhwb3J0IGNvbnN0IFBIWF9QT1JUQUwgPSBcImRhdGEtcGh4LXBvcnRhbFwiO1xuZXhwb3J0IGNvbnN0IFBIWF9URUxFUE9SVEVEX1JFRiA9IFwiZGF0YS1waHgtdGVsZXBvcnRlZFwiO1xuZXhwb3J0IGNvbnN0IFBIWF9URUxFUE9SVEVEX1NSQyA9IFwiZGF0YS1waHgtdGVsZXBvcnRlZC1zcmNcIjtcbmV4cG9ydCBjb25zdCBQSFhfUlVOVElNRV9IT09LID0gXCJkYXRhLXBoeC1ydW50aW1lLWhvb2tcIjtcbmV4cG9ydCBjb25zdCBQSFhfTFZfUElEID0gXCJkYXRhLXBoeC1waWRcIjtcbmV4cG9ydCBjb25zdCBQSFhfS0VZID0gXCJrZXlcIjtcbmV4cG9ydCBjb25zdCBQSFhfUFJJVkFURSA9IFwicGh4UHJpdmF0ZVwiO1xuZXhwb3J0IGNvbnN0IFBIWF9BVVRPX1JFQ09WRVIgPSBcImF1dG8tcmVjb3ZlclwiO1xuZXhwb3J0IGNvbnN0IFBIWF9MVl9ERUJVRyA9IFwicGh4OmxpdmUtc29ja2V0OmRlYnVnXCI7XG5leHBvcnQgY29uc3QgUEhYX0xWX1BST0ZJTEUgPSBcInBoeDpsaXZlLXNvY2tldDpwcm9maWxpbmdcIjtcbmV4cG9ydCBjb25zdCBQSFhfTFZfTEFURU5DWV9TSU0gPSBcInBoeDpsaXZlLXNvY2tldDpsYXRlbmN5LXNpbVwiO1xuZXhwb3J0IGNvbnN0IFBIWF9MVl9ISVNUT1JZX1BPU0lUSU9OID0gXCJwaHg6bmF2LWhpc3RvcnktcG9zaXRpb25cIjtcbmV4cG9ydCBjb25zdCBQSFhfUFJPR1JFU1MgPSBcInByb2dyZXNzXCI7XG5leHBvcnQgY29uc3QgUEhYX01PVU5URUQgPSBcIm1vdW50ZWRcIjtcbmV4cG9ydCBjb25zdCBQSFhfUkVMT0FEX1NUQVRVUyA9IFwiX19waG9lbml4X3JlbG9hZF9zdGF0dXNfX1wiO1xuZXhwb3J0IGNvbnN0IExPQURFUl9USU1FT1VUID0gMTtcbmV4cG9ydCBjb25zdCBNQVhfQ0hJTERfSk9JTl9BVFRFTVBUUyA9IDM7XG5leHBvcnQgY29uc3QgQkVGT1JFX1VOTE9BRF9MT0FERVJfVElNRU9VVCA9IDIwMDtcbmV4cG9ydCBjb25zdCBESVNDT05ORUNURURfVElNRU9VVCA9IDUwMDtcbmV4cG9ydCBjb25zdCBCSU5ESU5HX1BSRUZJWCA9IFwicGh4LVwiO1xuZXhwb3J0IGNvbnN0IFBVU0hfVElNRU9VVCA9IDMwMDAwO1xuZXhwb3J0IGNvbnN0IExJTktfSEVBREVSID0gXCJ4LXJlcXVlc3RlZC13aXRoXCI7XG5leHBvcnQgY29uc3QgUkVTUE9OU0VfVVJMX0hFQURFUiA9IFwieC1yZXNwb25zZS11cmxcIjtcbmV4cG9ydCBjb25zdCBERUJPVU5DRV9UUklHR0VSID0gXCJkZWJvdW5jZS10cmlnZ2VyXCI7XG5leHBvcnQgY29uc3QgVEhST1RUTEVEID0gXCJ0aHJvdHRsZWRcIjtcbmV4cG9ydCBjb25zdCBERUJPVU5DRV9QUkVWX0tFWSA9IFwiZGVib3VuY2UtcHJldi1rZXlcIjtcbmV4cG9ydCBjb25zdCBERUZBVUxUUyA9IHtcbiAgZGVib3VuY2U6IDMwMCxcbiAgdGhyb3R0bGU6IDMwMCxcbn07XG5leHBvcnQgY29uc3QgUEhYX1BFTkRJTkdfQVRUUlMgPSBbUEhYX1JFRl9MT0FESU5HLCBQSFhfUkVGX1NSQywgUEhYX1JFRl9MT0NLXTtcbi8vIFJlbmRlcmVkXG5leHBvcnQgY29uc3QgU1RBVElDID0gXCJzXCI7XG5leHBvcnQgY29uc3QgUk9PVCA9IFwiclwiO1xuZXhwb3J0IGNvbnN0IENPTVBPTkVOVFMgPSBcImNcIjtcbmV4cG9ydCBjb25zdCBLRVlFRCA9IFwia1wiO1xuZXhwb3J0IGNvbnN0IEtFWUVEX0NPVU5UID0gXCJrY1wiO1xuZXhwb3J0IGNvbnN0IEVWRU5UUyA9IFwiZVwiO1xuZXhwb3J0IGNvbnN0IFJFUExZID0gXCJyXCI7XG5leHBvcnQgY29uc3QgVElUTEUgPSBcInRcIjtcbmV4cG9ydCBjb25zdCBURU1QTEFURVMgPSBcInBcIjtcbmV4cG9ydCBjb25zdCBTVFJFQU0gPSBcInN0cmVhbVwiO1xuIiwgImltcG9ydCB7IGxvZ0Vycm9yIH0gZnJvbSBcIi4vdXRpbHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW50cnlVcGxvYWRlciB7XG4gIGNvbnN0cnVjdG9yKGVudHJ5LCBjb25maWcsIGxpdmVTb2NrZXQpIHtcbiAgICBjb25zdCB7IGNodW5rX3NpemUsIGNodW5rX3RpbWVvdXQgfSA9IGNvbmZpZztcbiAgICB0aGlzLmxpdmVTb2NrZXQgPSBsaXZlU29ja2V0O1xuICAgIHRoaXMuZW50cnkgPSBlbnRyeTtcbiAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgdGhpcy5jaHVua1NpemUgPSBjaHVua19zaXplO1xuICAgIHRoaXMuY2h1bmtUaW1lb3V0ID0gY2h1bmtfdGltZW91dDtcbiAgICB0aGlzLmNodW5rVGltZXIgPSBudWxsO1xuICAgIHRoaXMuZXJyb3JlZCA9IGZhbHNlO1xuICAgIHRoaXMudXBsb2FkQ2hhbm5lbCA9IGxpdmVTb2NrZXQuY2hhbm5lbChgbHZ1OiR7ZW50cnkucmVmfWAsIHtcbiAgICAgIHRva2VuOiBlbnRyeS5tZXRhZGF0YSgpLFxuICAgIH0pO1xuICB9XG5cbiAgZXJyb3IocmVhc29uKSB7XG4gICAgaWYgKHRoaXMuZXJyb3JlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVwbG9hZENoYW5uZWwubGVhdmUoKTtcbiAgICB0aGlzLmVycm9yZWQgPSB0cnVlO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmNodW5rVGltZXIpO1xuICAgIHRoaXMuZW50cnkuZXJyb3IocmVhc29uKTtcbiAgfVxuXG4gIHVwbG9hZCgpIHtcbiAgICB0aGlzLnVwbG9hZENoYW5uZWwub25FcnJvcigocmVhc29uKSA9PiB0aGlzLmVycm9yKHJlYXNvbikpO1xuICAgIHRoaXMudXBsb2FkQ2hhbm5lbFxuICAgICAgLmpvaW4oKVxuICAgICAgLnJlY2VpdmUoXCJva1wiLCAoX2RhdGEpID0+IHRoaXMucmVhZE5leHRDaHVuaygpKVxuICAgICAgLnJlY2VpdmUoXCJlcnJvclwiLCAocmVhc29uKSA9PiB0aGlzLmVycm9yKHJlYXNvbikpO1xuICB9XG5cbiAgaXNEb25lKCkge1xuICAgIHJldHVybiB0aGlzLm9mZnNldCA+PSB0aGlzLmVudHJ5LmZpbGUuc2l6ZTtcbiAgfVxuXG4gIHJlYWROZXh0Q2h1bmsoKSB7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IHdpbmRvdy5GaWxlUmVhZGVyKCk7XG4gICAgY29uc3QgYmxvYiA9IHRoaXMuZW50cnkuZmlsZS5zbGljZShcbiAgICAgIHRoaXMub2Zmc2V0LFxuICAgICAgdGhpcy5jaHVua1NpemUgKyB0aGlzLm9mZnNldCxcbiAgICApO1xuICAgIHJlYWRlci5vbmxvYWQgPSAoZSkgPT4ge1xuICAgICAgaWYgKGUudGFyZ2V0LmVycm9yID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IC8qKiBAdHlwZSB7QXJyYXlCdWZmZXJ9ICovIChlLnRhcmdldC5yZXN1bHQpLmJ5dGVMZW5ndGg7XG4gICAgICAgIHRoaXMucHVzaENodW5rKC8qKiBAdHlwZSB7QXJyYXlCdWZmZXJ9ICovIChlLnRhcmdldC5yZXN1bHQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsb2dFcnJvcihcIlJlYWQgZXJyb3I6IFwiICsgZS50YXJnZXQuZXJyb3IpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpO1xuICB9XG5cbiAgcHVzaENodW5rKGNodW5rKSB7XG4gICAgaWYgKCF0aGlzLnVwbG9hZENoYW5uZWwuaXNKb2luZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVwbG9hZENoYW5uZWxcbiAgICAgIC5wdXNoKFwiY2h1bmtcIiwgY2h1bmssIHRoaXMuY2h1bmtUaW1lb3V0KVxuICAgICAgLnJlY2VpdmUoXCJva1wiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuZW50cnkucHJvZ3Jlc3MoKHRoaXMub2Zmc2V0IC8gdGhpcy5lbnRyeS5maWxlLnNpemUpICogMTAwKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzRG9uZSgpKSB7XG4gICAgICAgICAgdGhpcy5jaHVua1RpbWVyID0gc2V0VGltZW91dChcbiAgICAgICAgICAgICgpID0+IHRoaXMucmVhZE5leHRDaHVuaygpLFxuICAgICAgICAgICAgdGhpcy5saXZlU29ja2V0LmdldExhdGVuY3lTaW0oKSB8fCAwLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAucmVjZWl2ZShcImVycm9yXCIsICh7IHJlYXNvbiB9KSA9PiB0aGlzLmVycm9yKHJlYXNvbikpO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgUEhYX1ZJRVdfU0VMRUNUT1IgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcblxuaW1wb3J0IEVudHJ5VXBsb2FkZXIgZnJvbSBcIi4vZW50cnlfdXBsb2FkZXJcIjtcblxuZXhwb3J0IGNvbnN0IGxvZ0Vycm9yID0gKG1zZywgb2JqKSA9PiBjb25zb2xlLmVycm9yICYmIGNvbnNvbGUuZXJyb3IobXNnLCBvYmopO1xuXG5leHBvcnQgY29uc3QgaXNDaWQgPSAoY2lkKSA9PiB7XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgY2lkO1xuICByZXR1cm4gdHlwZSA9PT0gXCJudW1iZXJcIiB8fCAodHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAvXigwfFsxLTldXFxkKikkLy50ZXN0KGNpZCkpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdER1cGxpY2F0ZUlkcygpIHtcbiAgY29uc3QgaWRzID0gbmV3IFNldCgpO1xuICBjb25zdCBlbGVtcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqW2lkXVwiKTtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGVsZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGlkcy5oYXMoZWxlbXNbaV0uaWQpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgTXVsdGlwbGUgSURzIGRldGVjdGVkOiAke2VsZW1zW2ldLmlkfS4gRW5zdXJlIHVuaXF1ZSBlbGVtZW50IGlkcy5gLFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWRzLmFkZChlbGVtc1tpXS5pZCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3RJbnZhbGlkU3RyZWFtSW5zZXJ0cyhpbnNlcnRzKSB7XG4gIGNvbnN0IGVycm9ycyA9IG5ldyBTZXQoKTtcbiAgT2JqZWN0LmtleXMoaW5zZXJ0cykuZm9yRWFjaCgoaWQpID0+IHtcbiAgICBjb25zdCBzdHJlYW1FbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICBpZiAoXG4gICAgICBzdHJlYW1FbCAmJlxuICAgICAgc3RyZWFtRWwucGFyZW50RWxlbWVudCAmJlxuICAgICAgc3RyZWFtRWwucGFyZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJwaHgtdXBkYXRlXCIpICE9PSBcInN0cmVhbVwiXG4gICAgKSB7XG4gICAgICBlcnJvcnMuYWRkKFxuICAgICAgICBgVGhlIHN0cmVhbSBjb250YWluZXIgd2l0aCBpZCBcIiR7c3RyZWFtRWwucGFyZW50RWxlbWVudC5pZH1cIiBpcyBtaXNzaW5nIHRoZSBwaHgtdXBkYXRlPVwic3RyZWFtXCIgYXR0cmlidXRlLiBFbnN1cmUgaXQgaXMgc2V0IGZvciBzdHJlYW1zIHRvIHdvcmsgcHJvcGVybHkuYCxcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbiAgZXJyb3JzLmZvckVhY2goKGVycm9yKSA9PiBjb25zb2xlLmVycm9yKGVycm9yKSk7XG59XG5cbmV4cG9ydCBjb25zdCBkZWJ1ZyA9ICh2aWV3LCBraW5kLCBtc2csIG9iaikgPT4ge1xuICBpZiAodmlldy5saXZlU29ja2V0LmlzRGVidWdFbmFibGVkKCkpIHtcbiAgICBjb25zb2xlLmxvZyhgJHt2aWV3LmlkfSAke2tpbmR9OiAke21zZ30gLSBgLCBvYmopO1xuICB9XG59O1xuXG4vLyB3cmFwcyB2YWx1ZSBpbiBjbG9zdXJlIG9yIHJldHVybnMgY2xvc3VyZVxuZXhwb3J0IGNvbnN0IGNsb3N1cmUgPSAodmFsKSA9PlxuICB0eXBlb2YgdmFsID09PSBcImZ1bmN0aW9uXCJcbiAgICA/IHZhbFxuICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfTtcblxuZXhwb3J0IGNvbnN0IGNsb25lID0gKG9iaikgPT4ge1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn07XG5cbmV4cG9ydCBjb25zdCBjbG9zZXN0UGh4QmluZGluZyA9IChlbCwgYmluZGluZywgYm9yZGVyRWwpID0+IHtcbiAgZG8ge1xuICAgIGlmIChlbC5tYXRjaGVzKGBbJHtiaW5kaW5nfV1gKSAmJiAhZWwuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBlbDtcbiAgICB9XG4gICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50IHx8IGVsLnBhcmVudE5vZGU7XG4gIH0gd2hpbGUgKFxuICAgIGVsICE9PSBudWxsICYmXG4gICAgZWwubm9kZVR5cGUgPT09IDEgJiZcbiAgICAhKChib3JkZXJFbCAmJiBib3JkZXJFbC5pc1NhbWVOb2RlKGVsKSkgfHwgZWwubWF0Y2hlcyhQSFhfVklFV19TRUxFQ1RPUikpXG4gICk7XG4gIHJldHVybiBudWxsO1xufTtcblxuZXhwb3J0IGNvbnN0IGlzT2JqZWN0ID0gKG9iaikgPT4ge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgIShvYmogaW5zdGFuY2VvZiBBcnJheSk7XG59O1xuXG5leHBvcnQgY29uc3QgaXNFcXVhbE9iaiA9IChvYmoxLCBvYmoyKSA9PlxuICBKU09OLnN0cmluZ2lmeShvYmoxKSA9PT0gSlNPTi5zdHJpbmdpZnkob2JqMik7XG5cbmV4cG9ydCBjb25zdCBpc0VtcHR5ID0gKG9iaikgPT4ge1xuICBmb3IgKGNvbnN0IHggaW4gb2JqKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuZXhwb3J0IGNvbnN0IG1heWJlID0gKGVsLCBjYWxsYmFjaykgPT4gZWwgJiYgY2FsbGJhY2soZWwpO1xuXG5leHBvcnQgY29uc3QgY2hhbm5lbFVwbG9hZGVyID0gZnVuY3Rpb24gKGVudHJpZXMsIG9uRXJyb3IsIHJlc3AsIGxpdmVTb2NrZXQpIHtcbiAgZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgIGNvbnN0IGVudHJ5VXBsb2FkZXIgPSBuZXcgRW50cnlVcGxvYWRlcihlbnRyeSwgcmVzcC5jb25maWcsIGxpdmVTb2NrZXQpO1xuICAgIGVudHJ5VXBsb2FkZXIudXBsb2FkKCk7XG4gIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGV2ZW50Q29udGFpbnNGaWxlcyA9IChlKSA9PiB7XG4gIGlmIChlLmRhdGFUcmFuc2Zlci50eXBlcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZS5kYXRhVHJhbnNmZXIudHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChlLmRhdGFUcmFuc2Zlci50eXBlc1tpXSA9PT0gXCJGaWxlc1wiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuIiwgImNvbnN0IEJyb3dzZXIgPSB7XG4gIGNhblB1c2hTdGF0ZSgpIHtcbiAgICByZXR1cm4gdHlwZW9mIGhpc3RvcnkucHVzaFN0YXRlICE9PSBcInVuZGVmaW5lZFwiO1xuICB9LFxuXG4gIGRyb3BMb2NhbChsb2NhbFN0b3JhZ2UsIG5hbWVzcGFjZSwgc3Via2V5KSB7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMubG9jYWxLZXkobmFtZXNwYWNlLCBzdWJrZXkpKTtcbiAgfSxcblxuICB1cGRhdGVMb2NhbChsb2NhbFN0b3JhZ2UsIG5hbWVzcGFjZSwgc3Via2V5LCBpbml0aWFsLCBmdW5jKSB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuZ2V0TG9jYWwobG9jYWxTdG9yYWdlLCBuYW1lc3BhY2UsIHN1YmtleSk7XG4gICAgY29uc3Qga2V5ID0gdGhpcy5sb2NhbEtleShuYW1lc3BhY2UsIHN1YmtleSk7XG4gICAgY29uc3QgbmV3VmFsID0gY3VycmVudCA9PT0gbnVsbCA/IGluaXRpYWwgOiBmdW5jKGN1cnJlbnQpO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkobmV3VmFsKSk7XG4gICAgcmV0dXJuIG5ld1ZhbDtcbiAgfSxcblxuICBnZXRMb2NhbChsb2NhbFN0b3JhZ2UsIG5hbWVzcGFjZSwgc3Via2V5KSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0odGhpcy5sb2NhbEtleShuYW1lc3BhY2UsIHN1YmtleSkpKTtcbiAgfSxcblxuICB1cGRhdGVDdXJyZW50U3RhdGUoY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuY2FuUHVzaFN0YXRlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoXG4gICAgICBjYWxsYmFjayhoaXN0b3J5LnN0YXRlIHx8IHt9KSxcbiAgICAgIFwiXCIsXG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZixcbiAgICApO1xuICB9LFxuXG4gIHB1c2hTdGF0ZShraW5kLCBtZXRhLCB0bykge1xuICAgIGlmICh0aGlzLmNhblB1c2hTdGF0ZSgpKSB7XG4gICAgICBpZiAodG8gIT09IHdpbmRvdy5sb2NhdGlvbi5ocmVmKSB7XG4gICAgICAgIGlmIChtZXRhLnR5cGUgPT0gXCJyZWRpcmVjdFwiICYmIG1ldGEuc2Nyb2xsKSB7XG4gICAgICAgICAgLy8gSWYgd2UncmUgcmVkaXJlY3Rpbmcgc3RvcmUgdGhlIGN1cnJlbnQgc2Nyb2xsWSBmb3IgdGhlIGN1cnJlbnQgaGlzdG9yeSBzdGF0ZS5cbiAgICAgICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBoaXN0b3J5LnN0YXRlIHx8IHt9O1xuICAgICAgICAgIGN1cnJlbnRTdGF0ZS5zY3JvbGwgPSBtZXRhLnNjcm9sbDtcbiAgICAgICAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZShjdXJyZW50U3RhdGUsIFwiXCIsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSBtZXRhLnNjcm9sbDsgLy8gT25seSBzdG9yZSB0aGUgc2Nyb2xsIGluIHRoZSByZWRpcmVjdCBjYXNlLlxuICAgICAgICBoaXN0b3J5W2tpbmQgKyBcIlN0YXRlXCJdKG1ldGEsIFwiXCIsIHRvIHx8IG51bGwpOyAvLyBJRSB3aWxsIGNvZXJjZSB1bmRlZmluZWQgdG8gc3RyaW5nXG5cbiAgICAgICAgLy8gd2hlbiB1c2luZyBuYXZpZ2F0ZSwgd2UnZCBjYWxsIHB1c2hTdGF0ZSBpbW1lZGlhdGVseSBiZWZvcmUgcGF0Y2hpbmcgdGhlIERPTSxcbiAgICAgICAgLy8ganVtcGluZyBiYWNrIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2UsIGVmZmVjdGl2ZWx5IGlnbm9yaW5nIHRoZSBzY3JvbGxJbnRvVmlldztcbiAgICAgICAgLy8gdGhlcmVmb3JlIHdlIHdhaXQgZm9yIHRoZSBuZXh0IGZyYW1lIChhZnRlciB0aGUgRE9NIHBhdGNoKSBhbmQgb25seSB0aGVuIHRyeVxuICAgICAgICAvLyB0byBzY3JvbGwgdG8gdGhlIGhhc2hFbFxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBoYXNoRWwgPSB0aGlzLmdldEhhc2hUYXJnZXRFbCh3aW5kb3cubG9jYXRpb24uaGFzaCk7XG5cbiAgICAgICAgICBpZiAoaGFzaEVsKSB7XG4gICAgICAgICAgICBoYXNoRWwuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1ldGEudHlwZSA9PT0gXCJyZWRpcmVjdFwiKSB7XG4gICAgICAgICAgICB3aW5kb3cuc2Nyb2xsKDAsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVkaXJlY3QodG8pO1xuICAgIH1cbiAgfSxcblxuICBzZXRDb29raWUobmFtZSwgdmFsdWUsIG1heEFnZVNlY29uZHMpIHtcbiAgICBjb25zdCBleHBpcmVzID1cbiAgICAgIHR5cGVvZiBtYXhBZ2VTZWNvbmRzID09PSBcIm51bWJlclwiID8gYCBtYXgtYWdlPSR7bWF4QWdlU2Vjb25kc307YCA6IFwiXCI7XG4gICAgZG9jdW1lbnQuY29va2llID0gYCR7bmFtZX09JHt2YWx1ZX07JHtleHBpcmVzfSBwYXRoPS9gO1xuICB9LFxuXG4gIGdldENvb2tpZShuYW1lKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNvb2tpZS5yZXBsYWNlKFxuICAgICAgbmV3IFJlZ0V4cChgKD86KD86XnwuKjtcXHMqKSR7bmFtZX1cXHMqXFw9XFxzKihbXjtdKikuKiQpfF4uKiRgKSxcbiAgICAgIFwiJDFcIixcbiAgICApO1xuICB9LFxuXG4gIGRlbGV0ZUNvb2tpZShuYW1lKSB7XG4gICAgZG9jdW1lbnQuY29va2llID0gYCR7bmFtZX09OyBtYXgtYWdlPS0xOyBwYXRoPS9gO1xuICB9LFxuXG4gIHJlZGlyZWN0KFxuICAgIHRvVVJMLFxuICAgIGZsYXNoLFxuICAgIG5hdmlnYXRlID0gKHVybCkgPT4ge1xuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG4gICAgfSxcbiAgKSB7XG4gICAgaWYgKGZsYXNoKSB7XG4gICAgICB0aGlzLnNldENvb2tpZShcIl9fcGhvZW5peF9mbGFzaF9fXCIsIGZsYXNoLCA2MCk7XG4gICAgfVxuICAgIG5hdmlnYXRlKHRvVVJMKTtcbiAgfSxcblxuICBsb2NhbEtleShuYW1lc3BhY2UsIHN1YmtleSkge1xuICAgIHJldHVybiBgJHtuYW1lc3BhY2V9LSR7c3Via2V5fWA7XG4gIH0sXG5cbiAgZ2V0SGFzaFRhcmdldEVsKG1heWJlSGFzaCkge1xuICAgIGNvbnN0IGhhc2ggPSBtYXliZUhhc2gudG9TdHJpbmcoKS5zdWJzdHJpbmcoMSk7XG4gICAgaWYgKGhhc2ggPT09IFwiXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhhc2gpIHx8XG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBhW25hbWU9XCIke2hhc2h9XCJdYClcbiAgICApO1xuICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgQnJvd3NlcjtcbiIsICJpbXBvcnQge1xuICBDSEVDS0FCTEVfSU5QVVRTLFxuICBERUJPVU5DRV9QUkVWX0tFWSxcbiAgREVCT1VOQ0VfVFJJR0dFUixcbiAgRk9DVVNBQkxFX0lOUFVUUyxcbiAgUEhYX0NPTVBPTkVOVCxcbiAgUEhYX1ZJRVdfUkVGLFxuICBQSFhfVEVMRVBPUlRFRF9SRUYsXG4gIFBIWF9IQVNfRk9DVVNFRCxcbiAgUEhYX0hBU19TVUJNSVRURUQsXG4gIFBIWF9NQUlOLFxuICBQSFhfUEFSRU5UX0lELFxuICBQSFhfUFJJVkFURSxcbiAgUEhYX1JFRl9TUkMsXG4gIFBIWF9SRUZfTE9DSyxcbiAgUEhYX1BFTkRJTkdfQVRUUlMsXG4gIFBIWF9ST09UX0lELFxuICBQSFhfU0VTU0lPTixcbiAgUEhYX1NUQVRJQyxcbiAgUEhYX1VQTE9BRF9SRUYsXG4gIFBIWF9WSUVXX1NFTEVDVE9SLFxuICBQSFhfU1RJQ0tZLFxuICBQSFhfRVZFTlRfQ0xBU1NFUyxcbiAgVEhST1RUTEVELFxuICBQSFhfUE9SVEFMLFxuICBQSFhfU1RSRUFNLFxufSBmcm9tIFwiLi9jb25zdGFudHNcIjtcblxuaW1wb3J0IHsgbG9nRXJyb3IgfSBmcm9tIFwiLi91dGlsc1wiO1xuXG5jb25zdCBET00gPSB7XG4gIGJ5SWQoaWQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIHx8IGxvZ0Vycm9yKGBubyBpZCBmb3VuZCBmb3IgJHtpZH1gKTtcbiAgfSxcblxuICByZW1vdmVDbGFzcyhlbCwgY2xhc3NOYW1lKSB7XG4gICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgIGlmIChlbC5jbGFzc0xpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICB9XG4gIH0sXG5cbiAgYWxsKG5vZGUsIHF1ZXJ5LCBjYWxsYmFjaykge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBhcnJheSA9IEFycmF5LmZyb20obm9kZS5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KSk7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBhcnJheS5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9LFxuXG4gIGNoaWxkTm9kZUxlbmd0aChodG1sKSB7XG4gICAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG4gICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgICByZXR1cm4gdGVtcGxhdGUuY29udGVudC5jaGlsZEVsZW1lbnRDb3VudDtcbiAgfSxcblxuICBpc1VwbG9hZElucHV0KGVsKSB7XG4gICAgcmV0dXJuIGVsLnR5cGUgPT09IFwiZmlsZVwiICYmIGVsLmdldEF0dHJpYnV0ZShQSFhfVVBMT0FEX1JFRikgIT09IG51bGw7XG4gIH0sXG5cbiAgaXNBdXRvVXBsb2FkKGlucHV0RWwpIHtcbiAgICByZXR1cm4gaW5wdXRFbC5oYXNBdHRyaWJ1dGUoXCJkYXRhLXBoeC1hdXRvLXVwbG9hZFwiKTtcbiAgfSxcblxuICBmaW5kVXBsb2FkSW5wdXRzKG5vZGUpIHtcbiAgICBjb25zdCBmb3JtSWQgPSBub2RlLmlkO1xuICAgIGNvbnN0IGlucHV0c091dHNpZGVGb3JtID0gdGhpcy5hbGwoXG4gICAgICBkb2N1bWVudCxcbiAgICAgIGBpbnB1dFt0eXBlPVwiZmlsZVwiXVske1BIWF9VUExPQURfUkVGfV1bZm9ybT1cIiR7Zm9ybUlkfVwiXWAsXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5hbGwobm9kZSwgYGlucHV0W3R5cGU9XCJmaWxlXCJdWyR7UEhYX1VQTE9BRF9SRUZ9XWApLmNvbmNhdChcbiAgICAgIGlucHV0c091dHNpZGVGb3JtLFxuICAgICk7XG4gIH0sXG5cbiAgZmluZENvbXBvbmVudE5vZGVMaXN0KHZpZXdJZCwgY2lkLCBkb2MgPSBkb2N1bWVudCkge1xuICAgIHJldHVybiB0aGlzLmFsbChcbiAgICAgIGRvYyxcbiAgICAgIGBbJHtQSFhfVklFV19SRUZ9PVwiJHt2aWV3SWR9XCJdWyR7UEhYX0NPTVBPTkVOVH09XCIke2NpZH1cIl1gLFxuICAgICk7XG4gIH0sXG5cbiAgaXNQaHhEZXN0cm95ZWQobm9kZSkge1xuICAgIHJldHVybiBub2RlLmlkICYmIERPTS5wcml2YXRlKG5vZGUsIFwiZGVzdHJveWVkXCIpID8gdHJ1ZSA6IGZhbHNlO1xuICB9LFxuXG4gIHdhbnRzTmV3VGFiKGUpIHtcbiAgICBjb25zdCB3YW50c05ld1RhYiA9XG4gICAgICBlLmN0cmxLZXkgfHwgZS5zaGlmdEtleSB8fCBlLm1ldGFLZXkgfHwgKGUuYnV0dG9uICYmIGUuYnV0dG9uID09PSAxKTtcbiAgICBjb25zdCBpc0Rvd25sb2FkID1cbiAgICAgIGUudGFyZ2V0IGluc3RhbmNlb2YgSFRNTEFuY2hvckVsZW1lbnQgJiZcbiAgICAgIGUudGFyZ2V0Lmhhc0F0dHJpYnV0ZShcImRvd25sb2FkXCIpO1xuICAgIGNvbnN0IGlzVGFyZ2V0QmxhbmsgPVxuICAgICAgZS50YXJnZXQuaGFzQXR0cmlidXRlKFwidGFyZ2V0XCIpICYmXG4gICAgICBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIikudG9Mb3dlckNhc2UoKSA9PT0gXCJfYmxhbmtcIjtcbiAgICBjb25zdCBpc1RhcmdldE5hbWVkVGFiID1cbiAgICAgIGUudGFyZ2V0Lmhhc0F0dHJpYnV0ZShcInRhcmdldFwiKSAmJlxuICAgICAgIWUudGFyZ2V0LmdldEF0dHJpYnV0ZShcInRhcmdldFwiKS5zdGFydHNXaXRoKFwiX1wiKTtcbiAgICByZXR1cm4gd2FudHNOZXdUYWIgfHwgaXNUYXJnZXRCbGFuayB8fCBpc0Rvd25sb2FkIHx8IGlzVGFyZ2V0TmFtZWRUYWI7XG4gIH0sXG5cbiAgaXNVbmxvYWRhYmxlRm9ybVN1Ym1pdChlKSB7XG4gICAgLy8gSWdub3JlIGZvcm0gc3VibWlzc2lvbnMgaW50ZW5kZWQgdG8gY2xvc2UgYSBuYXRpdmUgPGRpYWxvZz4gZWxlbWVudFxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9kaWFsb2cjdXNhZ2Vfbm90ZXNcbiAgICBjb25zdCBpc0RpYWxvZ1N1Ym1pdCA9XG4gICAgICAoZS50YXJnZXQgJiYgZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwibWV0aG9kXCIpID09PSBcImRpYWxvZ1wiKSB8fFxuICAgICAgKGUuc3VibWl0dGVyICYmIGUuc3VibWl0dGVyLmdldEF0dHJpYnV0ZShcImZvcm1tZXRob2RcIikgPT09IFwiZGlhbG9nXCIpO1xuXG4gICAgaWYgKGlzRGlhbG9nU3VibWl0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAhZS5kZWZhdWx0UHJldmVudGVkICYmICF0aGlzLndhbnRzTmV3VGFiKGUpO1xuICAgIH1cbiAgfSxcblxuICBpc05ld1BhZ2VDbGljayhlLCBjdXJyZW50TG9jYXRpb24pIHtcbiAgICBjb25zdCBocmVmID1cbiAgICAgIGUudGFyZ2V0IGluc3RhbmNlb2YgSFRNTEFuY2hvckVsZW1lbnRcbiAgICAgICAgPyBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpXG4gICAgICAgIDogbnVsbDtcbiAgICBsZXQgdXJsO1xuXG4gICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCB8fCBocmVmID09PSBudWxsIHx8IHRoaXMud2FudHNOZXdUYWIoZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGhyZWYuc3RhcnRzV2l0aChcIm1haWx0bzpcIikgfHwgaHJlZi5zdGFydHNXaXRoKFwidGVsOlwiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZS50YXJnZXQuaXNDb250ZW50RWRpdGFibGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdXJsID0gbmV3IFVSTChocmVmKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHVybCA9IG5ldyBVUkwoaHJlZiwgY3VycmVudExvY2F0aW9uKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBiYWQgVVJMLCBmYWxsYmFjayB0byBsZXQgYnJvd3NlciB0cnkgaXQgYXMgZXh0ZXJuYWxcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdXJsLmhvc3QgPT09IGN1cnJlbnRMb2NhdGlvbi5ob3N0ICYmXG4gICAgICB1cmwucHJvdG9jb2wgPT09IGN1cnJlbnRMb2NhdGlvbi5wcm90b2NvbFxuICAgICkge1xuICAgICAgaWYgKFxuICAgICAgICB1cmwucGF0aG5hbWUgPT09IGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZSAmJlxuICAgICAgICB1cmwuc2VhcmNoID09PSBjdXJyZW50TG9jYXRpb24uc2VhcmNoXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHVybC5oYXNoID09PSBcIlwiICYmICF1cmwuaHJlZi5lbmRzV2l0aChcIiNcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1cmwucHJvdG9jb2wuc3RhcnRzV2l0aChcImh0dHBcIik7XG4gIH0sXG5cbiAgbWFya1BoeENoaWxkRGVzdHJveWVkKGVsKSB7XG4gICAgaWYgKHRoaXMuaXNQaHhDaGlsZChlbCkpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShQSFhfU0VTU0lPTiwgXCJcIik7XG4gICAgfVxuICAgIHRoaXMucHV0UHJpdmF0ZShlbCwgXCJkZXN0cm95ZWRcIiwgdHJ1ZSk7XG4gIH0sXG5cbiAgZmluZFBoeENoaWxkcmVuSW5GcmFnbWVudChodG1sLCBwYXJlbnRJZCkge1xuICAgIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIHRoaXMuZmluZFBoeENoaWxkcmVuKHRlbXBsYXRlLmNvbnRlbnQsIHBhcmVudElkKTtcbiAgfSxcblxuICBpc0lnbm9yZWQoZWwsIHBoeFVwZGF0ZSkge1xuICAgIHJldHVybiAoXG4gICAgICAoZWwuZ2V0QXR0cmlidXRlKHBoeFVwZGF0ZSkgfHwgZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1waHgtdXBkYXRlXCIpKSA9PT1cbiAgICAgIFwiaWdub3JlXCJcbiAgICApO1xuICB9LFxuXG4gIGlzUGh4VXBkYXRlKGVsLCBwaHhVcGRhdGUsIHVwZGF0ZVR5cGVzKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGVsLmdldEF0dHJpYnV0ZSAmJiB1cGRhdGVUeXBlcy5pbmRleE9mKGVsLmdldEF0dHJpYnV0ZShwaHhVcGRhdGUpKSA+PSAwXG4gICAgKTtcbiAgfSxcblxuICBmaW5kUGh4U3RpY2t5KGVsKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsKGVsLCBgWyR7UEhYX1NUSUNLWX1dYCk7XG4gIH0sXG5cbiAgZmluZFBoeENoaWxkcmVuKGVsLCBwYXJlbnRJZCkge1xuICAgIHJldHVybiB0aGlzLmFsbChlbCwgYCR7UEhYX1ZJRVdfU0VMRUNUT1J9WyR7UEhYX1BBUkVOVF9JRH09XCIke3BhcmVudElkfVwiXWApO1xuICB9LFxuXG4gIGZpbmRFeGlzdGluZ1BhcmVudENJRHModmlld0lkLCBjaWRzKSB7XG4gICAgLy8gd2Ugb25seSB3YW50IHRvIGZpbmQgcGFyZW50cyB0aGF0IGV4aXN0IG9uIHRoZSBwYWdlXG4gICAgLy8gaWYgYSBjaWQgaXMgbm90IG9uIHRoZSBwYWdlLCB0aGUgb25seSB3YXkgaXQgY2FuIGJlIGFkZGVkIGJhY2sgdG8gdGhlIHBhZ2VcbiAgICAvLyBpcyBpZiBhIHBhcmVudCBhZGRzIGl0IGJhY2ssIHRoZXJlZm9yZSBpZiBhIGNpZCBkb2VzIG5vdCBleGlzdCBvbiB0aGUgcGFnZSxcbiAgICAvLyB3ZSBzaG91bGQgbm90IHRyeSB0byByZW5kZXIgaXQgYnkgaXRzZWxmIChiZWNhdXNlIGl0IHdvdWxkIGJlIHJlbmRlcmVkIHR3aWNlLFxuICAgIC8vIG9uZSBieSB0aGUgcGFyZW50LCBhbmQgYSBzZWNvbmQgdGltZSBieSBpdHNlbGYpXG4gICAgY29uc3QgcGFyZW50Q2lkcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBjaGlsZHJlbkNpZHMgPSBuZXcgU2V0KCk7XG5cbiAgICBjaWRzLmZvckVhY2goKGNpZCkgPT4ge1xuICAgICAgdGhpcy5hbGwoXG4gICAgICAgIGRvY3VtZW50LFxuICAgICAgICBgWyR7UEhYX1ZJRVdfUkVGfT1cIiR7dmlld0lkfVwiXVske1BIWF9DT01QT05FTlR9PVwiJHtjaWR9XCJdYCxcbiAgICAgICkuZm9yRWFjaCgocGFyZW50KSA9PiB7XG4gICAgICAgIHBhcmVudENpZHMuYWRkKGNpZCk7XG4gICAgICAgIHRoaXMuYWxsKHBhcmVudCwgYFske1BIWF9WSUVXX1JFRn09XCIke3ZpZXdJZH1cIl1bJHtQSFhfQ09NUE9ORU5UfV1gKVxuICAgICAgICAgIC5tYXAoKGVsKSA9PiBwYXJzZUludChlbC5nZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVCkpKVxuICAgICAgICAgIC5mb3JFYWNoKChjaGlsZENJRCkgPT4gY2hpbGRyZW5DaWRzLmFkZChjaGlsZENJRCkpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBjaGlsZHJlbkNpZHMuZm9yRWFjaCgoY2hpbGRDaWQpID0+IHBhcmVudENpZHMuZGVsZXRlKGNoaWxkQ2lkKSk7XG5cbiAgICByZXR1cm4gcGFyZW50Q2lkcztcbiAgfSxcblxuICBwcml2YXRlKGVsLCBrZXkpIHtcbiAgICByZXR1cm4gZWxbUEhYX1BSSVZBVEVdICYmIGVsW1BIWF9QUklWQVRFXVtrZXldO1xuICB9LFxuXG4gIGRlbGV0ZVByaXZhdGUoZWwsIGtleSkge1xuICAgIGVsW1BIWF9QUklWQVRFXSAmJiBkZWxldGUgZWxbUEhYX1BSSVZBVEVdW2tleV07XG4gIH0sXG5cbiAgcHV0UHJpdmF0ZShlbCwga2V5LCB2YWx1ZSkge1xuICAgIGlmICghZWxbUEhYX1BSSVZBVEVdKSB7XG4gICAgICBlbFtQSFhfUFJJVkFURV0gPSB7fTtcbiAgICB9XG4gICAgZWxbUEhYX1BSSVZBVEVdW2tleV0gPSB2YWx1ZTtcbiAgfSxcblxuICB1cGRhdGVQcml2YXRlKGVsLCBrZXksIGRlZmF1bHRWYWwsIHVwZGF0ZUZ1bmMpIHtcbiAgICBjb25zdCBleGlzdGluZyA9IHRoaXMucHJpdmF0ZShlbCwga2V5KTtcbiAgICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5wdXRQcml2YXRlKGVsLCBrZXksIHVwZGF0ZUZ1bmMoZGVmYXVsdFZhbCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1dFByaXZhdGUoZWwsIGtleSwgdXBkYXRlRnVuYyhleGlzdGluZykpO1xuICAgIH1cbiAgfSxcblxuICBzeW5jUGVuZGluZ0F0dHJzKGZyb21FbCwgdG9FbCkge1xuICAgIGlmICghZnJvbUVsLmhhc0F0dHJpYnV0ZShQSFhfUkVGX1NSQykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgUEhYX0VWRU5UX0NMQVNTRVMuZm9yRWFjaCgoY2xhc3NOYW1lKSA9PiB7XG4gICAgICBmcm9tRWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSkgJiYgdG9FbC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgfSk7XG4gICAgUEhYX1BFTkRJTkdfQVRUUlMuZmlsdGVyKChhdHRyKSA9PiBmcm9tRWwuaGFzQXR0cmlidXRlKGF0dHIpKS5mb3JFYWNoKFxuICAgICAgKGF0dHIpID0+IHtcbiAgICAgICAgdG9FbC5zZXRBdHRyaWJ1dGUoYXR0ciwgZnJvbUVsLmdldEF0dHJpYnV0ZShhdHRyKSk7XG4gICAgICB9LFxuICAgICk7XG4gIH0sXG5cbiAgY29weVByaXZhdGVzKHRhcmdldCwgc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZVtQSFhfUFJJVkFURV0pIHtcbiAgICAgIHRhcmdldFtQSFhfUFJJVkFURV0gPSBzb3VyY2VbUEhYX1BSSVZBVEVdO1xuICAgIH1cbiAgfSxcblxuICBwdXRUaXRsZShzdHIpIHtcbiAgICBjb25zdCB0aXRsZUVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcInRpdGxlXCIpO1xuICAgIGlmICh0aXRsZUVsKSB7XG4gICAgICBjb25zdCB7IHByZWZpeCwgc3VmZml4LCBkZWZhdWx0OiBkZWZhdWx0VGl0bGUgfSA9IHRpdGxlRWwuZGF0YXNldDtcbiAgICAgIGNvbnN0IGlzRW1wdHkgPSB0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiIHx8IHN0ci50cmltKCkgPT09IFwiXCI7XG4gICAgICBpZiAoaXNFbXB0eSAmJiB0eXBlb2YgZGVmYXVsdFRpdGxlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5uZXIgPSBpc0VtcHR5ID8gZGVmYXVsdFRpdGxlIDogc3RyO1xuICAgICAgZG9jdW1lbnQudGl0bGUgPSBgJHtwcmVmaXggfHwgXCJcIn0ke2lubmVyIHx8IFwiXCJ9JHtzdWZmaXggfHwgXCJcIn1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb2N1bWVudC50aXRsZSA9IHN0cjtcbiAgICB9XG4gIH0sXG5cbiAgZGVib3VuY2UoXG4gICAgZWwsXG4gICAgZXZlbnQsXG4gICAgcGh4RGVib3VuY2UsXG4gICAgZGVmYXVsdERlYm91bmNlLFxuICAgIHBoeFRocm90dGxlLFxuICAgIGRlZmF1bHRUaHJvdHRsZSxcbiAgICBhc3luY0ZpbHRlcixcbiAgICBjYWxsYmFjayxcbiAgKSB7XG4gICAgbGV0IGRlYm91bmNlID0gZWwuZ2V0QXR0cmlidXRlKHBoeERlYm91bmNlKTtcbiAgICBsZXQgdGhyb3R0bGUgPSBlbC5nZXRBdHRyaWJ1dGUocGh4VGhyb3R0bGUpO1xuXG4gICAgaWYgKGRlYm91bmNlID09PSBcIlwiKSB7XG4gICAgICBkZWJvdW5jZSA9IGRlZmF1bHREZWJvdW5jZTtcbiAgICB9XG4gICAgaWYgKHRocm90dGxlID09PSBcIlwiKSB7XG4gICAgICB0aHJvdHRsZSA9IGRlZmF1bHRUaHJvdHRsZTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBkZWJvdW5jZSB8fCB0aHJvdHRsZTtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICBjYXNlIG51bGw6XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuXG4gICAgICBjYXNlIFwiYmx1clwiOlxuICAgICAgICB0aGlzLmluY0N5Y2xlKGVsLCBcImRlYm91bmNlLWJsdXItY3ljbGVcIiwgKCkgPT4ge1xuICAgICAgICAgIGlmIChhc3luY0ZpbHRlcigpKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLm9uY2UoZWwsIFwiZGVib3VuY2UtYmx1clwiKSkge1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsICgpID0+XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJDeWNsZShlbCwgXCJkZWJvdW5jZS1ibHVyLWN5Y2xlXCIpLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb25zdCB0aW1lb3V0ID0gcGFyc2VJbnQodmFsdWUpO1xuICAgICAgICBjb25zdCB0cmlnZ2VyID0gKCkgPT5cbiAgICAgICAgICB0aHJvdHRsZSA/IHRoaXMuZGVsZXRlUHJpdmF0ZShlbCwgVEhST1RUTEVEKSA6IGNhbGxiYWNrKCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDeWNsZSA9IHRoaXMuaW5jQ3ljbGUoZWwsIERFQk9VTkNFX1RSSUdHRVIsIHRyaWdnZXIpO1xuICAgICAgICBpZiAoaXNOYU4odGltZW91dCkpIHtcbiAgICAgICAgICByZXR1cm4gbG9nRXJyb3IoYGludmFsaWQgdGhyb3R0bGUvZGVib3VuY2UgdmFsdWU6ICR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRocm90dGxlKSB7XG4gICAgICAgICAgbGV0IG5ld0tleURvd24gPSBmYWxzZTtcbiAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJrZXlkb3duXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZLZXkgPSB0aGlzLnByaXZhdGUoZWwsIERFQk9VTkNFX1BSRVZfS0VZKTtcbiAgICAgICAgICAgIHRoaXMucHV0UHJpdmF0ZShlbCwgREVCT1VOQ0VfUFJFVl9LRVksIGV2ZW50LmtleSk7XG4gICAgICAgICAgICBuZXdLZXlEb3duID0gcHJldktleSAhPT0gZXZlbnQua2V5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghbmV3S2V5RG93biAmJiB0aGlzLnByaXZhdGUoZWwsIFRIUk9UVExFRCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGNvbnN0IHQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGFzeW5jRmlsdGVyKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJDeWNsZShlbCwgREVCT1VOQ0VfVFJJR0dFUik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5wdXRQcml2YXRlKGVsLCBUSFJPVFRMRUQsIHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChhc3luY0ZpbHRlcigpKSB7XG4gICAgICAgICAgICAgIHRoaXMudHJpZ2dlckN5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSLCBjdXJyZW50Q3ljbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZm9ybSA9IGVsLmZvcm07XG4gICAgICAgIGlmIChmb3JtICYmIHRoaXMub25jZShmb3JtLCBcImJpbmQtZGVib3VuY2VcIikpIHtcbiAgICAgICAgICBmb3JtLmFkZEV2ZW50TGlzdGVuZXIoXCJzdWJtaXRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgQXJyYXkuZnJvbShuZXcgRm9ybURhdGEoZm9ybSkuZW50cmllcygpLCAoW25hbWVdKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IG5hbWVkSXRlbSA9IGZvcm0uZWxlbWVudHMubmFtZWRJdGVtKG5hbWUpO1xuICAgICAgICAgICAgICBjb25zdCBpbnB1dCA9XG4gICAgICAgICAgICAgICAgbmFtZWRJdGVtIGluc3RhbmNlb2YgUmFkaW9Ob2RlTGlzdCA/IG5hbWVkSXRlbVswXSA6IG5hbWVkSXRlbTtcbiAgICAgICAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmNDeWNsZShpbnB1dCwgREVCT1VOQ0VfVFJJR0dFUik7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGVQcml2YXRlKGlucHV0LCBUSFJPVFRMRUQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vbmNlKGVsLCBcImJpbmQtZGVib3VuY2VcIikpIHtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBiZWNhdXNlIHdlIHRyaWdnZXIgdGhlIGNhbGxiYWNrIGhlcmUsXG4gICAgICAgICAgICAvLyB3ZSBhbHNvIGNsZWFyIHRoZSB0aHJvdHRsZSB0aW1lb3V0IHRvIHByZXZlbnQgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAvLyBmcm9tIGJlaW5nIGNhbGxlZCBhZ2FpbiBhZnRlciB0aGUgdGltZW91dCBmaXJlc1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucHJpdmF0ZShlbCwgVEhST1RUTEVEKSk7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJDeWNsZShlbCwgREVCT1VOQ0VfVFJJR0dFUik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdHJpZ2dlckN5Y2xlKGVsLCBrZXksIGN1cnJlbnRDeWNsZSkge1xuICAgIGNvbnN0IFtjeWNsZSwgdHJpZ2dlcl0gPSB0aGlzLnByaXZhdGUoZWwsIGtleSk7XG4gICAgaWYgKCFjdXJyZW50Q3ljbGUpIHtcbiAgICAgIGN1cnJlbnRDeWNsZSA9IGN5Y2xlO1xuICAgIH1cbiAgICBpZiAoY3VycmVudEN5Y2xlID09PSBjeWNsZSkge1xuICAgICAgdGhpcy5pbmNDeWNsZShlbCwga2V5KTtcbiAgICAgIHRyaWdnZXIoKTtcbiAgICB9XG4gIH0sXG5cbiAgb25jZShlbCwga2V5KSB7XG4gICAgaWYgKHRoaXMucHJpdmF0ZShlbCwga2V5KSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLnB1dFByaXZhdGUoZWwsIGtleSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgaW5jQ3ljbGUoZWwsIGtleSwgdHJpZ2dlciA9IGZ1bmN0aW9uICgpIHt9KSB7XG4gICAgbGV0IFtjdXJyZW50Q3ljbGVdID0gdGhpcy5wcml2YXRlKGVsLCBrZXkpIHx8IFswLCB0cmlnZ2VyXTtcbiAgICBjdXJyZW50Q3ljbGUrKztcbiAgICB0aGlzLnB1dFByaXZhdGUoZWwsIGtleSwgW2N1cnJlbnRDeWNsZSwgdHJpZ2dlcl0pO1xuICAgIHJldHVybiBjdXJyZW50Q3ljbGU7XG4gIH0sXG5cbiAgLy8gbWFpbnRhaW5zIG9yIGFkZHMgcHJpdmF0ZWx5IHVzZWQgaG9vayBpbmZvcm1hdGlvblxuICAvLyBmcm9tRWwgYW5kIHRvRWwgY2FuIGJlIHRoZSBzYW1lIGVsZW1lbnQgaW4gdGhlIGNhc2Ugb2YgYSBuZXdseSBhZGRlZCBub2RlXG4gIC8vIGZyb21FbCBhbmQgdG9FbCBjYW4gYmUgYW55IEhUTUwgbm9kZSB0eXBlLCBzbyB3ZSBuZWVkIHRvIGNoZWNrIGlmIGl0J3MgYW4gZWxlbWVudCBub2RlXG4gIG1haW50YWluUHJpdmF0ZUhvb2tzKGZyb21FbCwgdG9FbCwgcGh4Vmlld3BvcnRUb3AsIHBoeFZpZXdwb3J0Qm90dG9tKSB7XG4gICAgLy8gbWFpbnRhaW4gdGhlIGhvb2tzIGNyZWF0ZWQgd2l0aCBjcmVhdGVIb29rXG4gICAgaWYgKFxuICAgICAgZnJvbUVsLmhhc0F0dHJpYnV0ZSAmJlxuICAgICAgZnJvbUVsLmhhc0F0dHJpYnV0ZShcImRhdGEtcGh4LWhvb2tcIikgJiZcbiAgICAgICF0b0VsLmhhc0F0dHJpYnV0ZShcImRhdGEtcGh4LWhvb2tcIilcbiAgICApIHtcbiAgICAgIHRvRWwuc2V0QXR0cmlidXRlKFwiZGF0YS1waHgtaG9va1wiLCBmcm9tRWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1waHgtaG9va1wiKSk7XG4gICAgfVxuICAgIC8vIGFkZCBob29rcyB0byBlbGVtZW50cyB3aXRoIHZpZXdwb3J0IGF0dHJpYnV0ZXNcbiAgICBpZiAoXG4gICAgICB0b0VsLmhhc0F0dHJpYnV0ZSAmJlxuICAgICAgKHRvRWwuaGFzQXR0cmlidXRlKHBoeFZpZXdwb3J0VG9wKSB8fFxuICAgICAgICB0b0VsLmhhc0F0dHJpYnV0ZShwaHhWaWV3cG9ydEJvdHRvbSkpXG4gICAgKSB7XG4gICAgICB0b0VsLnNldEF0dHJpYnV0ZShcImRhdGEtcGh4LWhvb2tcIiwgXCJQaG9lbml4LkluZmluaXRlU2Nyb2xsXCIpO1xuICAgIH1cbiAgfSxcblxuICBwdXRDdXN0b21FbEhvb2soZWwsIGhvb2spIHtcbiAgICBpZiAoZWwuaXNDb25uZWN0ZWQpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShcImRhdGEtcGh4LWhvb2tcIiwgXCJcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFxuICAgICAgICBob29rIGF0dGFjaGVkIHRvIG5vbi1jb25uZWN0ZWQgRE9NIGVsZW1lbnRcbiAgICAgICAgZW5zdXJlIHlvdSBhcmUgY2FsbGluZyBjcmVhdGVIb29rIHdpdGhpbiB5b3VyIGNvbm5lY3RlZENhbGxiYWNrLiAke2VsLm91dGVySFRNTH1cbiAgICAgIGApO1xuICAgIH1cbiAgICB0aGlzLnB1dFByaXZhdGUoZWwsIFwiY3VzdG9tLWVsLWhvb2tcIiwgaG9vayk7XG4gIH0sXG5cbiAgZ2V0Q3VzdG9tRWxIb29rKGVsKSB7XG4gICAgcmV0dXJuIHRoaXMucHJpdmF0ZShlbCwgXCJjdXN0b20tZWwtaG9va1wiKTtcbiAgfSxcblxuICBpc1VzZWRJbnB1dChlbCkge1xuICAgIHJldHVybiAoXG4gICAgICBlbC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiZcbiAgICAgICh0aGlzLnByaXZhdGUoZWwsIFBIWF9IQVNfRk9DVVNFRCkgfHwgdGhpcy5wcml2YXRlKGVsLCBQSFhfSEFTX1NVQk1JVFRFRCkpXG4gICAgKTtcbiAgfSxcblxuICByZXNldEZvcm0oZm9ybSkge1xuICAgIEFycmF5LmZyb20oZm9ybS5lbGVtZW50cykuZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICAgIHRoaXMuZGVsZXRlUHJpdmF0ZShpbnB1dCwgUEhYX0hBU19GT0NVU0VEKTtcbiAgICAgIHRoaXMuZGVsZXRlUHJpdmF0ZShpbnB1dCwgUEhYX0hBU19TVUJNSVRURUQpO1xuICAgIH0pO1xuICB9LFxuXG4gIGlzUGh4Q2hpbGQobm9kZSkge1xuICAgIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZShQSFhfUEFSRU5UX0lEKTtcbiAgfSxcblxuICBpc1BoeFN0aWNreShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKFBIWF9TVElDS1kpICE9PSBudWxsO1xuICB9LFxuXG4gIGlzQ2hpbGRPZkFueShlbCwgcGFyZW50cykge1xuICAgIHJldHVybiAhIXBhcmVudHMuZmluZCgocGFyZW50KSA9PiBwYXJlbnQuY29udGFpbnMoZWwpKTtcbiAgfSxcblxuICBmaXJzdFBoeENoaWxkKGVsKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNQaHhDaGlsZChlbCkgPyBlbCA6IHRoaXMuYWxsKGVsLCBgWyR7UEhYX1BBUkVOVF9JRH1dYClbMF07XG4gIH0sXG5cbiAgaXNQb3J0YWxUZW1wbGF0ZShlbCkge1xuICAgIHJldHVybiBlbC50YWdOYW1lID09PSBcIlRFTVBMQVRFXCIgJiYgZWwuaGFzQXR0cmlidXRlKFBIWF9QT1JUQUwpO1xuICB9LFxuXG4gIGNsb3Nlc3RWaWV3RWwoZWwpIHtcbiAgICAvLyBmaW5kIHRoZSBjbG9zZXN0IHBvcnRhbCBvciB2aWV3IGVsZW1lbnQsIHdoaWNoZXZlciBjb21lcyBmaXJzdFxuICAgIGNvbnN0IHBvcnRhbE9yVmlld0VsID0gZWwuY2xvc2VzdChcbiAgICAgIGBbJHtQSFhfVEVMRVBPUlRFRF9SRUZ9XSwke1BIWF9WSUVXX1NFTEVDVE9SfWAsXG4gICAgKTtcbiAgICBpZiAoIXBvcnRhbE9yVmlld0VsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHBvcnRhbE9yVmlld0VsLmhhc0F0dHJpYnV0ZShQSFhfVEVMRVBPUlRFRF9SRUYpKSB7XG4gICAgICAvLyBQSFhfVEVMRVBPUlRFRF9SRUYgaXMgc2V0IHRvIHRoZSBpZCBvZiB0aGUgdmlldyB0aGF0IG93bnMgdGhlIHBvcnRhbCBlbGVtZW50XG4gICAgICByZXR1cm4gdGhpcy5ieUlkKHBvcnRhbE9yVmlld0VsLmdldEF0dHJpYnV0ZShQSFhfVEVMRVBPUlRFRF9SRUYpKTtcbiAgICB9IGVsc2UgaWYgKHBvcnRhbE9yVmlld0VsLmhhc0F0dHJpYnV0ZShQSFhfU0VTU0lPTikpIHtcbiAgICAgIHJldHVybiBwb3J0YWxPclZpZXdFbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgZGlzcGF0Y2hFdmVudCh0YXJnZXQsIG5hbWUsIG9wdHMgPSB7fSkge1xuICAgIGxldCBkZWZhdWx0QnViYmxlID0gdHJ1ZTtcbiAgICBjb25zdCBpc1VwbG9hZFRhcmdldCA9XG4gICAgICB0YXJnZXQubm9kZU5hbWUgPT09IFwiSU5QVVRcIiAmJiB0YXJnZXQudHlwZSA9PT0gXCJmaWxlXCI7XG4gICAgaWYgKGlzVXBsb2FkVGFyZ2V0ICYmIG5hbWUgPT09IFwiY2xpY2tcIikge1xuICAgICAgZGVmYXVsdEJ1YmJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBidWJibGVzID0gb3B0cy5idWJibGVzID09PSB1bmRlZmluZWQgPyBkZWZhdWx0QnViYmxlIDogISFvcHRzLmJ1YmJsZXM7XG4gICAgY29uc3QgZXZlbnRPcHRzID0ge1xuICAgICAgYnViYmxlczogYnViYmxlcyxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBkZXRhaWw6IG9wdHMuZGV0YWlsIHx8IHt9LFxuICAgIH07XG4gICAgY29uc3QgZXZlbnQgPVxuICAgICAgbmFtZSA9PT0gXCJjbGlja1wiXG4gICAgICAgID8gbmV3IE1vdXNlRXZlbnQoXCJjbGlja1wiLCBldmVudE9wdHMpXG4gICAgICAgIDogbmV3IEN1c3RvbUV2ZW50KG5hbWUsIGV2ZW50T3B0cyk7XG4gICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9LFxuXG4gIGNsb25lTm9kZShub2RlLCBodG1sKSB7XG4gICAgaWYgKHR5cGVvZiBodG1sID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gbm9kZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNsb25lZCA9IG5vZGUuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgIGNsb25lZC5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9XG4gIH0sXG5cbiAgLy8gbWVyZ2UgYXR0cmlidXRlcyBmcm9tIHNvdXJjZSB0byB0YXJnZXRcbiAgLy8gaWYgYW4gZWxlbWVudCBpcyBpZ25vcmVkLCB3ZSBvbmx5IG1lcmdlIGRhdGEgYXR0cmlidXRlc1xuICAvLyBpbmNsdWRpbmcgcmVtb3ZpbmcgZGF0YSBhdHRyaWJ1dGVzIHRoYXQgYXJlIG5vIGxvbmdlciBpbiB0aGUgc291cmNlXG4gIG1lcmdlQXR0cnModGFyZ2V0LCBzb3VyY2UsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGV4Y2x1ZGUgPSBuZXcgU2V0KG9wdHMuZXhjbHVkZSB8fCBbXSk7XG4gICAgY29uc3QgaXNJZ25vcmVkID0gb3B0cy5pc0lnbm9yZWQ7XG4gICAgY29uc3Qgc291cmNlQXR0cnMgPSBzb3VyY2UuYXR0cmlidXRlcztcbiAgICBmb3IgKGxldCBpID0gc291cmNlQXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBzb3VyY2VBdHRyc1tpXS5uYW1lO1xuICAgICAgaWYgKCFleGNsdWRlLmhhcyhuYW1lKSkge1xuICAgICAgICBjb25zdCBzb3VyY2VWYWx1ZSA9IHNvdXJjZS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0YXJnZXQuZ2V0QXR0cmlidXRlKG5hbWUpICE9PSBzb3VyY2VWYWx1ZSAmJlxuICAgICAgICAgICghaXNJZ25vcmVkIHx8IChpc0lnbm9yZWQgJiYgbmFtZS5zdGFydHNXaXRoKFwiZGF0YS1cIikpKVxuICAgICAgICApIHtcbiAgICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKG5hbWUsIHNvdXJjZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UgZXhjbHVkZSB0aGUgdmFsdWUgZnJvbSBiZWluZyBtZXJnZWQgb24gZm9jdXNlZCBpbnB1dHMsIGJlY2F1c2UgdGhlXG4gICAgICAgIC8vIHVzZXIncyBpbnB1dCBzaG91bGQgYWx3YXlzIHdpbi5cbiAgICAgICAgLy8gV2UgY2FuIHN0aWxsIGFzc2lnbiBpdCBhcyBsb25nIGFzIHRoZSB2YWx1ZSBwcm9wZXJ0eSBpcyB0aGUgc2FtZSwgdGhvdWdoLlxuICAgICAgICAvLyBUaGlzIHByZXZlbnRzIGEgc2l0dWF0aW9uIHdoZXJlIHRoZSB1cGRhdGVkIGhvb2sgaXMgbm90IGJlaW5nIHRyaWdnZXJlZFxuICAgICAgICAvLyB3aGVuIGFuIGlucHV0IGlzIGJhY2sgaW4gaXRzIFwib3JpZ2luYWwgc3RhdGVcIiwgYmVjYXVzZSB0aGUgYXR0cmlidXRlXG4gICAgICAgIC8vIHdhcyBuZXZlciBjaGFuZ2VkLCBzZWU6XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXhfbGl2ZV92aWV3L2lzc3Vlcy8yMTYzXG4gICAgICAgIGlmIChuYW1lID09PSBcInZhbHVlXCIpIHtcbiAgICAgICAgICBjb25zdCBzb3VyY2VWYWx1ZSA9IHNvdXJjZS52YWx1ZSA/PyBzb3VyY2UuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgICAgIGlmICh0YXJnZXQudmFsdWUgPT09IHNvdXJjZVZhbHVlKSB7XG4gICAgICAgICAgICAvLyBhY3R1YWxseSBzZXQgdGhlIHZhbHVlIGF0dHJpYnV0ZSB0byBzeW5jIGl0IHdpdGggdGhlIHZhbHVlIHByb3BlcnR5XG4gICAgICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgc291cmNlLmdldEF0dHJpYnV0ZShuYW1lKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0QXR0cnMgPSB0YXJnZXQuYXR0cmlidXRlcztcbiAgICBmb3IgKGxldCBpID0gdGFyZ2V0QXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IG5hbWUgPSB0YXJnZXRBdHRyc1tpXS5uYW1lO1xuICAgICAgaWYgKGlzSWdub3JlZCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbmFtZS5zdGFydHNXaXRoKFwiZGF0YS1cIikgJiZcbiAgICAgICAgICAhc291cmNlLmhhc0F0dHJpYnV0ZShuYW1lKSAmJlxuICAgICAgICAgICFQSFhfUEVORElOR19BVFRSUy5pbmNsdWRlcyhuYW1lKVxuICAgICAgICApIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXNvdXJjZS5oYXNBdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIG1lcmdlRm9jdXNlZElucHV0KHRhcmdldCwgc291cmNlKSB7XG4gICAgLy8gc2tpcCBzZWxlY3RzIGJlY2F1c2UgRkYgd2lsbCByZXNldCBoaWdobGlnaHRlZCBpbmRleCBmb3IgYW55IHNldEF0dHJpYnV0ZVxuICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxTZWxlY3RFbGVtZW50KSkge1xuICAgICAgRE9NLm1lcmdlQXR0cnModGFyZ2V0LCBzb3VyY2UsIHsgZXhjbHVkZTogW1widmFsdWVcIl0gfSk7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZS5yZWFkT25seSkge1xuICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcInJlYWRvbmx5XCIsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwicmVhZG9ubHlcIik7XG4gICAgfVxuICB9LFxuXG4gIGhhc1NlbGVjdGlvblJhbmdlKGVsKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGVsLnNldFNlbGVjdGlvblJhbmdlICYmIChlbC50eXBlID09PSBcInRleHRcIiB8fCBlbC50eXBlID09PSBcInRleHRhcmVhXCIpXG4gICAgKTtcbiAgfSxcblxuICByZXN0b3JlRm9jdXMoZm9jdXNlZCwgc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCkge1xuICAgIGlmIChmb2N1c2VkIGluc3RhbmNlb2YgSFRNTFNlbGVjdEVsZW1lbnQpIHtcbiAgICAgIGZvY3VzZWQuZm9jdXMoKTtcbiAgICB9XG4gICAgaWYgKCFET00uaXNUZXh0dWFsSW5wdXQoZm9jdXNlZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB3YXNGb2N1c2VkID0gZm9jdXNlZC5tYXRjaGVzKFwiOmZvY3VzXCIpO1xuICAgIGlmICghd2FzRm9jdXNlZCkge1xuICAgICAgZm9jdXNlZC5mb2N1cygpO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNTZWxlY3Rpb25SYW5nZShmb2N1c2VkKSkge1xuICAgICAgZm9jdXNlZC5zZXRTZWxlY3Rpb25SYW5nZShzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKTtcbiAgICB9XG4gIH0sXG5cbiAgaXNGb3JtSW5wdXQoZWwpIHtcbiAgICBpZiAoZWwubG9jYWxOYW1lICYmIGN1c3RvbUVsZW1lbnRzLmdldChlbC5sb2NhbE5hbWUpKSB7XG4gICAgICAvLyBDdXN0b20gRWxlbWVudHMgbWF5IGJlIGZvcm0gYXNzb2NpYXRlZC4gVGhpcyBhbGxvd3MgdGhlbVxuICAgICAgLy8gdG8gcGFydGljaXBhdGUgd2l0aGluIGEgZm9ybSdzIGxpZmVjeWNsZSwgaW5jbHVkaW5nIGZvcm1cbiAgICAgIC8vIHZhbGlkaXR5IGFuZCBmb3JtIHN1Ym1pc3Npb25zLlxuICAgICAgLy8gVGhlIHNwZWMgZm9yIEZvcm0gQXNzb2NpYXRlZCBjdXN0b20gZWxlbWVudHMgcmVxdWlyZXMgdGhlXG4gICAgICAvLyBjdXN0b20gZWxlbWVudCdzIGNsYXNzIHRvIGNvbnRhaW4gYSBzdGF0aWMgYm9vbGVhbiB2YWx1ZSBvZiBgZm9ybUFzc29jaWF0ZWRgXG4gICAgICAvLyB3aGljaCBpZGVudGlmaWVzIHRoaXMgY2xhc3MgYXMgYWxsb3dlZCB0byBhc3NvY2lhdGUgdG8gYSBmb3JtLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvZGV2L2N1c3RvbS1lbGVtZW50cy5odG1sI2N1c3RvbS1lbGVtZW50cy1mYWNlLWV4YW1wbGVcbiAgICAgIC8vIGZvciBkZXRhaWxzLlxuICAgICAgcmV0dXJuIGN1c3RvbUVsZW1lbnRzLmdldChlbC5sb2NhbE5hbWUpW2Bmb3JtQXNzb2NpYXRlZGBdO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYSkkL2kudGVzdChlbC50YWdOYW1lKSAmJiBlbC50eXBlICE9PSBcImJ1dHRvblwiXG4gICAgKTtcbiAgfSxcblxuICBzeW5jQXR0cnNUb1Byb3BzKGVsKSB7XG4gICAgaWYgKFxuICAgICAgZWwgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50ICYmXG4gICAgICBDSEVDS0FCTEVfSU5QVVRTLmluZGV4T2YoZWwudHlwZS50b0xvY2FsZUxvd2VyQ2FzZSgpKSA+PSAwXG4gICAgKSB7XG4gICAgICBlbC5jaGVja2VkID0gZWwuZ2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiKSAhPT0gbnVsbDtcbiAgICB9XG4gIH0sXG5cbiAgaXNUZXh0dWFsSW5wdXQoZWwpIHtcbiAgICByZXR1cm4gRk9DVVNBQkxFX0lOUFVUUy5pbmRleE9mKGVsLnR5cGUpID49IDA7XG4gIH0sXG5cbiAgaXNOb3dUcmlnZ2VyRm9ybUV4dGVybmFsKGVsLCBwaHhUcmlnZ2VyRXh0ZXJuYWwpIHtcbiAgICByZXR1cm4gKFxuICAgICAgZWwuZ2V0QXR0cmlidXRlICYmXG4gICAgICBlbC5nZXRBdHRyaWJ1dGUocGh4VHJpZ2dlckV4dGVybmFsKSAhPT0gbnVsbCAmJlxuICAgICAgZG9jdW1lbnQuYm9keS5jb250YWlucyhlbClcbiAgICApO1xuICB9LFxuXG4gIGNsZWFuQ2hpbGROb2Rlcyhjb250YWluZXIsIHBoeFVwZGF0ZSkge1xuICAgIGlmIChcbiAgICAgIERPTS5pc1BoeFVwZGF0ZShjb250YWluZXIsIHBoeFVwZGF0ZSwgW1wiYXBwZW5kXCIsIFwicHJlcGVuZFwiLCBQSFhfU1RSRUFNXSlcbiAgICApIHtcbiAgICAgIGNvbnN0IHRvUmVtb3ZlID0gW107XG4gICAgICBjb250YWluZXIuY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZE5vZGUpID0+IHtcbiAgICAgICAgaWYgKCFjaGlsZE5vZGUuaWQpIHtcbiAgICAgICAgICAvLyBTa2lwIHdhcm5pbmcgaWYgaXQncyBhbiBlbXB0eSB0ZXh0IG5vZGUgKGUuZy4gYSBuZXctbGluZSlcbiAgICAgICAgICBjb25zdCBpc0VtcHR5VGV4dE5vZGUgPVxuICAgICAgICAgICAgY2hpbGROb2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSAmJlxuICAgICAgICAgICAgY2hpbGROb2RlLm5vZGVWYWx1ZS50cmltKCkgPT09IFwiXCI7XG4gICAgICAgICAgaWYgKCFpc0VtcHR5VGV4dE5vZGUgJiYgY2hpbGROb2RlLm5vZGVUeXBlICE9PSBOb2RlLkNPTU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgbG9nRXJyb3IoXG4gICAgICAgICAgICAgIFwib25seSBIVE1MIGVsZW1lbnQgdGFncyB3aXRoIGFuIGlkIGFyZSBhbGxvd2VkIGluc2lkZSBjb250YWluZXJzIHdpdGggcGh4LXVwZGF0ZS5cXG5cXG5cIiArXG4gICAgICAgICAgICAgICAgYHJlbW92aW5nIGlsbGVnYWwgbm9kZTogXCIkeyhjaGlsZE5vZGUub3V0ZXJIVE1MIHx8IGNoaWxkTm9kZS5ub2RlVmFsdWUpLnRyaW0oKX1cIlxcblxcbmAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b1JlbW92ZS5wdXNoKGNoaWxkTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdG9SZW1vdmUuZm9yRWFjaCgoY2hpbGROb2RlKSA9PiBjaGlsZE5vZGUucmVtb3ZlKCkpO1xuICAgIH1cbiAgfSxcblxuICByZXBsYWNlUm9vdENvbnRhaW5lcihjb250YWluZXIsIHRhZ05hbWUsIGF0dHJzKSB7XG4gICAgY29uc3QgcmV0YWluZWRBdHRycyA9IG5ldyBTZXQoW1xuICAgICAgXCJpZFwiLFxuICAgICAgUEhYX1NFU1NJT04sXG4gICAgICBQSFhfU1RBVElDLFxuICAgICAgUEhYX01BSU4sXG4gICAgICBQSFhfUk9PVF9JRCxcbiAgICBdKTtcbiAgICBpZiAoY29udGFpbmVyLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBBcnJheS5mcm9tKGNvbnRhaW5lci5hdHRyaWJ1dGVzKVxuICAgICAgICAuZmlsdGVyKChhdHRyKSA9PiAhcmV0YWluZWRBdHRycy5oYXMoYXR0ci5uYW1lLnRvTG93ZXJDYXNlKCkpKVxuICAgICAgICAuZm9yRWFjaCgoYXR0cikgPT4gY29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZShhdHRyLm5hbWUpKTtcblxuICAgICAgT2JqZWN0LmtleXMoYXR0cnMpXG4gICAgICAgIC5maWx0ZXIoKG5hbWUpID0+ICFyZXRhaW5lZEF0dHJzLmhhcyhuYW1lLnRvTG93ZXJDYXNlKCkpKVxuICAgICAgICAuZm9yRWFjaCgoYXR0cikgPT4gY29udGFpbmVyLnNldEF0dHJpYnV0ZShhdHRyLCBhdHRyc1thdHRyXSkpO1xuXG4gICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuZXdDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goKGF0dHIpID0+XG4gICAgICAgIG5ld0NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoYXR0ciwgYXR0cnNbYXR0cl0pLFxuICAgICAgKTtcbiAgICAgIHJldGFpbmVkQXR0cnMuZm9yRWFjaCgoYXR0cikgPT5cbiAgICAgICAgbmV3Q29udGFpbmVyLnNldEF0dHJpYnV0ZShhdHRyLCBjb250YWluZXIuZ2V0QXR0cmlidXRlKGF0dHIpKSxcbiAgICAgICk7XG4gICAgICBuZXdDb250YWluZXIuaW5uZXJIVE1MID0gY29udGFpbmVyLmlubmVySFRNTDtcbiAgICAgIGNvbnRhaW5lci5yZXBsYWNlV2l0aChuZXdDb250YWluZXIpO1xuICAgICAgcmV0dXJuIG5ld0NvbnRhaW5lcjtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0U3RpY2t5KGVsLCBuYW1lLCBkZWZhdWx0VmFsKSB7XG4gICAgY29uc3Qgb3AgPSAoRE9NLnByaXZhdGUoZWwsIFwic3RpY2t5XCIpIHx8IFtdKS5maW5kKFxuICAgICAgKFtleGlzdGluZ05hbWVdKSA9PiBuYW1lID09PSBleGlzdGluZ05hbWUsXG4gICAgKTtcbiAgICBpZiAob3ApIHtcbiAgICAgIGNvbnN0IFtfbmFtZSwgX29wLCBzdGFzaGVkUmVzdWx0XSA9IG9wO1xuICAgICAgcmV0dXJuIHN0YXNoZWRSZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZGVmYXVsdFZhbCA9PT0gXCJmdW5jdGlvblwiID8gZGVmYXVsdFZhbCgpIDogZGVmYXVsdFZhbDtcbiAgICB9XG4gIH0sXG5cbiAgZGVsZXRlU3RpY2t5KGVsLCBuYW1lKSB7XG4gICAgdGhpcy51cGRhdGVQcml2YXRlKGVsLCBcInN0aWNreVwiLCBbXSwgKG9wcykgPT4ge1xuICAgICAgcmV0dXJuIG9wcy5maWx0ZXIoKFtleGlzdGluZ05hbWUsIF9dKSA9PiBleGlzdGluZ05hbWUgIT09IG5hbWUpO1xuICAgIH0pO1xuICB9LFxuXG4gIHB1dFN0aWNreShlbCwgbmFtZSwgb3ApIHtcbiAgICBjb25zdCBzdGFzaGVkUmVzdWx0ID0gb3AoZWwpO1xuICAgIHRoaXMudXBkYXRlUHJpdmF0ZShlbCwgXCJzdGlja3lcIiwgW10sIChvcHMpID0+IHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nSW5kZXggPSBvcHMuZmluZEluZGV4KFxuICAgICAgICAoW2V4aXN0aW5nTmFtZV0pID0+IG5hbWUgPT09IGV4aXN0aW5nTmFtZSxcbiAgICAgICk7XG4gICAgICBpZiAoZXhpc3RpbmdJbmRleCA+PSAwKSB7XG4gICAgICAgIG9wc1tleGlzdGluZ0luZGV4XSA9IFtuYW1lLCBvcCwgc3Rhc2hlZFJlc3VsdF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHMucHVzaChbbmFtZSwgb3AsIHN0YXNoZWRSZXN1bHRdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHM7XG4gICAgfSk7XG4gIH0sXG5cbiAgYXBwbHlTdGlja3lPcGVyYXRpb25zKGVsKSB7XG4gICAgY29uc3Qgb3BzID0gRE9NLnByaXZhdGUoZWwsIFwic3RpY2t5XCIpO1xuICAgIGlmICghb3BzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3BzLmZvckVhY2goKFtuYW1lLCBvcCwgX3N0YXNoZWRdKSA9PiB0aGlzLnB1dFN0aWNreShlbCwgbmFtZSwgb3ApKTtcbiAgfSxcblxuICBpc0xvY2tlZChlbCkge1xuICAgIHJldHVybiBlbC5oYXNBdHRyaWJ1dGUgJiYgZWwuaGFzQXR0cmlidXRlKFBIWF9SRUZfTE9DSyk7XG4gIH0sXG5cbiAgYXR0cmlidXRlSWdub3JlZChhdHRyaWJ1dGUsIGlnbm9yZWRBdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIGlnbm9yZWRBdHRyaWJ1dGVzLnNvbWUoXG4gICAgICAodG9JZ25vcmUpID0+XG4gICAgICAgIGF0dHJpYnV0ZS5uYW1lID09IHRvSWdub3JlIHx8XG4gICAgICAgIHRvSWdub3JlID09PSBcIipcIiB8fFxuICAgICAgICAodG9JZ25vcmUuaW5jbHVkZXMoXCIqXCIpICYmIGF0dHJpYnV0ZS5uYW1lLm1hdGNoKHRvSWdub3JlKSAhPSBudWxsKSxcbiAgICApO1xuICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgRE9NO1xuIiwgImltcG9ydCB7XG4gIFBIWF9BQ1RJVkVfRU5UUllfUkVGUyxcbiAgUEhYX0xJVkVfRklMRV9VUERBVEVELFxuICBQSFhfUFJFRkxJR0hURURfUkVGUyxcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5cbmltcG9ydCB7IGNoYW5uZWxVcGxvYWRlciwgbG9nRXJyb3IgfSBmcm9tIFwiLi91dGlsc1wiO1xuXG5pbXBvcnQgTGl2ZVVwbG9hZGVyIGZyb20gXCIuL2xpdmVfdXBsb2FkZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVXBsb2FkRW50cnkge1xuICBzdGF0aWMgaXNBY3RpdmUoZmlsZUVsLCBmaWxlKSB7XG4gICAgY29uc3QgaXNOZXcgPSBmaWxlLl9waHhSZWYgPT09IHVuZGVmaW5lZDtcbiAgICBjb25zdCBhY3RpdmVSZWZzID0gZmlsZUVsLmdldEF0dHJpYnV0ZShQSFhfQUNUSVZFX0VOVFJZX1JFRlMpLnNwbGl0KFwiLFwiKTtcbiAgICBjb25zdCBpc0FjdGl2ZSA9IGFjdGl2ZVJlZnMuaW5kZXhPZihMaXZlVXBsb2FkZXIuZ2VuRmlsZVJlZihmaWxlKSkgPj0gMDtcbiAgICByZXR1cm4gZmlsZS5zaXplID4gMCAmJiAoaXNOZXcgfHwgaXNBY3RpdmUpO1xuICB9XG5cbiAgc3RhdGljIGlzUHJlZmxpZ2h0ZWQoZmlsZUVsLCBmaWxlKSB7XG4gICAgY29uc3QgcHJlZmxpZ2h0ZWRSZWZzID0gZmlsZUVsXG4gICAgICAuZ2V0QXR0cmlidXRlKFBIWF9QUkVGTElHSFRFRF9SRUZTKVxuICAgICAgLnNwbGl0KFwiLFwiKTtcbiAgICBjb25zdCBpc1ByZWZsaWdodGVkID1cbiAgICAgIHByZWZsaWdodGVkUmVmcy5pbmRleE9mKExpdmVVcGxvYWRlci5nZW5GaWxlUmVmKGZpbGUpKSA+PSAwO1xuICAgIHJldHVybiBpc1ByZWZsaWdodGVkICYmIHRoaXMuaXNBY3RpdmUoZmlsZUVsLCBmaWxlKTtcbiAgfVxuXG4gIHN0YXRpYyBpc1ByZWZsaWdodEluUHJvZ3Jlc3MoZmlsZSkge1xuICAgIHJldHVybiBmaWxlLl9wcmVmbGlnaHRJblByb2dyZXNzID09PSB0cnVlO1xuICB9XG5cbiAgc3RhdGljIG1hcmtQcmVmbGlnaHRJblByb2dyZXNzKGZpbGUpIHtcbiAgICBmaWxlLl9wcmVmbGlnaHRJblByb2dyZXNzID0gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGZpbGVFbCwgZmlsZSwgdmlldywgYXV0b1VwbG9hZCkge1xuICAgIHRoaXMucmVmID0gTGl2ZVVwbG9hZGVyLmdlbkZpbGVSZWYoZmlsZSk7XG4gICAgdGhpcy5maWxlRWwgPSBmaWxlRWw7XG4gICAgdGhpcy5maWxlID0gZmlsZTtcbiAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgIHRoaXMubWV0YSA9IG51bGw7XG4gICAgdGhpcy5faXNDYW5jZWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9pc0RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9wcm9ncmVzcyA9IDA7XG4gICAgdGhpcy5fbGFzdFByb2dyZXNzU2VudCA9IC0xO1xuICAgIHRoaXMuX29uRG9uZSA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIHRoaXMuX29uRWxVcGRhdGVkID0gdGhpcy5vbkVsVXBkYXRlZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZmlsZUVsLmFkZEV2ZW50TGlzdGVuZXIoUEhYX0xJVkVfRklMRV9VUERBVEVELCB0aGlzLl9vbkVsVXBkYXRlZCk7XG4gICAgdGhpcy5hdXRvVXBsb2FkID0gYXV0b1VwbG9hZDtcbiAgfVxuXG4gIG1ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLm1ldGE7XG4gIH1cblxuICBwcm9ncmVzcyhwcm9ncmVzcykge1xuICAgIHRoaXMuX3Byb2dyZXNzID0gTWF0aC5mbG9vcihwcm9ncmVzcyk7XG4gICAgaWYgKHRoaXMuX3Byb2dyZXNzID4gdGhpcy5fbGFzdFByb2dyZXNzU2VudCkge1xuICAgICAgaWYgKHRoaXMuX3Byb2dyZXNzID49IDEwMCkge1xuICAgICAgICB0aGlzLl9wcm9ncmVzcyA9IDEwMDtcbiAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzU2VudCA9IDEwMDtcbiAgICAgICAgdGhpcy5faXNEb25lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52aWV3LnB1c2hGaWxlUHJvZ3Jlc3ModGhpcy5maWxlRWwsIHRoaXMucmVmLCAxMDAsICgpID0+IHtcbiAgICAgICAgICBMaXZlVXBsb2FkZXIudW50cmFja0ZpbGUodGhpcy5maWxlRWwsIHRoaXMuZmlsZSk7XG4gICAgICAgICAgdGhpcy5fb25Eb25lKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzU2VudCA9IHRoaXMuX3Byb2dyZXNzO1xuICAgICAgICB0aGlzLnZpZXcucHVzaEZpbGVQcm9ncmVzcyh0aGlzLmZpbGVFbCwgdGhpcy5yZWYsIHRoaXMuX3Byb2dyZXNzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpc0NhbmNlbGxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNDYW5jZWxsZWQ7XG4gIH1cblxuICBjYW5jZWwoKSB7XG4gICAgdGhpcy5maWxlLl9wcmVmbGlnaHRJblByb2dyZXNzID0gZmFsc2U7XG4gICAgdGhpcy5faXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgIHRoaXMuX2lzRG9uZSA9IHRydWU7XG4gICAgdGhpcy5fb25Eb25lKCk7XG4gIH1cblxuICBpc0RvbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzRG9uZTtcbiAgfVxuXG4gIGVycm9yKHJlYXNvbiA9IFwiZmFpbGVkXCIpIHtcbiAgICB0aGlzLmZpbGVFbC5yZW1vdmVFdmVudExpc3RlbmVyKFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCwgdGhpcy5fb25FbFVwZGF0ZWQpO1xuICAgIHRoaXMudmlldy5wdXNoRmlsZVByb2dyZXNzKHRoaXMuZmlsZUVsLCB0aGlzLnJlZiwgeyBlcnJvcjogcmVhc29uIH0pO1xuICAgIGlmICghdGhpcy5pc0F1dG9VcGxvYWQoKSkge1xuICAgICAgTGl2ZVVwbG9hZGVyLmNsZWFyRmlsZXModGhpcy5maWxlRWwpO1xuICAgIH1cbiAgfVxuXG4gIGlzQXV0b1VwbG9hZCgpIHtcbiAgICByZXR1cm4gdGhpcy5hdXRvVXBsb2FkO1xuICB9XG5cbiAgLy9wcml2YXRlXG5cbiAgb25Eb25lKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fb25Eb25lID0gKCkgPT4ge1xuICAgICAgdGhpcy5maWxlRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihQSFhfTElWRV9GSUxFX1VQREFURUQsIHRoaXMuX29uRWxVcGRhdGVkKTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfTtcbiAgfVxuXG4gIG9uRWxVcGRhdGVkKCkge1xuICAgIGNvbnN0IGFjdGl2ZVJlZnMgPSB0aGlzLmZpbGVFbFxuICAgICAgLmdldEF0dHJpYnV0ZShQSFhfQUNUSVZFX0VOVFJZX1JFRlMpXG4gICAgICAuc3BsaXQoXCIsXCIpO1xuICAgIGlmIChhY3RpdmVSZWZzLmluZGV4T2YodGhpcy5yZWYpID09PSAtMSkge1xuICAgICAgTGl2ZVVwbG9hZGVyLnVudHJhY2tGaWxlKHRoaXMuZmlsZUVsLCB0aGlzLmZpbGUpO1xuICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICB9XG4gIH1cblxuICB0b1ByZWZsaWdodFBheWxvYWQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhc3RfbW9kaWZpZWQ6IHRoaXMuZmlsZS5sYXN0TW9kaWZpZWQsXG4gICAgICBuYW1lOiB0aGlzLmZpbGUubmFtZSxcbiAgICAgIHJlbGF0aXZlX3BhdGg6IHRoaXMuZmlsZS53ZWJraXRSZWxhdGl2ZVBhdGgsXG4gICAgICBzaXplOiB0aGlzLmZpbGUuc2l6ZSxcbiAgICAgIHR5cGU6IHRoaXMuZmlsZS50eXBlLFxuICAgICAgcmVmOiB0aGlzLnJlZixcbiAgICAgIG1ldGE6IHR5cGVvZiB0aGlzLmZpbGUubWV0YSA9PT0gXCJmdW5jdGlvblwiID8gdGhpcy5maWxlLm1ldGEoKSA6IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9XG5cbiAgdXBsb2FkZXIodXBsb2FkZXJzKSB7XG4gICAgaWYgKHRoaXMubWV0YS51cGxvYWRlcikge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPVxuICAgICAgICB1cGxvYWRlcnNbdGhpcy5tZXRhLnVwbG9hZGVyXSB8fFxuICAgICAgICBsb2dFcnJvcihgbm8gdXBsb2FkZXIgY29uZmlndXJlZCBmb3IgJHt0aGlzLm1ldGEudXBsb2FkZXJ9YCk7XG4gICAgICByZXR1cm4geyBuYW1lOiB0aGlzLm1ldGEudXBsb2FkZXIsIGNhbGxiYWNrOiBjYWxsYmFjayB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyBuYW1lOiBcImNoYW5uZWxcIiwgY2FsbGJhY2s6IGNoYW5uZWxVcGxvYWRlciB9O1xuICAgIH1cbiAgfVxuXG4gIHppcFBvc3RGbGlnaHQocmVzcCkge1xuICAgIHRoaXMubWV0YSA9IHJlc3AuZW50cmllc1t0aGlzLnJlZl07XG4gICAgaWYgKCF0aGlzLm1ldGEpIHtcbiAgICAgIGxvZ0Vycm9yKGBubyBwcmVmbGlnaHQgdXBsb2FkIHJlc3BvbnNlIHJldHVybmVkIHdpdGggcmVmICR7dGhpcy5yZWZ9YCwge1xuICAgICAgICBpbnB1dDogdGhpcy5maWxlRWwsXG4gICAgICAgIHJlc3BvbnNlOiByZXNwLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgUEhYX0RPTkVfUkVGUyxcbiAgUEhYX1BSRUZMSUdIVEVEX1JFRlMsXG4gIFBIWF9VUExPQURfUkVGLFxufSBmcm9tIFwiLi9jb25zdGFudHNcIjtcblxuaW1wb3J0IHt9IGZyb20gXCIuL3V0aWxzXCI7XG5cbmltcG9ydCBET00gZnJvbSBcIi4vZG9tXCI7XG5pbXBvcnQgVXBsb2FkRW50cnkgZnJvbSBcIi4vdXBsb2FkX2VudHJ5XCI7XG5cbmxldCBsaXZlVXBsb2FkZXJGaWxlUmVmID0gMDtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGl2ZVVwbG9hZGVyIHtcbiAgc3RhdGljIGdlbkZpbGVSZWYoZmlsZSkge1xuICAgIGNvbnN0IHJlZiA9IGZpbGUuX3BoeFJlZjtcbiAgICBpZiAocmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiByZWY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbGUuX3BoeFJlZiA9IChsaXZlVXBsb2FkZXJGaWxlUmVmKyspLnRvU3RyaW5nKCk7XG4gICAgICByZXR1cm4gZmlsZS5fcGh4UmVmO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXRFbnRyeURhdGFVUkwoaW5wdXRFbCwgcmVmLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGZpbGUgPSB0aGlzLmFjdGl2ZUZpbGVzKGlucHV0RWwpLmZpbmQoXG4gICAgICAoZmlsZSkgPT4gdGhpcy5nZW5GaWxlUmVmKGZpbGUpID09PSByZWYsXG4gICAgKTtcbiAgICBjYWxsYmFjayhVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpKTtcbiAgfVxuXG4gIHN0YXRpYyBoYXNVcGxvYWRzSW5Qcm9ncmVzcyhmb3JtRWwpIHtcbiAgICBsZXQgYWN0aXZlID0gMDtcbiAgICBET00uZmluZFVwbG9hZElucHV0cyhmb3JtRWwpLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIGlucHV0LmdldEF0dHJpYnV0ZShQSFhfUFJFRkxJR0hURURfUkVGUykgIT09XG4gICAgICAgIGlucHV0LmdldEF0dHJpYnV0ZShQSFhfRE9ORV9SRUZTKVxuICAgICAgKSB7XG4gICAgICAgIGFjdGl2ZSsrO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBhY3RpdmUgPiAwO1xuICB9XG5cbiAgc3RhdGljIHNlcmlhbGl6ZVVwbG9hZHMoaW5wdXRFbCkge1xuICAgIGNvbnN0IGZpbGVzID0gdGhpcy5hY3RpdmVGaWxlcyhpbnB1dEVsKTtcbiAgICBjb25zdCBmaWxlRGF0YSA9IHt9O1xuICAgIGZpbGVzLmZvckVhY2goKGZpbGUpID0+IHtcbiAgICAgIGNvbnN0IGVudHJ5ID0geyBwYXRoOiBpbnB1dEVsLm5hbWUgfTtcbiAgICAgIGNvbnN0IHVwbG9hZFJlZiA9IGlucHV0RWwuZ2V0QXR0cmlidXRlKFBIWF9VUExPQURfUkVGKTtcbiAgICAgIGZpbGVEYXRhW3VwbG9hZFJlZl0gPSBmaWxlRGF0YVt1cGxvYWRSZWZdIHx8IFtdO1xuICAgICAgZW50cnkucmVmID0gdGhpcy5nZW5GaWxlUmVmKGZpbGUpO1xuICAgICAgZW50cnkubGFzdF9tb2RpZmllZCA9IGZpbGUubGFzdE1vZGlmaWVkO1xuICAgICAgZW50cnkubmFtZSA9IGZpbGUubmFtZSB8fCBlbnRyeS5yZWY7XG4gICAgICBlbnRyeS5yZWxhdGl2ZV9wYXRoID0gZmlsZS53ZWJraXRSZWxhdGl2ZVBhdGg7XG4gICAgICBlbnRyeS50eXBlID0gZmlsZS50eXBlO1xuICAgICAgZW50cnkuc2l6ZSA9IGZpbGUuc2l6ZTtcbiAgICAgIGlmICh0eXBlb2YgZmlsZS5tZXRhID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZW50cnkubWV0YSA9IGZpbGUubWV0YSgpO1xuICAgICAgfVxuICAgICAgZmlsZURhdGFbdXBsb2FkUmVmXS5wdXNoKGVudHJ5KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZmlsZURhdGE7XG4gIH1cblxuICBzdGF0aWMgY2xlYXJGaWxlcyhpbnB1dEVsKSB7XG4gICAgaW5wdXRFbC52YWx1ZSA9IG51bGw7XG4gICAgaW5wdXRFbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpO1xuICAgIERPTS5wdXRQcml2YXRlKGlucHV0RWwsIFwiZmlsZXNcIiwgW10pO1xuICB9XG5cbiAgc3RhdGljIHVudHJhY2tGaWxlKGlucHV0RWwsIGZpbGUpIHtcbiAgICBET00ucHV0UHJpdmF0ZShcbiAgICAgIGlucHV0RWwsXG4gICAgICBcImZpbGVzXCIsXG4gICAgICBET00ucHJpdmF0ZShpbnB1dEVsLCBcImZpbGVzXCIpLmZpbHRlcigoZikgPT4gIU9iamVjdC5pcyhmLCBmaWxlKSksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0RWxcbiAgICogQHBhcmFtIHtBcnJheTxGaWxlfEJsb2I+fSBmaWxlc1xuICAgKiBAcGFyYW0ge0RhdGFUcmFuc2Zlcn0gW2RhdGFUcmFuc2Zlcl1cbiAgICovXG4gIHN0YXRpYyB0cmFja0ZpbGVzKGlucHV0RWwsIGZpbGVzLCBkYXRhVHJhbnNmZXIpIHtcbiAgICBpZiAoaW5wdXRFbC5nZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgbmV3RmlsZXMgPSBmaWxlcy5maWx0ZXIoXG4gICAgICAgIChmaWxlKSA9PiAhdGhpcy5hY3RpdmVGaWxlcyhpbnB1dEVsKS5maW5kKChmKSA9PiBPYmplY3QuaXMoZiwgZmlsZSkpLFxuICAgICAgKTtcbiAgICAgIERPTS51cGRhdGVQcml2YXRlKGlucHV0RWwsIFwiZmlsZXNcIiwgW10sIChleGlzdGluZykgPT5cbiAgICAgICAgZXhpc3RpbmcuY29uY2F0KG5ld0ZpbGVzKSxcbiAgICAgICk7XG4gICAgICBpbnB1dEVsLnZhbHVlID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVzZXQgaW5wdXRFbCBmaWxlcyB0byBhbGlnbiBvdXRwdXQgd2l0aCBwcm9ncmFtbWF0aWMgY2hhbmdlcyAoaS5lLiBkcmFnIGFuZCBkcm9wKVxuICAgICAgaWYgKGRhdGFUcmFuc2ZlciAmJiBkYXRhVHJhbnNmZXIuZmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBpbnB1dEVsLmZpbGVzID0gZGF0YVRyYW5zZmVyLmZpbGVzO1xuICAgICAgfVxuICAgICAgRE9NLnB1dFByaXZhdGUoaW5wdXRFbCwgXCJmaWxlc1wiLCBmaWxlcyk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGFjdGl2ZUZpbGVJbnB1dHMoZm9ybUVsKSB7XG4gICAgY29uc3QgZmlsZUlucHV0cyA9IERPTS5maW5kVXBsb2FkSW5wdXRzKGZvcm1FbCk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oZmlsZUlucHV0cykuZmlsdGVyKFxuICAgICAgKGVsKSA9PiBlbC5maWxlcyAmJiB0aGlzLmFjdGl2ZUZpbGVzKGVsKS5sZW5ndGggPiAwLFxuICAgICk7XG4gIH1cblxuICBzdGF0aWMgYWN0aXZlRmlsZXMoaW5wdXQpIHtcbiAgICByZXR1cm4gKERPTS5wcml2YXRlKGlucHV0LCBcImZpbGVzXCIpIHx8IFtdKS5maWx0ZXIoKGYpID0+XG4gICAgICBVcGxvYWRFbnRyeS5pc0FjdGl2ZShpbnB1dCwgZiksXG4gICAgKTtcbiAgfVxuXG4gIHN0YXRpYyBpbnB1dHNBd2FpdGluZ1ByZWZsaWdodChmb3JtRWwpIHtcbiAgICBjb25zdCBmaWxlSW5wdXRzID0gRE9NLmZpbmRVcGxvYWRJbnB1dHMoZm9ybUVsKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShmaWxlSW5wdXRzKS5maWx0ZXIoXG4gICAgICAoaW5wdXQpID0+IHRoaXMuZmlsZXNBd2FpdGluZ1ByZWZsaWdodChpbnB1dCkubGVuZ3RoID4gMCxcbiAgICApO1xuICB9XG5cbiAgc3RhdGljIGZpbGVzQXdhaXRpbmdQcmVmbGlnaHQoaW5wdXQpIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVGaWxlcyhpbnB1dCkuZmlsdGVyKFxuICAgICAgKGYpID0+XG4gICAgICAgICFVcGxvYWRFbnRyeS5pc1ByZWZsaWdodGVkKGlucHV0LCBmKSAmJlxuICAgICAgICAhVXBsb2FkRW50cnkuaXNQcmVmbGlnaHRJblByb2dyZXNzKGYpLFxuICAgICk7XG4gIH1cblxuICBzdGF0aWMgbWFya1ByZWZsaWdodEluUHJvZ3Jlc3MoZW50cmllcykge1xuICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IFVwbG9hZEVudHJ5Lm1hcmtQcmVmbGlnaHRJblByb2dyZXNzKGVudHJ5LmZpbGUpKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGlucHV0RWwsIHZpZXcsIG9uQ29tcGxldGUpIHtcbiAgICB0aGlzLmF1dG9VcGxvYWQgPSBET00uaXNBdXRvVXBsb2FkKGlucHV0RWwpO1xuICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgdGhpcy5vbkNvbXBsZXRlID0gb25Db21wbGV0ZTtcbiAgICB0aGlzLl9lbnRyaWVzID0gQXJyYXkuZnJvbShcbiAgICAgIExpdmVVcGxvYWRlci5maWxlc0F3YWl0aW5nUHJlZmxpZ2h0KGlucHV0RWwpIHx8IFtdLFxuICAgICkubWFwKChmaWxlKSA9PiBuZXcgVXBsb2FkRW50cnkoaW5wdXRFbCwgZmlsZSwgdmlldywgdGhpcy5hdXRvVXBsb2FkKSk7XG5cbiAgICAvLyBwcmV2ZW50IHNlbmRpbmcgZHVwbGljYXRlIHByZWZsaWdodCByZXF1ZXN0c1xuICAgIExpdmVVcGxvYWRlci5tYXJrUHJlZmxpZ2h0SW5Qcm9ncmVzcyh0aGlzLl9lbnRyaWVzKTtcblxuICAgIHRoaXMubnVtRW50cmllc0luUHJvZ3Jlc3MgPSB0aGlzLl9lbnRyaWVzLmxlbmd0aDtcbiAgfVxuXG4gIGlzQXV0b1VwbG9hZCgpIHtcbiAgICByZXR1cm4gdGhpcy5hdXRvVXBsb2FkO1xuICB9XG5cbiAgZW50cmllcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZW50cmllcztcbiAgfVxuXG4gIGluaXRBZGFwdGVyVXBsb2FkKHJlc3AsIG9uRXJyb3IsIGxpdmVTb2NrZXQpIHtcbiAgICB0aGlzLl9lbnRyaWVzID0gdGhpcy5fZW50cmllcy5tYXAoKGVudHJ5KSA9PiB7XG4gICAgICBpZiAoZW50cnkuaXNDYW5jZWxsZWQoKSkge1xuICAgICAgICB0aGlzLm51bUVudHJpZXNJblByb2dyZXNzLS07XG4gICAgICAgIGlmICh0aGlzLm51bUVudHJpZXNJblByb2dyZXNzID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5vbkNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudHJ5LnppcFBvc3RGbGlnaHQocmVzcCk7XG4gICAgICAgIGVudHJ5Lm9uRG9uZSgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5udW1FbnRyaWVzSW5Qcm9ncmVzcy0tO1xuICAgICAgICAgIGlmICh0aGlzLm51bUVudHJpZXNJblByb2dyZXNzID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ29tcGxldGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH0pO1xuXG4gICAgY29uc3QgZ3JvdXBlZEVudHJpZXMgPSB0aGlzLl9lbnRyaWVzLnJlZHVjZSgoYWNjLCBlbnRyeSkgPT4ge1xuICAgICAgaWYgKCFlbnRyeS5tZXRhKSB7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9XG4gICAgICBjb25zdCB7IG5hbWUsIGNhbGxiYWNrIH0gPSBlbnRyeS51cGxvYWRlcihsaXZlU29ja2V0LnVwbG9hZGVycyk7XG4gICAgICBhY2NbbmFtZV0gPSBhY2NbbmFtZV0gfHwgeyBjYWxsYmFjazogY2FsbGJhY2ssIGVudHJpZXM6IFtdIH07XG4gICAgICBhY2NbbmFtZV0uZW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuXG4gICAgZm9yIChjb25zdCBuYW1lIGluIGdyb3VwZWRFbnRyaWVzKSB7XG4gICAgICBjb25zdCB7IGNhbGxiYWNrLCBlbnRyaWVzIH0gPSBncm91cGVkRW50cmllc1tuYW1lXTtcbiAgICAgIGNhbGxiYWNrKGVudHJpZXMsIG9uRXJyb3IsIHJlc3AsIGxpdmVTb2NrZXQpO1xuICAgIH1cbiAgfVxufVxuIiwgImNvbnN0IEFSSUEgPSB7XG4gIGFueU9mKGluc3RhbmNlLCBjbGFzc2VzKSB7XG4gICAgcmV0dXJuIGNsYXNzZXMuZmluZCgobmFtZSkgPT4gaW5zdGFuY2UgaW5zdGFuY2VvZiBuYW1lKTtcbiAgfSxcblxuICBpc0ZvY3VzYWJsZShlbCwgaW50ZXJhY3RpdmVPbmx5KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIChlbCBpbnN0YW5jZW9mIEhUTUxBbmNob3JFbGVtZW50ICYmIGVsLnJlbCAhPT0gXCJpZ25vcmVcIikgfHxcbiAgICAgIChlbCBpbnN0YW5jZW9mIEhUTUxBcmVhRWxlbWVudCAmJiBlbC5ocmVmICE9PSB1bmRlZmluZWQpIHx8XG4gICAgICAoIWVsLmRpc2FibGVkICYmXG4gICAgICAgIHRoaXMuYW55T2YoZWwsIFtcbiAgICAgICAgICBIVE1MSW5wdXRFbGVtZW50LFxuICAgICAgICAgIEhUTUxTZWxlY3RFbGVtZW50LFxuICAgICAgICAgIEhUTUxUZXh0QXJlYUVsZW1lbnQsXG4gICAgICAgICAgSFRNTEJ1dHRvbkVsZW1lbnQsXG4gICAgICAgIF0pKSB8fFxuICAgICAgZWwgaW5zdGFuY2VvZiBIVE1MSUZyYW1lRWxlbWVudCB8fFxuICAgICAgKGVsLnRhYkluZGV4ID49IDAgJiYgZWwuZ2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIikgIT09IFwidHJ1ZVwiKSB8fFxuICAgICAgKCFpbnRlcmFjdGl2ZU9ubHkgJiZcbiAgICAgICAgZWwuZ2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIikgIT09IG51bGwgJiZcbiAgICAgICAgZWwuZ2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIikgIT09IFwidHJ1ZVwiKVxuICAgICk7XG4gIH0sXG5cbiAgYXR0ZW1wdEZvY3VzKGVsLCBpbnRlcmFjdGl2ZU9ubHkpIHtcbiAgICBpZiAodGhpcy5pc0ZvY3VzYWJsZShlbCwgaW50ZXJhY3RpdmVPbmx5KSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZWwuZm9jdXMoKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyB0aGF0J3MgZmluZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gISFkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuaXNTYW1lTm9kZShlbCk7XG4gIH0sXG5cbiAgZm9jdXNGaXJzdEludGVyYWN0aXZlKGVsKSB7XG4gICAgbGV0IGNoaWxkID0gZWwuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBpZiAodGhpcy5hdHRlbXB0Rm9jdXMoY2hpbGQsIHRydWUpIHx8IHRoaXMuZm9jdXNGaXJzdEludGVyYWN0aXZlKGNoaWxkKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgIH1cbiAgfSxcblxuICBmb2N1c0ZpcnN0KGVsKSB7XG4gICAgbGV0IGNoaWxkID0gZWwuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBpZiAodGhpcy5hdHRlbXB0Rm9jdXMoY2hpbGQpIHx8IHRoaXMuZm9jdXNGaXJzdChjaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLm5leHRFbGVtZW50U2libGluZztcbiAgICB9XG4gIH0sXG5cbiAgZm9jdXNMYXN0KGVsKSB7XG4gICAgbGV0IGNoaWxkID0gZWwubGFzdEVsZW1lbnRDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgIGlmICh0aGlzLmF0dGVtcHRGb2N1cyhjaGlsZCkgfHwgdGhpcy5mb2N1c0xhc3QoY2hpbGQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgIH1cbiAgfSxcbn07XG5leHBvcnQgZGVmYXVsdCBBUklBO1xuIiwgImltcG9ydCB7XG4gIFBIWF9BQ1RJVkVfRU5UUllfUkVGUyxcbiAgUEhYX0xJVkVfRklMRV9VUERBVEVELFxuICBQSFhfUFJFRkxJR0hURURfUkVGUyxcbiAgUEhYX1VQTE9BRF9SRUYsXG4gIFBIWF9WSUVXUE9SVF9PVkVSUlVOX1RBUkdFVCxcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5cbmltcG9ydCBMaXZlVXBsb2FkZXIgZnJvbSBcIi4vbGl2ZV91cGxvYWRlclwiO1xuaW1wb3J0IEFSSUEgZnJvbSBcIi4vYXJpYVwiO1xuXG5jb25zdCBIb29rcyA9IHtcbiAgTGl2ZUZpbGVVcGxvYWQ6IHtcbiAgICBhY3RpdmVSZWZzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9BQ1RJVkVfRU5UUllfUkVGUyk7XG4gICAgfSxcblxuICAgIHByZWZsaWdodGVkUmVmcygpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfUFJFRkxJR0hURURfUkVGUyk7XG4gICAgfSxcblxuICAgIG1vdW50ZWQoKSB7XG4gICAgICB0aGlzLmpzKCkuaWdub3JlQXR0cmlidXRlcyh0aGlzLmVsLCBbXCJ2YWx1ZVwiXSk7XG4gICAgICB0aGlzLnByZWZsaWdodGVkV2FzID0gdGhpcy5wcmVmbGlnaHRlZFJlZnMoKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlZCgpIHtcbiAgICAgIGNvbnN0IG5ld1ByZWZsaWdodHMgPSB0aGlzLnByZWZsaWdodGVkUmVmcygpO1xuICAgICAgaWYgKHRoaXMucHJlZmxpZ2h0ZWRXYXMgIT09IG5ld1ByZWZsaWdodHMpIHtcbiAgICAgICAgdGhpcy5wcmVmbGlnaHRlZFdhcyA9IG5ld1ByZWZsaWdodHM7XG4gICAgICAgIGlmIChuZXdQcmVmbGlnaHRzID09PSBcIlwiKSB7XG4gICAgICAgICAgdGhpcy5fX3ZpZXcoKS5jYW5jZWxTdWJtaXQodGhpcy5lbC5mb3JtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5hY3RpdmVSZWZzKCkgPT09IFwiXCIpIHtcbiAgICAgICAgdGhpcy5lbC52YWx1ZSA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLmVsLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCkpO1xuICAgIH0sXG4gIH0sXG5cbiAgTGl2ZUltZ1ByZXZpZXc6IHtcbiAgICBtb3VudGVkKCkge1xuICAgICAgdGhpcy5yZWYgPSB0aGlzLmVsLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LWVudHJ5LXJlZlwiKTtcbiAgICAgIHRoaXMuaW5wdXRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxuICAgICAgICB0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfVVBMT0FEX1JFRiksXG4gICAgICApO1xuICAgICAgTGl2ZVVwbG9hZGVyLmdldEVudHJ5RGF0YVVSTCh0aGlzLmlucHV0RWwsIHRoaXMucmVmLCAodXJsKSA9PiB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLmVsLnNyYyA9IHVybDtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZGVzdHJveWVkKCkge1xuICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLnVybCk7XG4gICAgfSxcbiAgfSxcbiAgRm9jdXNXcmFwOiB7XG4gICAgbW91bnRlZCgpIHtcbiAgICAgIHRoaXMuZm9jdXNTdGFydCA9IHRoaXMuZWwuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICB0aGlzLmZvY3VzRW5kID0gdGhpcy5lbC5sYXN0RWxlbWVudENoaWxkO1xuICAgICAgdGhpcy5mb2N1c1N0YXJ0LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCAoZSkgPT4ge1xuICAgICAgICBpZiAoIWUucmVsYXRlZFRhcmdldCB8fCAhdGhpcy5lbC5jb250YWlucyhlLnJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICAgICAgLy8gSGFuZGxlIGZvY3VzIGVudGVyaW5nIGZyb20gb3V0c2lkZSAoZS5nLiBUYWIgd2hlbiBib2R5IGlzIGZvY3VzZWQpXG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Bob2VuaXhmcmFtZXdvcmsvcGhvZW5peF9saXZlX3ZpZXcvaXNzdWVzLzM2MzZcbiAgICAgICAgICBjb25zdCBuZXh0Rm9jdXMgPSBlLnRhcmdldC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgICAgQVJJQS5hdHRlbXB0Rm9jdXMobmV4dEZvY3VzKSB8fCBBUklBLmZvY3VzRmlyc3QobmV4dEZvY3VzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBBUklBLmZvY3VzTGFzdCh0aGlzLmVsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmZvY3VzRW5kLmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCAoZSkgPT4ge1xuICAgICAgICBpZiAoIWUucmVsYXRlZFRhcmdldCB8fCAhdGhpcy5lbC5jb250YWlucyhlLnJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICAgICAgLy8gSGFuZGxlIGZvY3VzIGVudGVyaW5nIGZyb20gb3V0c2lkZSAoZS5nLiBTaGlmdCtUYWIgd2hlbiBib2R5IGlzIGZvY3VzZWQpXG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Bob2VuaXhmcmFtZXdvcmsvcGhvZW5peF9saXZlX3ZpZXcvaXNzdWVzLzM2MzZcbiAgICAgICAgICBjb25zdCBuZXh0Rm9jdXMgPSBlLnRhcmdldC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgIEFSSUEuYXR0ZW1wdEZvY3VzKG5leHRGb2N1cykgfHwgQVJJQS5mb2N1c0xhc3QobmV4dEZvY3VzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBBUklBLmZvY3VzRmlyc3QodGhpcy5lbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gb25seSB0cnkgdG8gY2hhbmdlIHRoZSBmb2N1cyBpZiBpdCBpcyBub3QgYWxyZWFkeSBpbnNpZGVcbiAgICAgIGlmICghdGhpcy5lbC5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJwaHg6c2hvdy1lbmRcIiwgKCkgPT4gdGhpcy5lbC5mb2N1cygpKTtcbiAgICAgICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWwpLmRpc3BsYXkgIT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgQVJJQS5mb2N1c0ZpcnN0KHRoaXMuZWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IGZpbmRTY3JvbGxDb250YWluZXIgPSAoZWwpID0+IHtcbiAgLy8gdGhlIHNjcm9sbCBldmVudCB3b24ndCBiZSBmaXJlZCBvbiB0aGUgaHRtbC9ib2R5IGVsZW1lbnQgZXZlbiBpZiBvdmVyZmxvdyBpcyBzZXRcbiAgLy8gdGhlcmVmb3JlIHdlIHJldHVybiBudWxsIHRvIGluc3RlYWQgbGlzdGVuIGZvciBzY3JvbGwgZXZlbnRzIG9uIGRvY3VtZW50XG4gIGlmIChbXCJIVE1MXCIsIFwiQk9EWVwiXS5pbmRleE9mKGVsLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkpID49IDApIHJldHVybiBudWxsO1xuICBpZiAoW1wic2Nyb2xsXCIsIFwiYXV0b1wiXS5pbmRleE9mKGdldENvbXB1dGVkU3R5bGUoZWwpLm92ZXJmbG93WSkgPj0gMClcbiAgICByZXR1cm4gZWw7XG4gIHJldHVybiBmaW5kU2Nyb2xsQ29udGFpbmVyKGVsLnBhcmVudEVsZW1lbnQpO1xufTtcblxuY29uc3Qgc2Nyb2xsVG9wID0gKHNjcm9sbENvbnRhaW5lcikgPT4ge1xuICBpZiAoc2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgcmV0dXJuIHNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3A7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3A7XG4gIH1cbn07XG5cbmNvbnN0IGJvdHRvbSA9IChzY3JvbGxDb250YWluZXIpID0+IHtcbiAgaWYgKHNjcm9sbENvbnRhaW5lcikge1xuICAgIHJldHVybiBzY3JvbGxDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tO1xuICB9IGVsc2Uge1xuICAgIC8vIHdoZW4gd2UgaGF2ZSBubyBjb250YWluZXIsIHRoZSB3aG9sZSBwYWdlIHNjcm9sbHMsXG4gICAgLy8gdGhlcmVmb3JlIHRoZSBib3R0b20gY29vcmRpbmF0ZSBpcyB0aGUgdmlld3BvcnQgaGVpZ2h0XG4gICAgcmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICB9XG59O1xuXG5jb25zdCB0b3AgPSAoc2Nyb2xsQ29udGFpbmVyKSA9PiB7XG4gIGlmIChzY3JvbGxDb250YWluZXIpIHtcbiAgICByZXR1cm4gc2Nyb2xsQ29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgfSBlbHNlIHtcbiAgICAvLyB3aGVuIHdlIGhhdmUgbm8gY29udGFpbmVyIHRoZSB3aG9sZSBwYWdlIHNjcm9sbHMsXG4gICAgLy8gdGhlcmVmb3JlIHRoZSB0b3AgY29vcmRpbmF0ZSBpcyAwXG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5cbmNvbnN0IGlzQXRWaWV3cG9ydFRvcCA9IChlbCwgc2Nyb2xsQ29udGFpbmVyKSA9PiB7XG4gIGNvbnN0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIChcbiAgICBNYXRoLmNlaWwocmVjdC50b3ApID49IHRvcChzY3JvbGxDb250YWluZXIpICYmXG4gICAgTWF0aC5jZWlsKHJlY3QubGVmdCkgPj0gMCAmJlxuICAgIE1hdGguZmxvb3IocmVjdC50b3ApIDw9IGJvdHRvbShzY3JvbGxDb250YWluZXIpXG4gICk7XG59O1xuXG5jb25zdCBpc0F0Vmlld3BvcnRCb3R0b20gPSAoZWwsIHNjcm9sbENvbnRhaW5lcikgPT4ge1xuICBjb25zdCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiAoXG4gICAgTWF0aC5jZWlsKHJlY3QuYm90dG9tKSA+PSB0b3Aoc2Nyb2xsQ29udGFpbmVyKSAmJlxuICAgIE1hdGguY2VpbChyZWN0LmxlZnQpID49IDAgJiZcbiAgICBNYXRoLmZsb29yKHJlY3QuYm90dG9tKSA8PSBib3R0b20oc2Nyb2xsQ29udGFpbmVyKVxuICApO1xufTtcblxuY29uc3QgaXNXaXRoaW5WaWV3cG9ydCA9IChlbCwgc2Nyb2xsQ29udGFpbmVyKSA9PiB7XG4gIGNvbnN0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIChcbiAgICBNYXRoLmNlaWwocmVjdC50b3ApID49IHRvcChzY3JvbGxDb250YWluZXIpICYmXG4gICAgTWF0aC5jZWlsKHJlY3QubGVmdCkgPj0gMCAmJlxuICAgIE1hdGguZmxvb3IocmVjdC50b3ApIDw9IGJvdHRvbShzY3JvbGxDb250YWluZXIpXG4gICk7XG59O1xuXG5Ib29rcy5JbmZpbml0ZVNjcm9sbCA9IHtcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLnNjcm9sbENvbnRhaW5lciA9IGZpbmRTY3JvbGxDb250YWluZXIodGhpcy5lbCk7XG4gICAgbGV0IHNjcm9sbEJlZm9yZSA9IHNjcm9sbFRvcCh0aGlzLnNjcm9sbENvbnRhaW5lcik7XG4gICAgbGV0IHRvcE92ZXJyYW4gPSBmYWxzZTtcbiAgICBjb25zdCB0aHJvdHRsZUludGVydmFsID0gNTAwO1xuICAgIGxldCBwZW5kaW5nT3AgPSBudWxsO1xuXG4gICAgY29uc3Qgb25Ub3BPdmVycnVuID0gdGhpcy50aHJvdHRsZShcbiAgICAgIHRocm90dGxlSW50ZXJ2YWwsXG4gICAgICAodG9wRXZlbnQsIGZpcnN0Q2hpbGQpID0+IHtcbiAgICAgICAgcGVuZGluZ09wID0gKCkgPT4gdHJ1ZTtcbiAgICAgICAgdGhpcy5saXZlU29ja2V0LmpzKCkucHVzaCh0aGlzLmVsLCB0b3BFdmVudCwge1xuICAgICAgICAgIHZhbHVlOiB7IGlkOiBmaXJzdENoaWxkLmlkLCBfb3ZlcnJhbjogdHJ1ZSB9LFxuICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgICBwZW5kaW5nT3AgPSBudWxsO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICApO1xuXG4gICAgY29uc3Qgb25GaXJzdENoaWxkQXRUb3AgPSB0aGlzLnRocm90dGxlKFxuICAgICAgdGhyb3R0bGVJbnRlcnZhbCxcbiAgICAgICh0b3BFdmVudCwgZmlyc3RDaGlsZCkgPT4ge1xuICAgICAgICBwZW5kaW5nT3AgPSAoKSA9PiBmaXJzdENoaWxkLnNjcm9sbEludG9WaWV3KHsgYmxvY2s6IFwic3RhcnRcIiB9KTtcbiAgICAgICAgdGhpcy5saXZlU29ja2V0LmpzKCkucHVzaCh0aGlzLmVsLCB0b3BFdmVudCwge1xuICAgICAgICAgIHZhbHVlOiB7IGlkOiBmaXJzdENoaWxkLmlkIH0sXG4gICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICAgIHBlbmRpbmdPcCA9IG51bGw7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhhdCB0aGUgRE9NIGlzIHBhdGNoZWQgYnkgd2FpdGluZyBmb3IgdGhlIG5leHQgdGlja1xuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICghaXNXaXRoaW5WaWV3cG9ydChmaXJzdENoaWxkLCB0aGlzLnNjcm9sbENvbnRhaW5lcikpIHtcbiAgICAgICAgICAgICAgICBmaXJzdENoaWxkLnNjcm9sbEludG9WaWV3KHsgYmxvY2s6IFwic3RhcnRcIiB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICk7XG5cbiAgICBjb25zdCBvbkxhc3RDaGlsZEF0Qm90dG9tID0gdGhpcy50aHJvdHRsZShcbiAgICAgIHRocm90dGxlSW50ZXJ2YWwsXG4gICAgICAoYm90dG9tRXZlbnQsIGxhc3RDaGlsZCkgPT4ge1xuICAgICAgICBwZW5kaW5nT3AgPSAoKSA9PiBsYXN0Q2hpbGQuc2Nyb2xsSW50b1ZpZXcoeyBibG9jazogXCJlbmRcIiB9KTtcbiAgICAgICAgdGhpcy5saXZlU29ja2V0LmpzKCkucHVzaCh0aGlzLmVsLCBib3R0b21FdmVudCwge1xuICAgICAgICAgIHZhbHVlOiB7IGlkOiBsYXN0Q2hpbGQuaWQgfSxcbiAgICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgICAgcGVuZGluZ09wID0gbnVsbDtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHRoZSBET00gaXMgcGF0Y2hlZCBieSB3YWl0aW5nIGZvciB0aGUgbmV4dCB0aWNrXG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFpc1dpdGhpblZpZXdwb3J0KGxhc3RDaGlsZCwgdGhpcy5zY3JvbGxDb250YWluZXIpKSB7XG4gICAgICAgICAgICAgICAgbGFzdENoaWxkLnNjcm9sbEludG9WaWV3KHsgYmxvY2s6IFwiZW5kXCIgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICApO1xuXG4gICAgdGhpcy5vblNjcm9sbCA9IChfZSkgPT4ge1xuICAgICAgY29uc3Qgc2Nyb2xsTm93ID0gc2Nyb2xsVG9wKHRoaXMuc2Nyb2xsQ29udGFpbmVyKTtcblxuICAgICAgaWYgKHBlbmRpbmdPcCkge1xuICAgICAgICBzY3JvbGxCZWZvcmUgPSBzY3JvbGxOb3c7XG4gICAgICAgIHJldHVybiBwZW5kaW5nT3AoKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVjdCA9IHRoaXMuZmluZE92ZXJydW5UYXJnZXQoKTtcbiAgICAgIGNvbnN0IHRvcEV2ZW50ID0gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoXG4gICAgICAgIHRoaXMubGl2ZVNvY2tldC5iaW5kaW5nKFwidmlld3BvcnQtdG9wXCIpLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGJvdHRvbUV2ZW50ID0gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoXG4gICAgICAgIHRoaXMubGl2ZVNvY2tldC5iaW5kaW5nKFwidmlld3BvcnQtYm90dG9tXCIpLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGxhc3RDaGlsZCA9IHRoaXMuZWwubGFzdEVsZW1lbnRDaGlsZDtcbiAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSB0aGlzLmVsLmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgY29uc3QgaXNTY3JvbGxpbmdVcCA9IHNjcm9sbE5vdyA8IHNjcm9sbEJlZm9yZTtcbiAgICAgIGNvbnN0IGlzU2Nyb2xsaW5nRG93biA9IHNjcm9sbE5vdyA+IHNjcm9sbEJlZm9yZTtcblxuICAgICAgLy8gZWwgb3ZlcnJhbiB3aGlsZSBzY3JvbGxpbmcgdXBcbiAgICAgIGlmIChpc1Njcm9sbGluZ1VwICYmIHRvcEV2ZW50ICYmICF0b3BPdmVycmFuICYmIHJlY3QudG9wID49IDApIHtcbiAgICAgICAgdG9wT3ZlcnJhbiA9IHRydWU7XG4gICAgICAgIG9uVG9wT3ZlcnJ1bih0b3BFdmVudCwgZmlyc3RDaGlsZCk7XG4gICAgICB9IGVsc2UgaWYgKGlzU2Nyb2xsaW5nRG93biAmJiB0b3BPdmVycmFuICYmIHJlY3QudG9wIDw9IDApIHtcbiAgICAgICAgdG9wT3ZlcnJhbiA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIHRvcEV2ZW50ICYmXG4gICAgICAgIGlzU2Nyb2xsaW5nVXAgJiZcbiAgICAgICAgaXNBdFZpZXdwb3J0VG9wKGZpcnN0Q2hpbGQsIHRoaXMuc2Nyb2xsQ29udGFpbmVyKVxuICAgICAgKSB7XG4gICAgICAgIG9uRmlyc3RDaGlsZEF0VG9wKHRvcEV2ZW50LCBmaXJzdENoaWxkKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGJvdHRvbUV2ZW50ICYmXG4gICAgICAgIGlzU2Nyb2xsaW5nRG93biAmJlxuICAgICAgICBpc0F0Vmlld3BvcnRCb3R0b20obGFzdENoaWxkLCB0aGlzLnNjcm9sbENvbnRhaW5lcilcbiAgICAgICkge1xuICAgICAgICBvbkxhc3RDaGlsZEF0Qm90dG9tKGJvdHRvbUV2ZW50LCBsYXN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgc2Nyb2xsQmVmb3JlID0gc2Nyb2xsTm93O1xuICAgIH07XG5cbiAgICBpZiAodGhpcy5zY3JvbGxDb250YWluZXIpIHtcbiAgICAgIHRoaXMuc2Nyb2xsQ29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xuICAgIH1cbiAgfSxcblxuICBkZXN0cm95ZWQoKSB7XG4gICAgaWYgKHRoaXMuc2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICB0aGlzLnNjcm9sbENvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICB9XG4gIH0sXG5cbiAgdGhyb3R0bGUoaW50ZXJ2YWwsIGNhbGxiYWNrKSB7XG4gICAgbGV0IGxhc3RDYWxsQXQgPSAwO1xuICAgIGxldCB0aW1lcjtcblxuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IHJlbWFpbmluZ1RpbWUgPSBpbnRlcnZhbCAtIChub3cgLSBsYXN0Q2FsbEF0KTtcblxuICAgICAgaWYgKHJlbWFpbmluZ1RpbWUgPD0gMCB8fCByZW1haW5pbmdUaW1lID4gaW50ZXJ2YWwpIHtcbiAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdENhbGxBdCA9IG5vdztcbiAgICAgICAgY2FsbGJhY2soLi4uYXJncyk7XG4gICAgICB9IGVsc2UgaWYgKCF0aW1lcikge1xuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGxhc3RDYWxsQXQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICBjYWxsYmFjayguLi5hcmdzKTtcbiAgICAgICAgfSwgcmVtYWluaW5nVGltZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcblxuICBmaW5kT3ZlcnJ1blRhcmdldCgpIHtcbiAgICBsZXQgcmVjdDtcbiAgICBjb25zdCBvdmVycnVuVGFyZ2V0ID0gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoXG4gICAgICB0aGlzLmxpdmVTb2NrZXQuYmluZGluZyhQSFhfVklFV1BPUlRfT1ZFUlJVTl9UQVJHRVQpLFxuICAgICk7XG4gICAgaWYgKG92ZXJydW5UYXJnZXQpIHtcbiAgICAgIGNvbnN0IG92ZXJydW5FbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG92ZXJydW5UYXJnZXQpO1xuICAgICAgaWYgKG92ZXJydW5FbCkge1xuICAgICAgICByZWN0ID0gb3ZlcnJ1bkVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlkIG5vdCBmaW5kIGVsZW1lbnQgd2l0aCBpZCBcIiArIG92ZXJydW5UYXJnZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWN0ID0gdGhpcy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH0sXG59O1xuZXhwb3J0IGRlZmF1bHQgSG9va3M7XG4iLCAiaW1wb3J0IHtcbiAgUEhYX1JFRl9MT0FESU5HLFxuICBQSFhfUkVGX0xPQ0ssXG4gIFBIWF9SRUZfU1JDLFxuICBQSFhfUEVORElOR19SRUZTLFxuICBQSFhfRVZFTlRfQ0xBU1NFUyxcbiAgUEhYX0RJU0FCTEVELFxuICBQSFhfUkVBRE9OTFksXG4gIFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSxcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5cbmltcG9ydCBET00gZnJvbSBcIi4vZG9tXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVsZW1lbnRSZWYge1xuICBzdGF0aWMgb25VbmxvY2soZWwsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFET00uaXNMb2NrZWQoZWwpICYmICFlbC5jbG9zZXN0KGBbJHtQSFhfUkVGX0xPQ0t9XWApKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG4gICAgY29uc3QgY2xvc2VzdExvY2sgPSBlbC5jbG9zZXN0KGBbJHtQSFhfUkVGX0xPQ0t9XWApO1xuICAgIGNvbnN0IHJlZiA9IGNsb3Nlc3RMb2NrXG4gICAgICAuY2xvc2VzdChgWyR7UEhYX1JFRl9MT0NLfV1gKVxuICAgICAgLmdldEF0dHJpYnV0ZShQSFhfUkVGX0xPQ0spO1xuICAgIGNsb3Nlc3RMb2NrLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBgcGh4OnVuZG8tbG9jazoke3JlZn1gLFxuICAgICAgKCkgPT4ge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfSxcbiAgICAgIHsgb25jZTogdHJ1ZSB9LFxuICAgICk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihlbCkge1xuICAgIHRoaXMuZWwgPSBlbDtcbiAgICB0aGlzLmxvYWRpbmdSZWYgPSBlbC5oYXNBdHRyaWJ1dGUoUEhYX1JFRl9MT0FESU5HKVxuICAgICAgPyBwYXJzZUludChlbC5nZXRBdHRyaWJ1dGUoUEhYX1JFRl9MT0FESU5HKSwgMTApXG4gICAgICA6IG51bGw7XG4gICAgdGhpcy5sb2NrUmVmID0gZWwuaGFzQXR0cmlidXRlKFBIWF9SRUZfTE9DSylcbiAgICAgID8gcGFyc2VJbnQoZWwuZ2V0QXR0cmlidXRlKFBIWF9SRUZfTE9DSyksIDEwKVxuICAgICAgOiBudWxsO1xuICB9XG5cbiAgLy8gcHVibGljXG5cbiAgbWF5YmVVbmRvKHJlZiwgcGh4RXZlbnQsIGVhY2hDbG9uZUNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLmlzV2l0aGluKHJlZikpIHtcbiAgICAgIC8vIHdlIGNhbm5vdCB1bmRvIHRoZSBsb2NrIC8gbG9hZGluZyBub3csIGFzIHRoZXJlIGlzIGEgbmV3ZXIgb25lIGFscmVhZHkgc2V0O1xuICAgICAgLy8gd2UgbmVlZCB0byBzdG9yZSB0aGUgb3JpZ2luYWwgcmVmIHdlIHRyaWVkIHRvIHNlbmQgdGhlIHVuZG8gZXZlbnQgbGF0ZXJcbiAgICAgIERPTS51cGRhdGVQcml2YXRlKHRoaXMuZWwsIFBIWF9QRU5ESU5HX1JFRlMsIFtdLCAocGVuZGluZ1JlZnMpID0+IHtcbiAgICAgICAgcGVuZGluZ1JlZnMucHVzaChyZWYpO1xuICAgICAgICByZXR1cm4gcGVuZGluZ1JlZnM7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB1bmRvIGxvY2tzIGFuZCBhcHBseSBjbG9uZXNcbiAgICB0aGlzLnVuZG9Mb2NrcyhyZWYsIHBoeEV2ZW50LCBlYWNoQ2xvbmVDYWxsYmFjayk7XG5cbiAgICAvLyB1bmRvIGxvYWRpbmcgc3RhdGVzXG4gICAgdGhpcy51bmRvTG9hZGluZyhyZWYsIHBoeEV2ZW50KTtcblxuICAgIC8vIGVuc3VyZSB1bmRvIGV2ZW50cyBhcmUgZmlyZWQgZm9yIHBlbmRpbmcgcmVmcyB0aGF0XG4gICAgLy8gYXJlIHJlc29sdmVkIGJ5IHRoZSBjdXJyZW50IHJlZiwgb3RoZXJ3aXNlIHdlJ2QgbGVhayBldmVudCBsaXN0ZW5lcnNcbiAgICBET00udXBkYXRlUHJpdmF0ZSh0aGlzLmVsLCBQSFhfUEVORElOR19SRUZTLCBbXSwgKHBlbmRpbmdSZWZzKSA9PiB7XG4gICAgICByZXR1cm4gcGVuZGluZ1JlZnMuZmlsdGVyKChwZW5kaW5nUmVmKSA9PiB7XG4gICAgICAgIGxldCBvcHRzID0ge1xuICAgICAgICAgIGRldGFpbDogeyByZWY6IHBlbmRpbmdSZWYsIGV2ZW50OiBwaHhFdmVudCB9LFxuICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmxvYWRpbmdSZWYgJiYgdGhpcy5sb2FkaW5nUmVmID4gcGVuZGluZ1JlZikge1xuICAgICAgICAgIHRoaXMuZWwuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICAgIG5ldyBDdXN0b21FdmVudChgcGh4OnVuZG8tbG9hZGluZzoke3BlbmRpbmdSZWZ9YCwgb3B0cyksXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sb2NrUmVmICYmIHRoaXMubG9ja1JlZiA+IHBlbmRpbmdSZWYpIHtcbiAgICAgICAgICB0aGlzLmVsLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgICBuZXcgQ3VzdG9tRXZlbnQoYHBoeDp1bmRvLWxvY2s6JHtwZW5kaW5nUmVmfWAsIG9wdHMpLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBlbmRpbmdSZWYgPiByZWY7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIGNsZWFuIHVwIGlmIGZ1bGx5IHJlc29sdmVkXG4gICAgaWYgKHRoaXMuaXNGdWxseVJlc29sdmVkQnkocmVmKSkge1xuICAgICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFRl9TUkMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByaXZhdGVcblxuICBpc1dpdGhpbihyZWYpIHtcbiAgICByZXR1cm4gIShcbiAgICAgIHRoaXMubG9hZGluZ1JlZiAhPT0gbnVsbCAmJlxuICAgICAgdGhpcy5sb2FkaW5nUmVmID4gcmVmICYmXG4gICAgICB0aGlzLmxvY2tSZWYgIT09IG51bGwgJiZcbiAgICAgIHRoaXMubG9ja1JlZiA+IHJlZlxuICAgICk7XG4gIH1cblxuICAvLyBDaGVjayBmb3IgY2xvbmVkIFBIWF9SRUZfTE9DSyBlbGVtZW50IHRoYXQgaGFzIGJlZW4gbW9ycGhlZCBiZWhpbmRcbiAgLy8gdGhlIHNjZW5lcyB3aGlsZSB0aGlzIGVsZW1lbnQgd2FzIGxvY2tlZCBpbiB0aGUgRE9NLlxuICAvLyBXaGVuIHdlIGFwcGx5IHRoZSBjbG9uZWQgdHJlZSB0byB0aGUgYWN0aXZlIERPTSBlbGVtZW50LCB3ZSBtdXN0XG4gIC8vXG4gIC8vICAgMS4gZXhlY3V0ZSBwZW5kaW5nIG1vdW50ZWQgaG9va3MgZm9yIG5vZGVzIG5vdyBpbiB0aGUgRE9NXG4gIC8vICAgMi4gdW5kbyBhbnkgcmVmIGluc2lkZSB0aGUgY2xvbmVkIHRyZWUgdGhhdCBoYXMgc2luY2UgYmVlbiBhY2snZFxuICB1bmRvTG9ja3MocmVmLCBwaHhFdmVudCwgZWFjaENsb25lQ2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuaXNMb2NrVW5kb25lQnkocmVmKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNsb25lZFRyZWUgPSBET00ucHJpdmF0ZSh0aGlzLmVsLCBQSFhfUkVGX0xPQ0spO1xuICAgIGlmIChjbG9uZWRUcmVlKSB7XG4gICAgICBlYWNoQ2xvbmVDYWxsYmFjayhjbG9uZWRUcmVlKTtcbiAgICAgIERPTS5kZWxldGVQcml2YXRlKHRoaXMuZWwsIFBIWF9SRUZfTE9DSyk7XG4gICAgfVxuICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9SRUZfTE9DSyk7XG5cbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgZGV0YWlsOiB7IHJlZjogcmVmLCBldmVudDogcGh4RXZlbnQgfSxcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICB9O1xuICAgIHRoaXMuZWwuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBDdXN0b21FdmVudChgcGh4OnVuZG8tbG9jazoke3RoaXMubG9ja1JlZn1gLCBvcHRzKSxcbiAgICApO1xuICB9XG5cbiAgdW5kb0xvYWRpbmcocmVmLCBwaHhFdmVudCkge1xuICAgIGlmICghdGhpcy5pc0xvYWRpbmdVbmRvbmVCeShyZWYpKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuY2FuVW5kb0xvYWRpbmcocmVmKSAmJlxuICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5jb250YWlucyhcInBoeC1zdWJtaXQtbG9hZGluZ1wiKVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZShcInBoeC1jaGFuZ2UtbG9hZGluZ1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jYW5VbmRvTG9hZGluZyhyZWYpKSB7XG4gICAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfUkVGX0xPQURJTkcpO1xuICAgICAgY29uc3QgZGlzYWJsZWRWYWwgPSB0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfRElTQUJMRUQpO1xuICAgICAgY29uc3QgcmVhZE9ubHlWYWwgPSB0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfUkVBRE9OTFkpO1xuICAgICAgLy8gcmVzdG9yZSBpbnB1dHNcbiAgICAgIGlmIChyZWFkT25seVZhbCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmVsLnJlYWRPbmx5ID0gcmVhZE9ubHlWYWwgPT09IFwidHJ1ZVwiID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfUkVBRE9OTFkpO1xuICAgICAgfVxuICAgICAgaWYgKGRpc2FibGVkVmFsICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuZWwuZGlzYWJsZWQgPSBkaXNhYmxlZFZhbCA9PT0gXCJ0cnVlXCIgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9ESVNBQkxFRCk7XG4gICAgICB9XG4gICAgICAvLyByZXN0b3JlIGRpc2FibGVzXG4gICAgICBjb25zdCBkaXNhYmxlUmVzdG9yZSA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSk7XG4gICAgICBpZiAoZGlzYWJsZVJlc3RvcmUgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5lbC50ZXh0Q29udGVudCA9IGRpc2FibGVSZXN0b3JlO1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfRElTQUJMRV9XSVRIX1JFU1RPUkUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICBkZXRhaWw6IHsgcmVmOiByZWYsIGV2ZW50OiBwaHhFdmVudCB9LFxuICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgIH07XG4gICAgICB0aGlzLmVsLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgIG5ldyBDdXN0b21FdmVudChgcGh4OnVuZG8tbG9hZGluZzoke3RoaXMubG9hZGluZ1JlZn1gLCBvcHRzKSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGNsYXNzZXNcbiAgICBQSFhfRVZFTlRfQ0xBU1NFUy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICBpZiAobmFtZSAhPT0gXCJwaHgtc3VibWl0LWxvYWRpbmdcIiB8fCB0aGlzLmNhblVuZG9Mb2FkaW5nKHJlZikpIHtcbiAgICAgICAgRE9NLnJlbW92ZUNsYXNzKHRoaXMuZWwsIG5hbWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaXNMb2FkaW5nVW5kb25lQnkocmVmKSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZGluZ1JlZiA9PT0gbnVsbCA/IGZhbHNlIDogdGhpcy5sb2FkaW5nUmVmIDw9IHJlZjtcbiAgfVxuICBpc0xvY2tVbmRvbmVCeShyZWYpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NrUmVmID09PSBudWxsID8gZmFsc2UgOiB0aGlzLmxvY2tSZWYgPD0gcmVmO1xuICB9XG5cbiAgaXNGdWxseVJlc29sdmVkQnkocmVmKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICh0aGlzLmxvYWRpbmdSZWYgPT09IG51bGwgfHwgdGhpcy5sb2FkaW5nUmVmIDw9IHJlZikgJiZcbiAgICAgICh0aGlzLmxvY2tSZWYgPT09IG51bGwgfHwgdGhpcy5sb2NrUmVmIDw9IHJlZilcbiAgICApO1xuICB9XG5cbiAgLy8gb25seSByZW1vdmUgdGhlIHBoeC1zdWJtaXQtbG9hZGluZyBjbGFzcyBpZiB3ZSBhcmUgbm90IGxvY2tlZFxuICBjYW5VbmRvTG9hZGluZyhyZWYpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NrUmVmID09PSBudWxsIHx8IHRoaXMubG9ja1JlZiA8PSByZWY7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBtYXliZSB9IGZyb20gXCIuL3V0aWxzXCI7XG5cbmltcG9ydCBET00gZnJvbSBcIi4vZG9tXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERPTVBvc3RNb3JwaFJlc3RvcmVyIHtcbiAgY29uc3RydWN0b3IoY29udGFpbmVyQmVmb3JlLCBjb250YWluZXJBZnRlciwgdXBkYXRlVHlwZSkge1xuICAgIGNvbnN0IGlkc0JlZm9yZSA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBpZHNBZnRlciA9IG5ldyBTZXQoXG4gICAgICBbLi4uY29udGFpbmVyQWZ0ZXIuY2hpbGRyZW5dLm1hcCgoY2hpbGQpID0+IGNoaWxkLmlkKSxcbiAgICApO1xuXG4gICAgY29uc3QgZWxlbWVudHNUb01vZGlmeSA9IFtdO1xuXG4gICAgQXJyYXkuZnJvbShjb250YWluZXJCZWZvcmUuY2hpbGRyZW4pLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBpZiAoY2hpbGQuaWQpIHtcbiAgICAgICAgLy8gYWxsIG9mIG91ciBjaGlsZHJlbiBzaG91bGQgYmUgZWxlbWVudHMgd2l0aCBpZHNcbiAgICAgICAgaWRzQmVmb3JlLmFkZChjaGlsZC5pZCk7XG4gICAgICAgIGlmIChpZHNBZnRlci5oYXMoY2hpbGQuaWQpKSB7XG4gICAgICAgICAgY29uc3QgcHJldmlvdXNFbGVtZW50SWQgPVxuICAgICAgICAgICAgY2hpbGQucHJldmlvdXNFbGVtZW50U2libGluZyAmJiBjaGlsZC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLmlkO1xuICAgICAgICAgIGVsZW1lbnRzVG9Nb2RpZnkucHVzaCh7XG4gICAgICAgICAgICBlbGVtZW50SWQ6IGNoaWxkLmlkLFxuICAgICAgICAgICAgcHJldmlvdXNFbGVtZW50SWQ6IHByZXZpb3VzRWxlbWVudElkLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmNvbnRhaW5lcklkID0gY29udGFpbmVyQWZ0ZXIuaWQ7XG4gICAgdGhpcy51cGRhdGVUeXBlID0gdXBkYXRlVHlwZTtcbiAgICB0aGlzLmVsZW1lbnRzVG9Nb2RpZnkgPSBlbGVtZW50c1RvTW9kaWZ5O1xuICAgIHRoaXMuZWxlbWVudElkc1RvQWRkID0gWy4uLmlkc0FmdGVyXS5maWx0ZXIoKGlkKSA9PiAhaWRzQmVmb3JlLmhhcyhpZCkpO1xuICB9XG5cbiAgLy8gV2UgZG8gdGhlIGZvbGxvd2luZyB0byBvcHRpbWl6ZSBhcHBlbmQvcHJlcGVuZCBvcGVyYXRpb25zOlxuICAvLyAgIDEpIFRyYWNrIGlkcyBvZiBtb2RpZmllZCBlbGVtZW50cyAmIG9mIG5ldyBlbGVtZW50c1xuICAvLyAgIDIpIEFsbCB0aGUgbW9kaWZpZWQgZWxlbWVudHMgYXJlIHB1dCBiYWNrIGluIHRoZSBjb3JyZWN0IHBvc2l0aW9uIGluIHRoZSBET00gdHJlZVxuICAvLyAgICAgIGJ5IHN0b3JpbmcgdGhlIGlkIG9mIHRoZWlyIHByZXZpb3VzIHNpYmxpbmdcbiAgLy8gICAzKSBOZXcgZWxlbWVudHMgYXJlIGdvaW5nIHRvIGJlIHB1dCBpbiB0aGUgcmlnaHQgcGxhY2UgYnkgbW9ycGhkb20gZHVyaW5nIGFwcGVuZC5cbiAgLy8gICAgICBGb3IgcHJlcGVuZCwgd2UgbW92ZSB0aGVtIHRvIHRoZSBmaXJzdCBwb3NpdGlvbiBpbiB0aGUgY29udGFpbmVyXG4gIHBlcmZvcm0oKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gRE9NLmJ5SWQodGhpcy5jb250YWluZXJJZCk7XG4gICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbGVtZW50c1RvTW9kaWZ5LmZvckVhY2goKGVsZW1lbnRUb01vZGlmeSkgPT4ge1xuICAgICAgaWYgKGVsZW1lbnRUb01vZGlmeS5wcmV2aW91c0VsZW1lbnRJZCkge1xuICAgICAgICBtYXliZShcbiAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50VG9Nb2RpZnkucHJldmlvdXNFbGVtZW50SWQpLFxuICAgICAgICAgIChwcmV2aW91c0VsZW0pID0+IHtcbiAgICAgICAgICAgIG1heWJlKFxuICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50VG9Nb2RpZnkuZWxlbWVudElkKSxcbiAgICAgICAgICAgICAgKGVsZW0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0luUmlnaHRQbGFjZSA9XG4gICAgICAgICAgICAgICAgICBlbGVtLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgJiZcbiAgICAgICAgICAgICAgICAgIGVsZW0ucHJldmlvdXNFbGVtZW50U2libGluZy5pZCA9PSBwcmV2aW91c0VsZW0uaWQ7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0luUmlnaHRQbGFjZSkge1xuICAgICAgICAgICAgICAgICAgcHJldmlvdXNFbGVtLmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyZW5kXCIsIGVsZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGNvbnRhaW5lclxuICAgICAgICBtYXliZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50VG9Nb2RpZnkuZWxlbWVudElkKSwgKGVsZW0pID0+IHtcbiAgICAgICAgICBjb25zdCBpc0luUmlnaHRQbGFjZSA9IGVsZW0ucHJldmlvdXNFbGVtZW50U2libGluZyA9PSBudWxsO1xuICAgICAgICAgIGlmICghaXNJblJpZ2h0UGxhY2UpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJhZnRlcmJlZ2luXCIsIGVsZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy51cGRhdGVUeXBlID09IFwicHJlcGVuZFwiKSB7XG4gICAgICB0aGlzLmVsZW1lbnRJZHNUb0FkZC5yZXZlcnNlKCkuZm9yRWFjaCgoZWxlbUlkKSA9PiB7XG4gICAgICAgIG1heWJlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1JZCksIChlbGVtKSA9PlxuICAgICAgICAgIGNvbnRhaW5lci5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJhZnRlcmJlZ2luXCIsIGVsZW0pLFxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG4iLCAidmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPSAxMTtcblxuZnVuY3Rpb24gbW9ycGhBdHRycyhmcm9tTm9kZSwgdG9Ob2RlKSB7XG4gICAgdmFyIHRvTm9kZUF0dHJzID0gdG9Ob2RlLmF0dHJpYnV0ZXM7XG4gICAgdmFyIGF0dHI7XG4gICAgdmFyIGF0dHJOYW1lO1xuICAgIHZhciBhdHRyTmFtZXNwYWNlVVJJO1xuICAgIHZhciBhdHRyVmFsdWU7XG4gICAgdmFyIGZyb21WYWx1ZTtcblxuICAgIC8vIGRvY3VtZW50LWZyYWdtZW50cyBkb250IGhhdmUgYXR0cmlidXRlcyBzbyBsZXRzIG5vdCBkbyBhbnl0aGluZ1xuICAgIGlmICh0b05vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgfHwgZnJvbU5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgYXR0cmlidXRlcyBvbiBvcmlnaW5hbCBET00gZWxlbWVudFxuICAgIGZvciAodmFyIGkgPSB0b05vZGVBdHRycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBhdHRyID0gdG9Ob2RlQXR0cnNbaV07XG4gICAgICAgIGF0dHJOYW1lID0gYXR0ci5uYW1lO1xuICAgICAgICBhdHRyTmFtZXNwYWNlVVJJID0gYXR0ci5uYW1lc3BhY2VVUkk7XG4gICAgICAgIGF0dHJWYWx1ZSA9IGF0dHIudmFsdWU7XG5cbiAgICAgICAgaWYgKGF0dHJOYW1lc3BhY2VVUkkpIHtcbiAgICAgICAgICAgIGF0dHJOYW1lID0gYXR0ci5sb2NhbE5hbWUgfHwgYXR0ck5hbWU7XG4gICAgICAgICAgICBmcm9tVmFsdWUgPSBmcm9tTm9kZS5nZXRBdHRyaWJ1dGVOUyhhdHRyTmFtZXNwYWNlVVJJLCBhdHRyTmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChmcm9tVmFsdWUgIT09IGF0dHJWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChhdHRyLnByZWZpeCA9PT0gJ3htbG5zJyl7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJOYW1lID0gYXR0ci5uYW1lOyAvLyBJdCdzIG5vdCBhbGxvd2VkIHRvIHNldCBhbiBhdHRyaWJ1dGUgd2l0aCB0aGUgWE1MTlMgbmFtZXNwYWNlIHdpdGhvdXQgc3BlY2lmeWluZyB0aGUgYHhtbG5zYCBwcmVmaXhcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnJvbU5vZGUuc2V0QXR0cmlidXRlTlMoYXR0ck5hbWVzcGFjZVVSSSwgYXR0ck5hbWUsIGF0dHJWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcm9tVmFsdWUgPSBmcm9tTm9kZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuXG4gICAgICAgICAgICBpZiAoZnJvbVZhbHVlICE9PSBhdHRyVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBmcm9tTm9kZS5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIGF0dHJWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgYW55IGV4dHJhIGF0dHJpYnV0ZXMgZm91bmQgb24gdGhlIG9yaWdpbmFsIERPTSBlbGVtZW50IHRoYXRcbiAgICAvLyB3ZXJlbid0IGZvdW5kIG9uIHRoZSB0YXJnZXQgZWxlbWVudC5cbiAgICB2YXIgZnJvbU5vZGVBdHRycyA9IGZyb21Ob2RlLmF0dHJpYnV0ZXM7XG5cbiAgICBmb3IgKHZhciBkID0gZnJvbU5vZGVBdHRycy5sZW5ndGggLSAxOyBkID49IDA7IGQtLSkge1xuICAgICAgICBhdHRyID0gZnJvbU5vZGVBdHRyc1tkXTtcbiAgICAgICAgYXR0ck5hbWUgPSBhdHRyLm5hbWU7XG4gICAgICAgIGF0dHJOYW1lc3BhY2VVUkkgPSBhdHRyLm5hbWVzcGFjZVVSSTtcblxuICAgICAgICBpZiAoYXR0ck5hbWVzcGFjZVVSSSkge1xuICAgICAgICAgICAgYXR0ck5hbWUgPSBhdHRyLmxvY2FsTmFtZSB8fCBhdHRyTmFtZTtcblxuICAgICAgICAgICAgaWYgKCF0b05vZGUuaGFzQXR0cmlidXRlTlMoYXR0ck5hbWVzcGFjZVVSSSwgYXR0ck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgZnJvbU5vZGUucmVtb3ZlQXR0cmlidXRlTlMoYXR0ck5hbWVzcGFjZVVSSSwgYXR0ck5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0b05vZGUuaGFzQXR0cmlidXRlKGF0dHJOYW1lKSkge1xuICAgICAgICAgICAgICAgIGZyb21Ob2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciByYW5nZTsgLy8gQ3JlYXRlIGEgcmFuZ2Ugb2JqZWN0IGZvciBlZmZpY2VudGx5IHJlbmRlcmluZyBzdHJpbmdzIHRvIGVsZW1lbnRzLlxudmFyIE5TX1hIVE1MID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xuXG52YXIgZG9jID0gdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IGRvY3VtZW50O1xudmFyIEhBU19URU1QTEFURV9TVVBQT1JUID0gISFkb2MgJiYgJ2NvbnRlbnQnIGluIGRvYy5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xudmFyIEhBU19SQU5HRV9TVVBQT1JUID0gISFkb2MgJiYgZG9jLmNyZWF0ZVJhbmdlICYmICdjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQnIGluIGRvYy5jcmVhdGVSYW5nZSgpO1xuXG5mdW5jdGlvbiBjcmVhdGVGcmFnbWVudEZyb21UZW1wbGF0ZShzdHIpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBkb2MuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSBzdHI7XG4gICAgcmV0dXJuIHRlbXBsYXRlLmNvbnRlbnQuY2hpbGROb2Rlc1swXTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnRGcm9tUmFuZ2Uoc3RyKSB7XG4gICAgaWYgKCFyYW5nZSkge1xuICAgICAgICByYW5nZSA9IGRvYy5jcmVhdGVSYW5nZSgpO1xuICAgICAgICByYW5nZS5zZWxlY3ROb2RlKGRvYy5ib2R5KTtcbiAgICB9XG5cbiAgICB2YXIgZnJhZ21lbnQgPSByYW5nZS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQoc3RyKTtcbiAgICByZXR1cm4gZnJhZ21lbnQuY2hpbGROb2Rlc1swXTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnRGcm9tV3JhcChzdHIpIHtcbiAgICB2YXIgZnJhZ21lbnQgPSBkb2MuY3JlYXRlRWxlbWVudCgnYm9keScpO1xuICAgIGZyYWdtZW50LmlubmVySFRNTCA9IHN0cjtcbiAgICByZXR1cm4gZnJhZ21lbnQuY2hpbGROb2Rlc1swXTtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGFib3V0IHRoZSBzYW1lXG4gKiB2YXIgaHRtbCA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoc3RyLCAndGV4dC9odG1sJyk7XG4gKiByZXR1cm4gaHRtbC5ib2R5LmZpcnN0Q2hpbGQ7XG4gKlxuICogQG1ldGhvZCB0b0VsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqL1xuZnVuY3Rpb24gdG9FbGVtZW50KHN0cikge1xuICAgIHN0ciA9IHN0ci50cmltKCk7XG4gICAgaWYgKEhBU19URU1QTEFURV9TVVBQT1JUKSB7XG4gICAgICAvLyBhdm9pZCByZXN0cmljdGlvbnMgb24gY29udGVudCBmb3IgdGhpbmdzIGxpa2UgYDx0cj48dGg+SGk8L3RoPjwvdHI+YCB3aGljaFxuICAgICAgLy8gY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50IGRvZXNuJ3Qgc3VwcG9ydFxuICAgICAgLy8gPHRlbXBsYXRlPiBzdXBwb3J0IG5vdCBhdmFpbGFibGUgaW4gSUVcbiAgICAgIHJldHVybiBjcmVhdGVGcmFnbWVudEZyb21UZW1wbGF0ZShzdHIpO1xuICAgIH0gZWxzZSBpZiAoSEFTX1JBTkdFX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGcmFnbWVudEZyb21SYW5nZShzdHIpO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVGcmFnbWVudEZyb21XcmFwKHN0cik7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHR3byBub2RlJ3MgbmFtZXMgYXJlIHRoZSBzYW1lLlxuICpcbiAqIE5PVEU6IFdlIGRvbid0IGJvdGhlciBjaGVja2luZyBgbmFtZXNwYWNlVVJJYCBiZWNhdXNlIHlvdSB3aWxsIG5ldmVyIGZpbmQgdHdvIEhUTUwgZWxlbWVudHMgd2l0aCB0aGUgc2FtZVxuICogICAgICAgbm9kZU5hbWUgYW5kIGRpZmZlcmVudCBuYW1lc3BhY2UgVVJJcy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gYiBUaGUgdGFyZ2V0IGVsZW1lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVOb2RlTmFtZXMoZnJvbUVsLCB0b0VsKSB7XG4gICAgdmFyIGZyb21Ob2RlTmFtZSA9IGZyb21FbC5ub2RlTmFtZTtcbiAgICB2YXIgdG9Ob2RlTmFtZSA9IHRvRWwubm9kZU5hbWU7XG4gICAgdmFyIGZyb21Db2RlU3RhcnQsIHRvQ29kZVN0YXJ0O1xuXG4gICAgaWYgKGZyb21Ob2RlTmFtZSA9PT0gdG9Ob2RlTmFtZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmcm9tQ29kZVN0YXJ0ID0gZnJvbU5vZGVOYW1lLmNoYXJDb2RlQXQoMCk7XG4gICAgdG9Db2RlU3RhcnQgPSB0b05vZGVOYW1lLmNoYXJDb2RlQXQoMCk7XG5cbiAgICAvLyBJZiB0aGUgdGFyZ2V0IGVsZW1lbnQgaXMgYSB2aXJ0dWFsIERPTSBub2RlIG9yIFNWRyBub2RlIHRoZW4gd2UgbWF5XG4gICAgLy8gbmVlZCB0byBub3JtYWxpemUgdGhlIHRhZyBuYW1lIGJlZm9yZSBjb21wYXJpbmcuIE5vcm1hbCBIVE1MIGVsZW1lbnRzIHRoYXQgYXJlXG4gICAgLy8gaW4gdGhlIFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiXG4gICAgLy8gYXJlIGNvbnZlcnRlZCB0byB1cHBlciBjYXNlXG4gICAgaWYgKGZyb21Db2RlU3RhcnQgPD0gOTAgJiYgdG9Db2RlU3RhcnQgPj0gOTcpIHsgLy8gZnJvbSBpcyB1cHBlciBhbmQgdG8gaXMgbG93ZXJcbiAgICAgICAgcmV0dXJuIGZyb21Ob2RlTmFtZSA9PT0gdG9Ob2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgIH0gZWxzZSBpZiAodG9Db2RlU3RhcnQgPD0gOTAgJiYgZnJvbUNvZGVTdGFydCA+PSA5NykgeyAvLyB0byBpcyB1cHBlciBhbmQgZnJvbSBpcyBsb3dlclxuICAgICAgICByZXR1cm4gdG9Ob2RlTmFtZSA9PT0gZnJvbU5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gZWxlbWVudCwgb3B0aW9uYWxseSB3aXRoIGEga25vd24gbmFtZXNwYWNlIFVSSS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgZWxlbWVudCBuYW1lLCBlLmcuICdkaXYnIG9yICdzdmcnXG4gKiBAcGFyYW0ge3N0cmluZ30gW25hbWVzcGFjZVVSSV0gdGhlIGVsZW1lbnQncyBuYW1lc3BhY2UgVVJJLCBpLmUuIHRoZSB2YWx1ZSBvZlxuICogaXRzIGB4bWxuc2AgYXR0cmlidXRlIG9yIGl0cyBpbmZlcnJlZCBuYW1lc3BhY2UuXG4gKlxuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TKG5hbWUsIG5hbWVzcGFjZVVSSSkge1xuICAgIHJldHVybiAhbmFtZXNwYWNlVVJJIHx8IG5hbWVzcGFjZVVSSSA9PT0gTlNfWEhUTUwgP1xuICAgICAgICBkb2MuY3JlYXRlRWxlbWVudChuYW1lKSA6XG4gICAgICAgIGRvYy5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCBuYW1lKTtcbn1cblxuLyoqXG4gKiBDb3BpZXMgdGhlIGNoaWxkcmVuIG9mIG9uZSBET00gZWxlbWVudCB0byBhbm90aGVyIERPTSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIG1vdmVDaGlsZHJlbihmcm9tRWwsIHRvRWwpIHtcbiAgICB2YXIgY3VyQ2hpbGQgPSBmcm9tRWwuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcbiAgICAgICAgdmFyIG5leHRDaGlsZCA9IGN1ckNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICB0b0VsLmFwcGVuZENoaWxkKGN1ckNoaWxkKTtcbiAgICAgICAgY3VyQ2hpbGQgPSBuZXh0Q2hpbGQ7XG4gICAgfVxuICAgIHJldHVybiB0b0VsO1xufVxuXG5mdW5jdGlvbiBzeW5jQm9vbGVhbkF0dHJQcm9wKGZyb21FbCwgdG9FbCwgbmFtZSkge1xuICAgIGlmIChmcm9tRWxbbmFtZV0gIT09IHRvRWxbbmFtZV0pIHtcbiAgICAgICAgZnJvbUVsW25hbWVdID0gdG9FbFtuYW1lXTtcbiAgICAgICAgaWYgKGZyb21FbFtuYW1lXSkge1xuICAgICAgICAgICAgZnJvbUVsLnNldEF0dHJpYnV0ZShuYW1lLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcm9tRWwucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG52YXIgc3BlY2lhbEVsSGFuZGxlcnMgPSB7XG4gICAgT1BUSU9OOiBmdW5jdGlvbihmcm9tRWwsIHRvRWwpIHtcbiAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBmcm9tRWwucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnROYW1lID0gcGFyZW50Tm9kZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKHBhcmVudE5hbWUgPT09ICdPUFRHUk9VUCcpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIHBhcmVudE5hbWUgPSBwYXJlbnROb2RlICYmIHBhcmVudE5vZGUubm9kZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJlbnROYW1lID09PSAnU0VMRUNUJyAmJiAhcGFyZW50Tm9kZS5oYXNBdHRyaWJ1dGUoJ211bHRpcGxlJykpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUVsLmhhc0F0dHJpYnV0ZSgnc2VsZWN0ZWQnKSAmJiAhdG9FbC5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBNUyBFZGdlIGJ1ZyB3aGVyZSB0aGUgJ3NlbGVjdGVkJyBhdHRyaWJ1dGUgY2FuIG9ubHkgYmVcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlZCBpZiBzZXQgdG8gYSBub24tZW1wdHkgdmFsdWU6XG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzEyMDg3Njc5L1xuICAgICAgICAgICAgICAgICAgICBmcm9tRWwuc2V0QXR0cmlidXRlKCdzZWxlY3RlZCcsICdzZWxlY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICBmcm9tRWwucmVtb3ZlQXR0cmlidXRlKCdzZWxlY3RlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIHRvIHJlc2V0IHNlbGVjdCBlbGVtZW50J3Mgc2VsZWN0ZWRJbmRleCB0byAtMSwgb3RoZXJ3aXNlIHNldHRpbmdcbiAgICAgICAgICAgICAgICAvLyBmcm9tRWwuc2VsZWN0ZWQgdXNpbmcgdGhlIHN5bmNCb29sZWFuQXR0clByb3AgYmVsb3cgaGFzIG5vIGVmZmVjdC5cbiAgICAgICAgICAgICAgICAvLyBUaGUgY29ycmVjdCBzZWxlY3RlZEluZGV4IHdpbGwgYmUgc2V0IGluIHRoZSBTRUxFQ1Qgc3BlY2lhbCBoYW5kbGVyIGJlbG93LlxuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN5bmNCb29sZWFuQXR0clByb3AoZnJvbUVsLCB0b0VsLCAnc2VsZWN0ZWQnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBcInZhbHVlXCIgYXR0cmlidXRlIGlzIHNwZWNpYWwgZm9yIHRoZSA8aW5wdXQ+IGVsZW1lbnQgc2luY2UgaXQgc2V0c1xuICAgICAqIHRoZSBpbml0aWFsIHZhbHVlLiBDaGFuZ2luZyB0aGUgXCJ2YWx1ZVwiIGF0dHJpYnV0ZSB3aXRob3V0IGNoYW5naW5nIHRoZVxuICAgICAqIFwidmFsdWVcIiBwcm9wZXJ0eSB3aWxsIGhhdmUgbm8gZWZmZWN0IHNpbmNlIGl0IGlzIG9ubHkgdXNlZCB0byB0aGUgc2V0IHRoZVxuICAgICAqIGluaXRpYWwgdmFsdWUuICBTaW1pbGFyIGZvciB0aGUgXCJjaGVja2VkXCIgYXR0cmlidXRlLCBhbmQgXCJkaXNhYmxlZFwiLlxuICAgICAqL1xuICAgIElOUFVUOiBmdW5jdGlvbihmcm9tRWwsIHRvRWwpIHtcbiAgICAgICAgc3luY0Jvb2xlYW5BdHRyUHJvcChmcm9tRWwsIHRvRWwsICdjaGVja2VkJyk7XG4gICAgICAgIHN5bmNCb29sZWFuQXR0clByb3AoZnJvbUVsLCB0b0VsLCAnZGlzYWJsZWQnKTtcblxuICAgICAgICBpZiAoZnJvbUVsLnZhbHVlICE9PSB0b0VsLnZhbHVlKSB7XG4gICAgICAgICAgICBmcm9tRWwudmFsdWUgPSB0b0VsLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0b0VsLmhhc0F0dHJpYnV0ZSgndmFsdWUnKSkge1xuICAgICAgICAgICAgZnJvbUVsLnJlbW92ZUF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBURVhUQVJFQTogZnVuY3Rpb24oZnJvbUVsLCB0b0VsKSB7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IHRvRWwudmFsdWU7XG4gICAgICAgIGlmIChmcm9tRWwudmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBmcm9tRWwudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaXJzdENoaWxkID0gZnJvbUVsLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmIChmaXJzdENoaWxkKSB7XG4gICAgICAgICAgICAvLyBOZWVkZWQgZm9yIElFLiBBcHBhcmVudGx5IElFIHNldHMgdGhlIHBsYWNlaG9sZGVyIGFzIHRoZVxuICAgICAgICAgICAgLy8gbm9kZSB2YWx1ZSBhbmQgdmlzZSB2ZXJzYS4gVGhpcyBpZ25vcmVzIGFuIGVtcHR5IHVwZGF0ZS5cbiAgICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IGZpcnN0Q2hpbGQubm9kZVZhbHVlO1xuXG4gICAgICAgICAgICBpZiAob2xkVmFsdWUgPT0gbmV3VmFsdWUgfHwgKCFuZXdWYWx1ZSAmJiBvbGRWYWx1ZSA9PSBmcm9tRWwucGxhY2Vob2xkZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaXJzdENoaWxkLm5vZGVWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBTRUxFQ1Q6IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgICBpZiAoIXRvRWwuaGFzQXR0cmlidXRlKCdtdWx0aXBsZScpKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBsb29wIHRocm91Z2ggY2hpbGRyZW4gb2YgZnJvbUVsLCBub3QgdG9FbCBzaW5jZSBub2RlcyBjYW4gYmUgbW92ZWRcbiAgICAgICAgICAgIC8vIGZyb20gdG9FbCB0byBmcm9tRWwgZGlyZWN0bHkgd2hlbiBtb3JwaGluZy5cbiAgICAgICAgICAgIC8vIEF0IHRoZSB0aW1lIHRoaXMgc3BlY2lhbCBoYW5kbGVyIGlzIGludm9rZWQsIGFsbCBjaGlsZHJlbiBoYXZlIGFscmVhZHkgYmVlbiBtb3JwaGVkXG4gICAgICAgICAgICAvLyBhbmQgYXBwZW5kZWQgdG8gLyByZW1vdmVkIGZyb20gZnJvbUVsLCBzbyB1c2luZyBmcm9tRWwgaGVyZSBpcyBzYWZlIGFuZCBjb3JyZWN0LlxuICAgICAgICAgICAgdmFyIGN1ckNoaWxkID0gZnJvbUVsLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB2YXIgb3B0Z3JvdXA7XG4gICAgICAgICAgICB2YXIgbm9kZU5hbWU7XG4gICAgICAgICAgICB3aGlsZShjdXJDaGlsZCkge1xuICAgICAgICAgICAgICAgIG5vZGVOYW1lID0gY3VyQ2hpbGQubm9kZU5hbWUgJiYgY3VyQ2hpbGQubm9kZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZU5hbWUgPT09ICdPUFRHUk9VUCcpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0Z3JvdXAgPSBjdXJDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgY3VyQ2hpbGQgPSBvcHRncm91cC5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgZW1wdHkgb3B0Z3JvdXBzXG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VyQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gb3B0Z3JvdXAubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRncm91cCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZU5hbWUgPT09ICdPUFRJT04nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyQ2hpbGQuaGFzQXR0cmlidXRlKCdzZWxlY3RlZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VyQ2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJDaGlsZCAmJiBvcHRncm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyQ2hpbGQgPSBvcHRncm91cC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGdyb3VwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnJvbUVsLnNlbGVjdGVkSW5kZXggPSBzZWxlY3RlZEluZGV4O1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIEVMRU1FTlRfTk9ERSA9IDE7XG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSQxID0gMTE7XG52YXIgVEVYVF9OT0RFID0gMztcbnZhciBDT01NRU5UX05PREUgPSA4O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gZGVmYXVsdEdldE5vZGVLZXkobm9kZSkge1xuICBpZiAobm9kZSkge1xuICAgIHJldHVybiAobm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ2lkJykpIHx8IG5vZGUuaWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbW9ycGhkb21GYWN0b3J5KG1vcnBoQXR0cnMpIHtcblxuICByZXR1cm4gZnVuY3Rpb24gbW9ycGhkb20oZnJvbU5vZGUsIHRvTm9kZSwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdG9Ob2RlID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKGZyb21Ob2RlLm5vZGVOYW1lID09PSAnI2RvY3VtZW50JyB8fCBmcm9tTm9kZS5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgICAgIHZhciB0b05vZGVIdG1sID0gdG9Ob2RlO1xuICAgICAgICB0b05vZGUgPSBkb2MuY3JlYXRlRWxlbWVudCgnaHRtbCcpO1xuICAgICAgICB0b05vZGUuaW5uZXJIVE1MID0gdG9Ob2RlSHRtbDtcbiAgICAgIH0gZWxzZSBpZiAoZnJvbU5vZGUubm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgICAgICB2YXIgdG9Ob2RlQm9keSA9IHRvTm9kZTtcbiAgICAgICAgdG9Ob2RlID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2h0bWwnKTtcbiAgICAgICAgdG9Ob2RlLmlubmVySFRNTCA9IHRvTm9kZUJvZHk7XG4gICAgICAgIC8vIEV4dHJhY3QgdGhlIGJvZHkgZWxlbWVudCBmcm9tIHRoZSBjcmVhdGVkIEhUTUwgc3RydWN0dXJlXG4gICAgICAgIHZhciBib2R5RWxlbWVudCA9IHRvTm9kZS5xdWVyeVNlbGVjdG9yKCdib2R5Jyk7XG4gICAgICAgIGlmIChib2R5RWxlbWVudCkge1xuICAgICAgICAgIHRvTm9kZSA9IGJvZHlFbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b05vZGUgPSB0b0VsZW1lbnQodG9Ob2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRvTm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSQxKSB7XG4gICAgICB0b05vZGUgPSB0b05vZGUuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgfVxuXG4gICAgdmFyIGdldE5vZGVLZXkgPSBvcHRpb25zLmdldE5vZGVLZXkgfHwgZGVmYXVsdEdldE5vZGVLZXk7XG4gICAgdmFyIG9uQmVmb3JlTm9kZUFkZGVkID0gb3B0aW9ucy5vbkJlZm9yZU5vZGVBZGRlZCB8fCBub29wO1xuICAgIHZhciBvbk5vZGVBZGRlZCA9IG9wdGlvbnMub25Ob2RlQWRkZWQgfHwgbm9vcDtcbiAgICB2YXIgb25CZWZvcmVFbFVwZGF0ZWQgPSBvcHRpb25zLm9uQmVmb3JlRWxVcGRhdGVkIHx8IG5vb3A7XG4gICAgdmFyIG9uRWxVcGRhdGVkID0gb3B0aW9ucy5vbkVsVXBkYXRlZCB8fCBub29wO1xuICAgIHZhciBvbkJlZm9yZU5vZGVEaXNjYXJkZWQgPSBvcHRpb25zLm9uQmVmb3JlTm9kZURpc2NhcmRlZCB8fCBub29wO1xuICAgIHZhciBvbk5vZGVEaXNjYXJkZWQgPSBvcHRpb25zLm9uTm9kZURpc2NhcmRlZCB8fCBub29wO1xuICAgIHZhciBvbkJlZm9yZUVsQ2hpbGRyZW5VcGRhdGVkID0gb3B0aW9ucy5vbkJlZm9yZUVsQ2hpbGRyZW5VcGRhdGVkIHx8IG5vb3A7XG4gICAgdmFyIHNraXBGcm9tQ2hpbGRyZW4gPSBvcHRpb25zLnNraXBGcm9tQ2hpbGRyZW4gfHwgbm9vcDtcbiAgICB2YXIgYWRkQ2hpbGQgPSBvcHRpb25zLmFkZENoaWxkIHx8IGZ1bmN0aW9uKHBhcmVudCwgY2hpbGQpeyByZXR1cm4gcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKTsgfTtcbiAgICB2YXIgY2hpbGRyZW5Pbmx5ID0gb3B0aW9ucy5jaGlsZHJlbk9ubHkgPT09IHRydWU7XG5cbiAgICAvLyBUaGlzIG9iamVjdCBpcyB1c2VkIGFzIGEgbG9va3VwIHRvIHF1aWNrbHkgZmluZCBhbGwga2V5ZWQgZWxlbWVudHMgaW4gdGhlIG9yaWdpbmFsIERPTSB0cmVlLlxuICAgIHZhciBmcm9tTm9kZXNMb29rdXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBrZXllZFJlbW92YWxMaXN0ID0gW107XG5cbiAgICBmdW5jdGlvbiBhZGRLZXllZFJlbW92YWwoa2V5KSB7XG4gICAgICBrZXllZFJlbW92YWxMaXN0LnB1c2goa2V5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3YWxrRGlzY2FyZGVkQ2hpbGROb2Rlcyhub2RlLCBza2lwS2V5ZWROb2Rlcykge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICB2YXIgY3VyQ2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHdoaWxlIChjdXJDaGlsZCkge1xuXG4gICAgICAgICAgdmFyIGtleSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGlmIChza2lwS2V5ZWROb2RlcyAmJiAoa2V5ID0gZ2V0Tm9kZUtleShjdXJDaGlsZCkpKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgc2tpcHBpbmcga2V5ZWQgbm9kZXMgdGhlbiB3ZSBhZGQgdGhlIGtleVxuICAgICAgICAgICAgLy8gdG8gYSBsaXN0IHNvIHRoYXQgaXQgY2FuIGJlIGhhbmRsZWQgYXQgdGhlIHZlcnkgZW5kLlxuICAgICAgICAgICAgYWRkS2V5ZWRSZW1vdmFsKGtleSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE9ubHkgcmVwb3J0IHRoZSBub2RlIGFzIGRpc2NhcmRlZCBpZiBpdCBpcyBub3Qga2V5ZWQuIFdlIGRvIHRoaXMgYmVjYXVzZVxuICAgICAgICAgICAgLy8gYXQgdGhlIGVuZCB3ZSBsb29wIHRocm91Z2ggYWxsIGtleWVkIGVsZW1lbnRzIHRoYXQgd2VyZSB1bm1hdGNoZWRcbiAgICAgICAgICAgIC8vIGFuZCB0aGVuIGRpc2NhcmQgdGhlbSBpbiBvbmUgZmluYWwgcGFzcy5cbiAgICAgICAgICAgIG9uTm9kZURpc2NhcmRlZChjdXJDaGlsZCk7XG4gICAgICAgICAgICBpZiAoY3VyQ2hpbGQuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICB3YWxrRGlzY2FyZGVkQ2hpbGROb2RlcyhjdXJDaGlsZCwgc2tpcEtleWVkTm9kZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1ckNoaWxkID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFJlbW92ZXMgYSBET00gbm9kZSBvdXQgb2YgdGhlIG9yaWdpbmFsIERPTVxuICAgICpcbiAgICAqIEBwYXJhbSAge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXG4gICAgKiBAcGFyYW0gIHtOb2RlfSBwYXJlbnROb2RlIFRoZSBub2RlcyBwYXJlbnRcbiAgICAqIEBwYXJhbSAge0Jvb2xlYW59IHNraXBLZXllZE5vZGVzIElmIHRydWUgdGhlbiBlbGVtZW50cyB3aXRoIGtleXMgd2lsbCBiZSBza2lwcGVkIGFuZCBub3QgZGlzY2FyZGVkLlxuICAgICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlTm9kZShub2RlLCBwYXJlbnROb2RlLCBza2lwS2V5ZWROb2Rlcykge1xuICAgICAgaWYgKG9uQmVmb3JlTm9kZURpc2NhcmRlZChub2RlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICBvbk5vZGVEaXNjYXJkZWQobm9kZSk7XG4gICAgICB3YWxrRGlzY2FyZGVkQ2hpbGROb2Rlcyhub2RlLCBza2lwS2V5ZWROb2Rlcyk7XG4gICAgfVxuXG4gICAgLy8gLy8gVHJlZVdhbGtlciBpbXBsZW1lbnRhdGlvbiBpcyBubyBmYXN0ZXIsIGJ1dCBrZWVwaW5nIHRoaXMgYXJvdW5kIGluIGNhc2UgdGhpcyBjaGFuZ2VzIGluIHRoZSBmdXR1cmVcbiAgICAvLyBmdW5jdGlvbiBpbmRleFRyZWUocm9vdCkge1xuICAgIC8vICAgICB2YXIgdHJlZVdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoXG4gICAgLy8gICAgICAgICByb290LFxuICAgIC8vICAgICAgICAgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQpO1xuICAgIC8vXG4gICAgLy8gICAgIHZhciBlbDtcbiAgICAvLyAgICAgd2hpbGUoKGVsID0gdHJlZVdhbGtlci5uZXh0Tm9kZSgpKSkge1xuICAgIC8vICAgICAgICAgdmFyIGtleSA9IGdldE5vZGVLZXkoZWwpO1xuICAgIC8vICAgICAgICAgaWYgKGtleSkge1xuICAgIC8vICAgICAgICAgICAgIGZyb21Ob2Rlc0xvb2t1cFtrZXldID0gZWw7XG4gICAgLy8gICAgICAgICB9XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG5cbiAgICAvLyAvLyBOb2RlSXRlcmF0b3IgaW1wbGVtZW50YXRpb24gaXMgbm8gZmFzdGVyLCBidXQga2VlcGluZyB0aGlzIGFyb3VuZCBpbiBjYXNlIHRoaXMgY2hhbmdlcyBpbiB0aGUgZnV0dXJlXG4gICAgLy9cbiAgICAvLyBmdW5jdGlvbiBpbmRleFRyZWUobm9kZSkge1xuICAgIC8vICAgICB2YXIgbm9kZUl0ZXJhdG9yID0gZG9jdW1lbnQuY3JlYXRlTm9kZUl0ZXJhdG9yKG5vZGUsIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5UKTtcbiAgICAvLyAgICAgdmFyIGVsO1xuICAgIC8vICAgICB3aGlsZSgoZWwgPSBub2RlSXRlcmF0b3IubmV4dE5vZGUoKSkpIHtcbiAgICAvLyAgICAgICAgIHZhciBrZXkgPSBnZXROb2RlS2V5KGVsKTtcbiAgICAvLyAgICAgICAgIGlmIChrZXkpIHtcbiAgICAvLyAgICAgICAgICAgICBmcm9tTm9kZXNMb29rdXBba2V5XSA9IGVsO1xuICAgIC8vICAgICAgICAgfVxuICAgIC8vICAgICB9XG4gICAgLy8gfVxuXG4gICAgZnVuY3Rpb24gaW5kZXhUcmVlKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSQxKSB7XG4gICAgICAgIHZhciBjdXJDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgd2hpbGUgKGN1ckNoaWxkKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGdldE5vZGVLZXkoY3VyQ2hpbGQpO1xuICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGZyb21Ob2Rlc0xvb2t1cFtrZXldID0gY3VyQ2hpbGQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gV2FsayByZWN1cnNpdmVseVxuICAgICAgICAgIGluZGV4VHJlZShjdXJDaGlsZCk7XG5cbiAgICAgICAgICBjdXJDaGlsZCA9IGN1ckNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5kZXhUcmVlKGZyb21Ob2RlKTtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZU5vZGVBZGRlZChlbCkge1xuICAgICAgb25Ob2RlQWRkZWQoZWwpO1xuXG4gICAgICB2YXIgY3VyQ2hpbGQgPSBlbC5maXJzdENoaWxkO1xuICAgICAgd2hpbGUgKGN1ckNoaWxkKSB7XG4gICAgICAgIHZhciBuZXh0U2libGluZyA9IGN1ckNoaWxkLm5leHRTaWJsaW5nO1xuXG4gICAgICAgIHZhciBrZXkgPSBnZXROb2RlS2V5KGN1ckNoaWxkKTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgIHZhciB1bm1hdGNoZWRGcm9tRWwgPSBmcm9tTm9kZXNMb29rdXBba2V5XTtcbiAgICAgICAgICAvLyBpZiB3ZSBmaW5kIGEgZHVwbGljYXRlICNpZCBub2RlIGluIGNhY2hlLCByZXBsYWNlIGBlbGAgd2l0aCBjYWNoZSB2YWx1ZVxuICAgICAgICAgIC8vIGFuZCBtb3JwaCBpdCB0byB0aGUgY2hpbGQgbm9kZS5cbiAgICAgICAgICBpZiAodW5tYXRjaGVkRnJvbUVsICYmIGNvbXBhcmVOb2RlTmFtZXMoY3VyQ2hpbGQsIHVubWF0Y2hlZEZyb21FbCkpIHtcbiAgICAgICAgICAgIGN1ckNoaWxkLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHVubWF0Y2hlZEZyb21FbCwgY3VyQ2hpbGQpO1xuICAgICAgICAgICAgbW9ycGhFbCh1bm1hdGNoZWRGcm9tRWwsIGN1ckNoaWxkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlTm9kZUFkZGVkKGN1ckNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gcmVjdXJzaXZlbHkgY2FsbCBmb3IgY3VyQ2hpbGQgYW5kIGl0J3MgY2hpbGRyZW4gdG8gc2VlIGlmIHdlIGZpbmQgc29tZXRoaW5nIGluXG4gICAgICAgICAgLy8gZnJvbU5vZGVzTG9va3VwXG4gICAgICAgICAgaGFuZGxlTm9kZUFkZGVkKGN1ckNoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1ckNoaWxkID0gbmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYW51cEZyb21FbChmcm9tRWwsIGN1ckZyb21Ob2RlQ2hpbGQsIGN1ckZyb21Ob2RlS2V5KSB7XG4gICAgICAvLyBXZSBoYXZlIHByb2Nlc3NlZCBhbGwgb2YgdGhlIFwidG8gbm9kZXNcIi4gSWYgY3VyRnJvbU5vZGVDaGlsZCBpc1xuICAgICAgLy8gbm9uLW51bGwgdGhlbiB3ZSBzdGlsbCBoYXZlIHNvbWUgZnJvbSBub2RlcyBsZWZ0IG92ZXIgdGhhdCBuZWVkXG4gICAgICAvLyB0byBiZSByZW1vdmVkXG4gICAgICB3aGlsZSAoY3VyRnJvbU5vZGVDaGlsZCkge1xuICAgICAgICB2YXIgZnJvbU5leHRTaWJsaW5nID0gY3VyRnJvbU5vZGVDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgaWYgKChjdXJGcm9tTm9kZUtleSA9IGdldE5vZGVLZXkoY3VyRnJvbU5vZGVDaGlsZCkpKSB7XG4gICAgICAgICAgLy8gU2luY2UgdGhlIG5vZGUgaXMga2V5ZWQgaXQgbWlnaHQgYmUgbWF0Y2hlZCB1cCBsYXRlciBzbyB3ZSBkZWZlclxuICAgICAgICAgIC8vIHRoZSBhY3R1YWwgcmVtb3ZhbCB0byBsYXRlclxuICAgICAgICAgIGFkZEtleWVkUmVtb3ZhbChjdXJGcm9tTm9kZUtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTk9URTogd2Ugc2tpcCBuZXN0ZWQga2V5ZWQgbm9kZXMgZnJvbSBiZWluZyByZW1vdmVkIHNpbmNlIHRoZXJlIGlzXG4gICAgICAgICAgLy8gICAgICAgc3RpbGwgYSBjaGFuY2UgdGhleSB3aWxsIGJlIG1hdGNoZWQgdXAgbGF0ZXJcbiAgICAgICAgICByZW1vdmVOb2RlKGN1ckZyb21Ob2RlQ2hpbGQsIGZyb21FbCwgdHJ1ZSAvKiBza2lwIGtleWVkIG5vZGVzICovKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vcnBoRWwoZnJvbUVsLCB0b0VsLCBjaGlsZHJlbk9ubHkpIHtcbiAgICAgIHZhciB0b0VsS2V5ID0gZ2V0Tm9kZUtleSh0b0VsKTtcblxuICAgICAgaWYgKHRvRWxLZXkpIHtcbiAgICAgICAgLy8gSWYgYW4gZWxlbWVudCB3aXRoIGFuIElEIGlzIGJlaW5nIG1vcnBoZWQgdGhlbiBpdCB3aWxsIGJlIGluIHRoZSBmaW5hbFxuICAgICAgICAvLyBET00gc28gY2xlYXIgaXQgb3V0IG9mIHRoZSBzYXZlZCBlbGVtZW50cyBjb2xsZWN0aW9uXG4gICAgICAgIGRlbGV0ZSBmcm9tTm9kZXNMb29rdXBbdG9FbEtleV07XG4gICAgICB9XG5cbiAgICAgIGlmICghY2hpbGRyZW5Pbmx5KSB7XG4gICAgICAgIC8vIG9wdGlvbmFsXG4gICAgICAgIHZhciBiZWZvcmVVcGRhdGVSZXN1bHQgPSBvbkJlZm9yZUVsVXBkYXRlZChmcm9tRWwsIHRvRWwpO1xuICAgICAgICBpZiAoYmVmb3JlVXBkYXRlUmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChiZWZvcmVVcGRhdGVSZXN1bHQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgIGZyb21FbCA9IGJlZm9yZVVwZGF0ZVJlc3VsdDtcbiAgICAgICAgICAvLyByZWluZGV4IHRoZSBuZXcgZnJvbUVsIGluIGNhc2UgaXQncyBub3QgaW4gdGhlIHNhbWVcbiAgICAgICAgICAvLyB0cmVlIGFzIHRoZSBvcmlnaW5hbCBmcm9tRWxcbiAgICAgICAgICAvLyAoUGhvZW5peCBMaXZlVmlldyBzb21ldGltZXMgcmV0dXJucyBhIGNsb25lZCB0cmVlLFxuICAgICAgICAgIC8vICBidXQga2V5ZWQgbG9va3VwcyB3b3VsZCBzdGlsbCBwb2ludCB0byB0aGUgb3JpZ2luYWwgdHJlZSlcbiAgICAgICAgICBpbmRleFRyZWUoZnJvbUVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSBhdHRyaWJ1dGVzIG9uIG9yaWdpbmFsIERPTSBlbGVtZW50IGZpcnN0XG4gICAgICAgIG1vcnBoQXR0cnMoZnJvbUVsLCB0b0VsKTtcbiAgICAgICAgLy8gb3B0aW9uYWxcbiAgICAgICAgb25FbFVwZGF0ZWQoZnJvbUVsKTtcblxuICAgICAgICBpZiAob25CZWZvcmVFbENoaWxkcmVuVXBkYXRlZChmcm9tRWwsIHRvRWwpID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZnJvbUVsLm5vZGVOYW1lICE9PSAnVEVYVEFSRUEnKSB7XG4gICAgICAgIG1vcnBoQ2hpbGRyZW4oZnJvbUVsLCB0b0VsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwZWNpYWxFbEhhbmRsZXJzLlRFWFRBUkVBKGZyb21FbCwgdG9FbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9ycGhDaGlsZHJlbihmcm9tRWwsIHRvRWwpIHtcbiAgICAgIHZhciBza2lwRnJvbSA9IHNraXBGcm9tQ2hpbGRyZW4oZnJvbUVsLCB0b0VsKTtcbiAgICAgIHZhciBjdXJUb05vZGVDaGlsZCA9IHRvRWwuZmlyc3RDaGlsZDtcbiAgICAgIHZhciBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbUVsLmZpcnN0Q2hpbGQ7XG4gICAgICB2YXIgY3VyVG9Ob2RlS2V5O1xuICAgICAgdmFyIGN1ckZyb21Ob2RlS2V5O1xuXG4gICAgICB2YXIgZnJvbU5leHRTaWJsaW5nO1xuICAgICAgdmFyIHRvTmV4dFNpYmxpbmc7XG4gICAgICB2YXIgbWF0Y2hpbmdGcm9tRWw7XG5cbiAgICAgIC8vIHdhbGsgdGhlIGNoaWxkcmVuXG4gICAgICBvdXRlcjogd2hpbGUgKGN1clRvTm9kZUNoaWxkKSB7XG4gICAgICAgIHRvTmV4dFNpYmxpbmcgPSBjdXJUb05vZGVDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgY3VyVG9Ob2RlS2V5ID0gZ2V0Tm9kZUtleShjdXJUb05vZGVDaGlsZCk7XG5cbiAgICAgICAgLy8gd2FsayB0aGUgZnJvbU5vZGUgY2hpbGRyZW4gYWxsIHRoZSB3YXkgdGhyb3VnaFxuICAgICAgICB3aGlsZSAoIXNraXBGcm9tICYmIGN1ckZyb21Ob2RlQ2hpbGQpIHtcbiAgICAgICAgICBmcm9tTmV4dFNpYmxpbmcgPSBjdXJGcm9tTm9kZUNoaWxkLm5leHRTaWJsaW5nO1xuXG4gICAgICAgICAgaWYgKGN1clRvTm9kZUNoaWxkLmlzU2FtZU5vZGUgJiYgY3VyVG9Ob2RlQ2hpbGQuaXNTYW1lTm9kZShjdXJGcm9tTm9kZUNoaWxkKSkge1xuICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSB0b05leHRTaWJsaW5nO1xuICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1ckZyb21Ob2RlS2V5ID0gZ2V0Tm9kZUtleShjdXJGcm9tTm9kZUNoaWxkKTtcblxuICAgICAgICAgIHZhciBjdXJGcm9tTm9kZVR5cGUgPSBjdXJGcm9tTm9kZUNoaWxkLm5vZGVUeXBlO1xuXG4gICAgICAgICAgLy8gdGhpcyBtZWFucyBpZiB0aGUgY3VyRnJvbU5vZGVDaGlsZCBkb2VzbnQgaGF2ZSBhIG1hdGNoIHdpdGggdGhlIGN1clRvTm9kZUNoaWxkXG4gICAgICAgICAgdmFyIGlzQ29tcGF0aWJsZSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGlmIChjdXJGcm9tTm9kZVR5cGUgPT09IGN1clRvTm9kZUNoaWxkLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgLy8gQm90aCBub2RlcyBiZWluZyBjb21wYXJlZCBhcmUgRWxlbWVudCBub2Rlc1xuXG4gICAgICAgICAgICAgIGlmIChjdXJUb05vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgdGFyZ2V0IG5vZGUgaGFzIGEga2V5IHNvIHdlIHdhbnQgdG8gbWF0Y2ggaXQgdXAgd2l0aCB0aGUgY29ycmVjdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gaW4gdGhlIG9yaWdpbmFsIERPTSB0cmVlXG4gICAgICAgICAgICAgICAgaWYgKGN1clRvTm9kZUtleSAhPT0gY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IGVsZW1lbnQgaW4gdGhlIG9yaWdpbmFsIERPTSB0cmVlIGRvZXMgbm90IGhhdmUgYSBtYXRjaGluZyBrZXkgc29cbiAgICAgICAgICAgICAgICAgIC8vIGxldCdzIGNoZWNrIG91ciBsb29rdXAgdG8gc2VlIGlmIHRoZXJlIGlzIGEgbWF0Y2hpbmcgZWxlbWVudCBpbiB0aGUgb3JpZ2luYWxcbiAgICAgICAgICAgICAgICAgIC8vIERPTSB0cmVlXG4gICAgICAgICAgICAgICAgICBpZiAoKG1hdGNoaW5nRnJvbUVsID0gZnJvbU5vZGVzTG9va3VwW2N1clRvTm9kZUtleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcm9tTmV4dFNpYmxpbmcgPT09IG1hdGNoaW5nRnJvbUVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBzaW5nbGUgZWxlbWVudCByZW1vdmFscy4gVG8gYXZvaWQgcmVtb3ZpbmcgdGhlIG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gRE9NIG5vZGUgb3V0IG9mIHRoZSB0cmVlIChzaW5jZSB0aGF0IGNhbiBicmVhayBDU1MgdHJhbnNpdGlvbnMsIGV0Yy4pLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHdpbGwgaW5zdGVhZCBkaXNjYXJkIHRoZSBjdXJyZW50IG5vZGUgYW5kIHdhaXQgdW50aWwgdGhlIG5leHRcbiAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVyYXRpb24gdG8gcHJvcGVybHkgbWF0Y2ggdXAgdGhlIGtleWVkIHRhcmdldCBlbGVtZW50IHdpdGggaXRzIG1hdGNoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZWxlbWVudCBpbiB0aGUgb3JpZ2luYWwgdHJlZVxuICAgICAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGZvdW5kIGEgbWF0Y2hpbmcga2V5ZWQgZWxlbWVudCBzb21ld2hlcmUgaW4gdGhlIG9yaWdpbmFsIERPTSB0cmVlLlxuICAgICAgICAgICAgICAgICAgICAgIC8vIExldCdzIG1vdmUgdGhlIG9yaWdpbmFsIERPTSBub2RlIGludG8gdGhlIGN1cnJlbnQgcG9zaXRpb24gYW5kIG1vcnBoXG4gICAgICAgICAgICAgICAgICAgICAgLy8gaXQuXG5cbiAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBXZSB1c2UgaW5zZXJ0QmVmb3JlIGluc3RlYWQgb2YgcmVwbGFjZUNoaWxkIGJlY2F1c2Ugd2Ugd2FudCB0byBnbyB0aHJvdWdoXG4gICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGByZW1vdmVOb2RlKClgIGZ1bmN0aW9uIGZvciB0aGUgbm9kZSB0aGF0IGlzIGJlaW5nIGRpc2NhcmRlZCBzbyB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgLy8gYWxsIGxpZmVjeWNsZSBob29rcyBhcmUgY29ycmVjdGx5IGludm9rZWRcbiAgICAgICAgICAgICAgICAgICAgICBmcm9tRWwuaW5zZXJ0QmVmb3JlKG1hdGNoaW5nRnJvbUVsLCBjdXJGcm9tTm9kZUNoaWxkKTtcblxuICAgICAgICAgICAgICAgICAgICAgIC8vIGZyb21OZXh0U2libGluZyA9IGN1ckZyb21Ob2RlQ2hpbGQubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBub2RlIGlzIGtleWVkIGl0IG1pZ2h0IGJlIG1hdGNoZWQgdXAgbGF0ZXIgc28gd2UgZGVmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBhY3R1YWwgcmVtb3ZhbCB0byBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkS2V5ZWRSZW1vdmFsKGN1ckZyb21Ob2RlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogd2Ugc2tpcCBuZXN0ZWQga2V5ZWQgbm9kZXMgZnJvbSBiZWluZyByZW1vdmVkIHNpbmNlIHRoZXJlIGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBzdGlsbCBhIGNoYW5jZSB0aGV5IHdpbGwgYmUgbWF0Y2hlZCB1cCBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZShjdXJGcm9tTm9kZUNoaWxkLCBmcm9tRWwsIHRydWUgLyogc2tpcCBrZXllZCBub2RlcyAqLyk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IG1hdGNoaW5nRnJvbUVsO1xuICAgICAgICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlS2V5ID0gZ2V0Tm9kZUtleShjdXJGcm9tTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG5vZGVzIGFyZSBub3QgY29tcGF0aWJsZSBzaW5jZSB0aGUgXCJ0b1wiIG5vZGUgaGFzIGEga2V5IGFuZCB0aGVyZVxuICAgICAgICAgICAgICAgICAgICAvLyBpcyBubyBtYXRjaGluZyBrZXllZCBub2RlIGluIHRoZSBzb3VyY2UgdHJlZVxuICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgb3JpZ2luYWwgaGFzIGEga2V5XG4gICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSBpc0NvbXBhdGlibGUgIT09IGZhbHNlICYmIGNvbXBhcmVOb2RlTmFtZXMoY3VyRnJvbU5vZGVDaGlsZCwgY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICBpZiAoaXNDb21wYXRpYmxlKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZm91bmQgY29tcGF0aWJsZSBET00gZWxlbWVudHMgc28gdHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgXCJmcm9tXCIgbm9kZSB0byBtYXRjaCB0aGUgY3VycmVudFxuICAgICAgICAgICAgICAgIC8vIHRhcmdldCBET00gbm9kZS5cbiAgICAgICAgICAgICAgICAvLyBNT1JQSFxuICAgICAgICAgICAgICAgIG1vcnBoRWwoY3VyRnJvbU5vZGVDaGlsZCwgY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyRnJvbU5vZGVUeXBlID09PSBURVhUX05PREUgfHwgY3VyRnJvbU5vZGVUeXBlID09IENPTU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAvLyBCb3RoIG5vZGVzIGJlaW5nIGNvbXBhcmVkIGFyZSBUZXh0IG9yIENvbW1lbnQgbm9kZXNcbiAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgLy8gU2ltcGx5IHVwZGF0ZSBub2RlVmFsdWUgb24gdGhlIG9yaWdpbmFsIG5vZGUgdG9cbiAgICAgICAgICAgICAgLy8gY2hhbmdlIHRoZSB0ZXh0IHZhbHVlXG4gICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZUNoaWxkLm5vZGVWYWx1ZSAhPT0gY3VyVG9Ob2RlQ2hpbGQubm9kZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZC5ub2RlVmFsdWUgPSBjdXJUb05vZGVDaGlsZC5ub2RlVmFsdWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc0NvbXBhdGlibGUpIHtcbiAgICAgICAgICAgIC8vIEFkdmFuY2UgYm90aCB0aGUgXCJ0b1wiIGNoaWxkIGFuZCB0aGUgXCJmcm9tXCIgY2hpbGQgc2luY2Ugd2UgZm91bmQgYSBtYXRjaFxuICAgICAgICAgICAgLy8gTm90aGluZyBlbHNlIHRvIGRvIGFzIHdlIGFscmVhZHkgcmVjdXJzaXZlbHkgY2FsbGVkIG1vcnBoQ2hpbGRyZW4gYWJvdmVcbiAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gdG9OZXh0U2libGluZztcbiAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBObyBjb21wYXRpYmxlIG1hdGNoIHNvIHJlbW92ZSB0aGUgb2xkIG5vZGUgZnJvbSB0aGUgRE9NIGFuZCBjb250aW51ZSB0cnlpbmcgdG8gZmluZCBhXG4gICAgICAgICAgLy8gbWF0Y2ggaW4gdGhlIG9yaWdpbmFsIERPTS4gSG93ZXZlciwgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSBmcm9tIG5vZGUgaXMgbm90IGtleWVkXG4gICAgICAgICAgLy8gc2luY2UgaXQgaXMgcG9zc2libGUgdGhhdCBhIGtleWVkIG5vZGUgbWlnaHQgbWF0Y2ggdXAgd2l0aCBhIG5vZGUgc29tZXdoZXJlIGVsc2UgaW4gdGhlXG4gICAgICAgICAgLy8gdGFyZ2V0IHRyZWUgYW5kIHdlIGRvbid0IHdhbnQgdG8gZGlzY2FyZCBpdCBqdXN0IHlldCBzaW5jZSBpdCBzdGlsbCBtaWdodCBmaW5kIGFcbiAgICAgICAgICAvLyBob21lIGluIHRoZSBmaW5hbCBET00gdHJlZS4gQWZ0ZXIgZXZlcnl0aGluZyBpcyBkb25lIHdlIHdpbGwgcmVtb3ZlIGFueSBrZXllZCBub2Rlc1xuICAgICAgICAgIC8vIHRoYXQgZGlkbid0IGZpbmQgYSBob21lXG4gICAgICAgICAgaWYgKGN1ckZyb21Ob2RlS2V5KSB7XG4gICAgICAgICAgICAvLyBTaW5jZSB0aGUgbm9kZSBpcyBrZXllZCBpdCBtaWdodCBiZSBtYXRjaGVkIHVwIGxhdGVyIHNvIHdlIGRlZmVyXG4gICAgICAgICAgICAvLyB0aGUgYWN0dWFsIHJlbW92YWwgdG8gbGF0ZXJcbiAgICAgICAgICAgIGFkZEtleWVkUmVtb3ZhbChjdXJGcm9tTm9kZUtleSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IHdlIHNraXAgbmVzdGVkIGtleWVkIG5vZGVzIGZyb20gYmVpbmcgcmVtb3ZlZCBzaW5jZSB0aGVyZSBpc1xuICAgICAgICAgICAgLy8gICAgICAgc3RpbGwgYSBjaGFuY2UgdGhleSB3aWxsIGJlIG1hdGNoZWQgdXAgbGF0ZXJcbiAgICAgICAgICAgIHJlbW92ZU5vZGUoY3VyRnJvbU5vZGVDaGlsZCwgZnJvbUVsLCB0cnVlIC8qIHNraXAga2V5ZWQgbm9kZXMgKi8pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICAgIH0gLy8gRU5EOiB3aGlsZShjdXJGcm9tTm9kZUNoaWxkKSB7fVxuXG4gICAgICAgIC8vIElmIHdlIGdvdCB0aGlzIGZhciB0aGVuIHdlIGRpZCBub3QgZmluZCBhIGNhbmRpZGF0ZSBtYXRjaCBmb3JcbiAgICAgICAgLy8gb3VyIFwidG8gbm9kZVwiIGFuZCB3ZSBleGhhdXN0ZWQgYWxsIG9mIHRoZSBjaGlsZHJlbiBcImZyb21cIlxuICAgICAgICAvLyBub2Rlcy4gVGhlcmVmb3JlLCB3ZSB3aWxsIGp1c3QgYXBwZW5kIHRoZSBjdXJyZW50IFwidG9cIiBub2RlXG4gICAgICAgIC8vIHRvIHRoZSBlbmRcbiAgICAgICAgaWYgKGN1clRvTm9kZUtleSAmJiAobWF0Y2hpbmdGcm9tRWwgPSBmcm9tTm9kZXNMb29rdXBbY3VyVG9Ob2RlS2V5XSkgJiYgY29tcGFyZU5vZGVOYW1lcyhtYXRjaGluZ0Zyb21FbCwgY3VyVG9Ob2RlQ2hpbGQpKSB7XG4gICAgICAgICAgLy8gTU9SUEhcbiAgICAgICAgICBpZighc2tpcEZyb20peyBhZGRDaGlsZChmcm9tRWwsIG1hdGNoaW5nRnJvbUVsKTsgfVxuICAgICAgICAgIG1vcnBoRWwobWF0Y2hpbmdGcm9tRWwsIGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb25CZWZvcmVOb2RlQWRkZWRSZXN1bHQgPSBvbkJlZm9yZU5vZGVBZGRlZChjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgaWYgKG9uQmVmb3JlTm9kZUFkZGVkUmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKG9uQmVmb3JlTm9kZUFkZGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gb25CZWZvcmVOb2RlQWRkZWRSZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjdXJUb05vZGVDaGlsZC5hY3R1YWxpemUpIHtcbiAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSBjdXJUb05vZGVDaGlsZC5hY3R1YWxpemUoZnJvbUVsLm93bmVyRG9jdW1lbnQgfHwgZG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZENoaWxkKGZyb21FbCwgY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgaGFuZGxlTm9kZUFkZGVkKGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdXJUb05vZGVDaGlsZCA9IHRvTmV4dFNpYmxpbmc7XG4gICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIGNsZWFudXBGcm9tRWwoZnJvbUVsLCBjdXJGcm9tTm9kZUNoaWxkLCBjdXJGcm9tTm9kZUtleSk7XG5cbiAgICAgIHZhciBzcGVjaWFsRWxIYW5kbGVyID0gc3BlY2lhbEVsSGFuZGxlcnNbZnJvbUVsLm5vZGVOYW1lXTtcbiAgICAgIGlmIChzcGVjaWFsRWxIYW5kbGVyKSB7XG4gICAgICAgIHNwZWNpYWxFbEhhbmRsZXIoZnJvbUVsLCB0b0VsKTtcbiAgICAgIH1cbiAgICB9IC8vIEVORDogbW9ycGhDaGlsZHJlbiguLi4pXG5cbiAgICB2YXIgbW9ycGhlZE5vZGUgPSBmcm9tTm9kZTtcbiAgICB2YXIgbW9ycGhlZE5vZGVUeXBlID0gbW9ycGhlZE5vZGUubm9kZVR5cGU7XG4gICAgdmFyIHRvTm9kZVR5cGUgPSB0b05vZGUubm9kZVR5cGU7XG5cbiAgICBpZiAoIWNoaWxkcmVuT25seSkge1xuICAgICAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIHdlIGFyZSBnaXZlbiB0d28gRE9NIG5vZGVzIHRoYXQgYXJlIG5vdFxuICAgICAgLy8gY29tcGF0aWJsZSAoZS5nLiA8ZGl2PiAtLT4gPHNwYW4+IG9yIDxkaXY+IC0tPiBURVhUKVxuICAgICAgaWYgKG1vcnBoZWROb2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIGlmICh0b05vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgICBpZiAoIWNvbXBhcmVOb2RlTmFtZXMoZnJvbU5vZGUsIHRvTm9kZSkpIHtcbiAgICAgICAgICAgIG9uTm9kZURpc2NhcmRlZChmcm9tTm9kZSk7XG4gICAgICAgICAgICBtb3JwaGVkTm9kZSA9IG1vdmVDaGlsZHJlbihmcm9tTm9kZSwgY3JlYXRlRWxlbWVudE5TKHRvTm9kZS5ub2RlTmFtZSwgdG9Ob2RlLm5hbWVzcGFjZVVSSSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBHb2luZyBmcm9tIGFuIGVsZW1lbnQgbm9kZSB0byBhIHRleHQgbm9kZVxuICAgICAgICAgIG1vcnBoZWROb2RlID0gdG9Ob2RlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG1vcnBoZWROb2RlVHlwZSA9PT0gVEVYVF9OT0RFIHx8IG1vcnBoZWROb2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7IC8vIFRleHQgb3IgY29tbWVudCBub2RlXG4gICAgICAgIGlmICh0b05vZGVUeXBlID09PSBtb3JwaGVkTm9kZVR5cGUpIHtcbiAgICAgICAgICBpZiAobW9ycGhlZE5vZGUubm9kZVZhbHVlICE9PSB0b05vZGUubm9kZVZhbHVlKSB7XG4gICAgICAgICAgICBtb3JwaGVkTm9kZS5ub2RlVmFsdWUgPSB0b05vZGUubm9kZVZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBtb3JwaGVkTm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUZXh0IG5vZGUgdG8gc29tZXRoaW5nIGVsc2VcbiAgICAgICAgICBtb3JwaGVkTm9kZSA9IHRvTm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtb3JwaGVkTm9kZSA9PT0gdG9Ob2RlKSB7XG4gICAgICAvLyBUaGUgXCJ0byBub2RlXCIgd2FzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIFwiZnJvbSBub2RlXCIgc28gd2UgaGFkIHRvXG4gICAgICAvLyB0b3NzIG91dCB0aGUgXCJmcm9tIG5vZGVcIiBhbmQgdXNlIHRoZSBcInRvIG5vZGVcIlxuICAgICAgb25Ob2RlRGlzY2FyZGVkKGZyb21Ob2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRvTm9kZS5pc1NhbWVOb2RlICYmIHRvTm9kZS5pc1NhbWVOb2RlKG1vcnBoZWROb2RlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG1vcnBoRWwobW9ycGhlZE5vZGUsIHRvTm9kZSwgY2hpbGRyZW5Pbmx5KTtcblxuICAgICAgLy8gV2Ugbm93IG5lZWQgdG8gbG9vcCBvdmVyIGFueSBrZXllZCBub2RlcyB0aGF0IG1pZ2h0IG5lZWQgdG8gYmVcbiAgICAgIC8vIHJlbW92ZWQuIFdlIG9ubHkgZG8gdGhlIHJlbW92YWwgaWYgd2Uga25vdyB0aGF0IHRoZSBrZXllZCBub2RlXG4gICAgICAvLyBuZXZlciBmb3VuZCBhIG1hdGNoLiBXaGVuIGEga2V5ZWQgbm9kZSBpcyBtYXRjaGVkIHVwIHdlIHJlbW92ZVxuICAgICAgLy8gaXQgb3V0IG9mIGZyb21Ob2Rlc0xvb2t1cCBhbmQgd2UgdXNlIGZyb21Ob2Rlc0xvb2t1cCB0byBkZXRlcm1pbmVcbiAgICAgIC8vIGlmIGEga2V5ZWQgbm9kZSBoYXMgYmVlbiBtYXRjaGVkIHVwIG9yIG5vdFxuICAgICAgaWYgKGtleWVkUmVtb3ZhbExpc3QpIHtcbiAgICAgICAgZm9yICh2YXIgaT0wLCBsZW49a2V5ZWRSZW1vdmFsTGlzdC5sZW5ndGg7IGk8bGVuOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxUb1JlbW92ZSA9IGZyb21Ob2Rlc0xvb2t1cFtrZXllZFJlbW92YWxMaXN0W2ldXTtcbiAgICAgICAgICBpZiAoZWxUb1JlbW92ZSkge1xuICAgICAgICAgICAgcmVtb3ZlTm9kZShlbFRvUmVtb3ZlLCBlbFRvUmVtb3ZlLnBhcmVudE5vZGUsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNoaWxkcmVuT25seSAmJiBtb3JwaGVkTm9kZSAhPT0gZnJvbU5vZGUgJiYgZnJvbU5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgaWYgKG1vcnBoZWROb2RlLmFjdHVhbGl6ZSkge1xuICAgICAgICBtb3JwaGVkTm9kZSA9IG1vcnBoZWROb2RlLmFjdHVhbGl6ZShmcm9tTm9kZS5vd25lckRvY3VtZW50IHx8IGRvYyk7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSBoYWQgdG8gc3dhcCBvdXQgdGhlIGZyb20gbm9kZSB3aXRoIGEgbmV3IG5vZGUgYmVjYXVzZSB0aGUgb2xkXG4gICAgICAvLyBub2RlIHdhcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSB0YXJnZXQgbm9kZSB0aGVuIHdlIG5lZWQgdG9cbiAgICAgIC8vIHJlcGxhY2UgdGhlIG9sZCBET00gbm9kZSBpbiB0aGUgb3JpZ2luYWwgRE9NIHRyZWUuIFRoaXMgaXMgb25seVxuICAgICAgLy8gcG9zc2libGUgaWYgdGhlIG9yaWdpbmFsIERPTSBub2RlIHdhcyBwYXJ0IG9mIGEgRE9NIHRyZWUgd2hpY2hcbiAgICAgIC8vIHdlIGtub3cgaXMgdGhlIGNhc2UgaWYgaXQgaGFzIGEgcGFyZW50IG5vZGUuXG4gICAgICBmcm9tTm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChtb3JwaGVkTm9kZSwgZnJvbU5vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBtb3JwaGVkTm9kZTtcbiAgfTtcbn1cblxudmFyIG1vcnBoZG9tID0gbW9ycGhkb21GYWN0b3J5KG1vcnBoQXR0cnMpO1xuXG5leHBvcnQgZGVmYXVsdCBtb3JwaGRvbTtcbiIsICJpbXBvcnQge1xuICBQSFhfQ09NUE9ORU5ULFxuICBQSFhfUFJVTkUsXG4gIFBIWF9ST09UX0lELFxuICBQSFhfU0VTU0lPTixcbiAgUEhYX1NLSVAsXG4gIFBIWF9NQUdJQ19JRCxcbiAgUEhYX1NUQVRJQyxcbiAgUEhYX1RSSUdHRVJfQUNUSU9OLFxuICBQSFhfVVBEQVRFLFxuICBQSFhfUkVGX1NSQyxcbiAgUEhYX1JFRl9MT0NLLFxuICBQSFhfU1RSRUFNLFxuICBQSFhfU1RSRUFNX1JFRixcbiAgUEhYX1ZJRVdQT1JUX1RPUCxcbiAgUEhYX1ZJRVdQT1JUX0JPVFRPTSxcbiAgUEhYX1BPUlRBTCxcbiAgUEhYX1RFTEVQT1JURURfUkVGLFxuICBQSFhfVEVMRVBPUlRFRF9TUkMsXG4gIFBIWF9SVU5USU1FX0hPT0ssXG59IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuXG5pbXBvcnQgeyBkZXRlY3REdXBsaWNhdGVJZHMsIGRldGVjdEludmFsaWRTdHJlYW1JbnNlcnRzLCBpc0NpZCB9IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgRWxlbWVudFJlZiBmcm9tIFwiLi9lbGVtZW50X3JlZlwiO1xuaW1wb3J0IERPTSBmcm9tIFwiLi9kb21cIjtcbmltcG9ydCBET01Qb3N0TW9ycGhSZXN0b3JlciBmcm9tIFwiLi9kb21fcG9zdF9tb3JwaF9yZXN0b3JlclwiO1xuaW1wb3J0IG1vcnBoZG9tIGZyb20gXCJtb3JwaGRvbVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBET01QYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHZpZXcsIGNvbnRhaW5lciwgaWQsIGh0bWwsIHN0cmVhbXMsIHRhcmdldENJRCwgb3B0cyA9IHt9KSB7XG4gICAgdGhpcy52aWV3ID0gdmlldztcbiAgICB0aGlzLmxpdmVTb2NrZXQgPSB2aWV3LmxpdmVTb2NrZXQ7XG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMucm9vdElEID0gdmlldy5yb290LmlkO1xuICAgIHRoaXMuaHRtbCA9IGh0bWw7XG4gICAgdGhpcy5zdHJlYW1zID0gc3RyZWFtcztcbiAgICB0aGlzLnN0cmVhbUluc2VydHMgPSB7fTtcbiAgICB0aGlzLnN0cmVhbUNvbXBvbmVudFJlc3RvcmUgPSB7fTtcbiAgICB0aGlzLnRhcmdldENJRCA9IHRhcmdldENJRDtcbiAgICB0aGlzLmNpZFBhdGNoID0gaXNDaWQodGhpcy50YXJnZXRDSUQpO1xuICAgIHRoaXMucGVuZGluZ1JlbW92ZXMgPSBbXTtcbiAgICB0aGlzLnBoeFJlbW92ZSA9IHRoaXMubGl2ZVNvY2tldC5iaW5kaW5nKFwicmVtb3ZlXCIpO1xuICAgIHRoaXMudGFyZ2V0Q29udGFpbmVyID0gdGhpcy5pc0NJRFBhdGNoKClcbiAgICAgID8gdGhpcy50YXJnZXRDSURDb250YWluZXIoaHRtbClcbiAgICAgIDogY29udGFpbmVyO1xuICAgIHRoaXMuY2FsbGJhY2tzID0ge1xuICAgICAgYmVmb3JlYWRkZWQ6IFtdLFxuICAgICAgYmVmb3JldXBkYXRlZDogW10sXG4gICAgICBiZWZvcmVwaHhDaGlsZEFkZGVkOiBbXSxcbiAgICAgIGFmdGVyYWRkZWQ6IFtdLFxuICAgICAgYWZ0ZXJ1cGRhdGVkOiBbXSxcbiAgICAgIGFmdGVyZGlzY2FyZGVkOiBbXSxcbiAgICAgIGFmdGVycGh4Q2hpbGRBZGRlZDogW10sXG4gICAgICBhZnRlcnRyYW5zaXRpb25zRGlzY2FyZGVkOiBbXSxcbiAgICB9O1xuICAgIHRoaXMud2l0aENoaWxkcmVuID0gb3B0cy53aXRoQ2hpbGRyZW4gfHwgb3B0cy51bmRvUmVmIHx8IGZhbHNlO1xuICAgIHRoaXMudW5kb1JlZiA9IG9wdHMudW5kb1JlZjtcbiAgfVxuXG4gIGJlZm9yZShraW5kLCBjYWxsYmFjaykge1xuICAgIHRoaXMuY2FsbGJhY2tzW2BiZWZvcmUke2tpbmR9YF0ucHVzaChjYWxsYmFjayk7XG4gIH1cbiAgYWZ0ZXIoa2luZCwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmNhbGxiYWNrc1tgYWZ0ZXIke2tpbmR9YF0ucHVzaChjYWxsYmFjayk7XG4gIH1cblxuICB0cmFja0JlZm9yZShraW5kLCAuLi5hcmdzKSB7XG4gICAgdGhpcy5jYWxsYmFja3NbYGJlZm9yZSR7a2luZH1gXS5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soLi4uYXJncykpO1xuICB9XG5cbiAgdHJhY2tBZnRlcihraW5kLCAuLi5hcmdzKSB7XG4gICAgdGhpcy5jYWxsYmFja3NbYGFmdGVyJHtraW5kfWBdLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayguLi5hcmdzKSk7XG4gIH1cblxuICBtYXJrUHJ1bmFibGVDb250ZW50Rm9yUmVtb3ZhbCgpIHtcbiAgICBjb25zdCBwaHhVcGRhdGUgPSB0aGlzLmxpdmVTb2NrZXQuYmluZGluZyhQSFhfVVBEQVRFKTtcbiAgICBET00uYWxsKFxuICAgICAgdGhpcy5jb250YWluZXIsXG4gICAgICBgWyR7cGh4VXBkYXRlfT1hcHBlbmRdID4gKiwgWyR7cGh4VXBkYXRlfT1wcmVwZW5kXSA+ICpgLFxuICAgICAgKGVsKSA9PiB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShQSFhfUFJVTkUsIFwiXCIpO1xuICAgICAgfSxcbiAgICApO1xuICB9XG5cbiAgcGVyZm9ybShpc0pvaW5QYXRjaCkge1xuICAgIGNvbnN0IHsgdmlldywgbGl2ZVNvY2tldCwgaHRtbCwgY29udGFpbmVyIH0gPSB0aGlzO1xuICAgIGxldCB0YXJnZXRDb250YWluZXIgPSB0aGlzLnRhcmdldENvbnRhaW5lcjtcblxuICAgIGlmICh0aGlzLmlzQ0lEUGF0Y2goKSAmJiAhdGhpcy50YXJnZXRDb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0NJRFBhdGNoKCkpIHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXhfbGl2ZV92aWV3L3B1bGwvMzk0MlxuICAgICAgLy8gd2UgbmVlZCB0byBlbnN1cmUgdGhhdCBubyBwYXJlbnQgaXMgbG9ja2VkXG4gICAgICBjb25zdCBjbG9zZXN0TG9jayA9IHRhcmdldENvbnRhaW5lci5jbG9zZXN0KGBbJHtQSFhfUkVGX0xPQ0t9XWApO1xuICAgICAgaWYgKGNsb3Nlc3RMb2NrKSB7XG4gICAgICAgIGNvbnN0IGNsb25lZFRyZWUgPSBET00ucHJpdmF0ZShjbG9zZXN0TG9jaywgUEhYX1JFRl9MT0NLKTtcbiAgICAgICAgaWYgKGNsb25lZFRyZWUpIHtcbiAgICAgICAgICAvLyBpZiBhIHBhcmVudCBpcyBsb2NrZWQgd2l0aCBhIGNsb25lZCB0cmVlLCB3ZSBuZWVkIHRvIHBhdGNoIHRoZSBjbG9uZWQgdHJlZSBpbnN0ZWFkXG4gICAgICAgICAgdGFyZ2V0Q29udGFpbmVyID0gY2xvbmVkVHJlZS5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgYFtkYXRhLXBoeC1jb21wb25lbnQ9XCIke3RoaXMudGFyZ2V0Q0lEfVwiXWAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGZvY3VzZWQgPSBsaXZlU29ja2V0LmdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgICBjb25zdCB7IHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQgfSA9XG4gICAgICBmb2N1c2VkICYmIERPTS5oYXNTZWxlY3Rpb25SYW5nZShmb2N1c2VkKSA/IGZvY3VzZWQgOiB7fTtcbiAgICBjb25zdCBwaHhVcGRhdGUgPSBsaXZlU29ja2V0LmJpbmRpbmcoUEhYX1VQREFURSk7XG4gICAgY29uc3QgcGh4Vmlld3BvcnRUb3AgPSBsaXZlU29ja2V0LmJpbmRpbmcoUEhYX1ZJRVdQT1JUX1RPUCk7XG4gICAgY29uc3QgcGh4Vmlld3BvcnRCb3R0b20gPSBsaXZlU29ja2V0LmJpbmRpbmcoUEhYX1ZJRVdQT1JUX0JPVFRPTSk7XG4gICAgY29uc3QgcGh4VHJpZ2dlckV4dGVybmFsID0gbGl2ZVNvY2tldC5iaW5kaW5nKFBIWF9UUklHR0VSX0FDVElPTik7XG4gICAgY29uc3QgYWRkZWQgPSBbXTtcbiAgICBjb25zdCB1cGRhdGVzID0gW107XG4gICAgY29uc3QgYXBwZW5kUHJlcGVuZFVwZGF0ZXMgPSBbXTtcblxuICAgIC8vIGFzIHRoZSBwb3J0YWwgdGFyZ2V0IGl0c2VsZiBjb3VsZCBiZSBhdCB0aGUgZW5kIG9mIHRoZSBET00sXG4gICAgLy8gaXQgbWF5IG5vdCBiZSBwcmVzZW50IHdoaWxlIG1vcnBoaW5nIHByZXZpb3VzIHBhcnRzO1xuICAgIC8vIHRoZXJlZm9yZSB3ZSBhcHBseSBhbGwgdGVsZXBvcnRzIGFmdGVyIHRoZSBtb3JwaGluZyBpcyBkb25lK1xuICAgIGxldCBwb3J0YWxDYWxsYmFja3MgPSBbXTtcblxuICAgIGxldCBleHRlcm5hbEZvcm1UcmlnZ2VyZWQgPSBudWxsO1xuXG4gICAgY29uc3QgbW9ycGggPSAoXG4gICAgICB0YXJnZXRDb250YWluZXIsXG4gICAgICBzb3VyY2UsXG4gICAgICB3aXRoQ2hpbGRyZW4gPSB0aGlzLndpdGhDaGlsZHJlbixcbiAgICApID0+IHtcbiAgICAgIGNvbnN0IG1vcnBoQ2FsbGJhY2tzID0ge1xuICAgICAgICAvLyBub3JtYWxseSwgd2UgYXJlIHJ1bm5pbmcgd2l0aCBjaGlsZHJlbk9ubHksIGFzIHRoZSBwYXRjaCBIVE1MIGZvciBhIExWXG4gICAgICAgIC8vIGRvZXMgbm90IGluY2x1ZGUgdGhlIExWIGF0dHJzIChkYXRhLXBoeC1zZXNzaW9uLCBldGMuKVxuICAgICAgICAvLyB3aGVuIHdlIGFyZSBwYXRjaGluZyBhIGxpdmUgY29tcG9uZW50LCB3ZSBkbyB3YW50IHRvIHBhdGNoIHRoZSByb290IGVsZW1lbnQgYXMgd2VsbDtcbiAgICAgICAgLy8gYW5vdGhlciBjYXNlIGlzIHRoZSByZWN1cnNpdmUgcGF0Y2ggb2YgYSBzdHJlYW0gaXRlbSB0aGF0IHdhcyBrZXB0IG9uIHJlc2V0ICgtPiBvbkJlZm9yZU5vZGVBZGRlZClcbiAgICAgICAgY2hpbGRyZW5Pbmx5OlxuICAgICAgICAgIHRhcmdldENvbnRhaW5lci5nZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVCkgPT09IG51bGwgJiYgIXdpdGhDaGlsZHJlbixcbiAgICAgICAgZ2V0Tm9kZUtleTogKG5vZGUpID0+IHtcbiAgICAgICAgICBpZiAoRE9NLmlzUGh4RGVzdHJveWVkKG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIGpvaW4gcGF0Y2gsIHRoZW4gYnkgZGVmaW5pdGlvbiB0aGVyZSB3YXMgbm8gUEhYX01BR0lDX0lELlxuICAgICAgICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IHRvIHJlZHVjZSB0aGUgYW1vdW50IG9mIGVsZW1lbnRzIG1vcnBoZG9tIGRpc2NhcmRzLlxuICAgICAgICAgIGlmIChpc0pvaW5QYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuaWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBub2RlLmlkIHx8IChub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZShQSFhfTUFHSUNfSUQpKVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHNraXAgaW5kZXhpbmcgZnJvbSBjaGlsZHJlbiB3aGVuIGNvbnRhaW5lciBpcyBzdHJlYW1cbiAgICAgICAgc2tpcEZyb21DaGlsZHJlbjogKGZyb20pID0+IHtcbiAgICAgICAgICByZXR1cm4gZnJvbS5nZXRBdHRyaWJ1dGUocGh4VXBkYXRlKSA9PT0gUEhYX1NUUkVBTTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gdGVsbCBtb3JwaGRvbSBob3cgdG8gYWRkIGEgY2hpbGRcbiAgICAgICAgYWRkQ2hpbGQ6IChwYXJlbnQsIGNoaWxkKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyByZWYsIHN0cmVhbUF0IH0gPSB0aGlzLmdldFN0cmVhbUluc2VydChjaGlsZCk7XG4gICAgICAgICAgaWYgKHJlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnNldFN0cmVhbVJlZihjaGlsZCwgcmVmKTtcblxuICAgICAgICAgIC8vIHN0cmVhbWluZ1xuICAgICAgICAgIGlmIChzdHJlYW1BdCA9PT0gMCkge1xuICAgICAgICAgICAgcGFyZW50Lmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyYmVnaW5cIiwgY2hpbGQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtQXQgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0Q2hpbGQgPSBwYXJlbnQubGFzdEVsZW1lbnRDaGlsZDtcbiAgICAgICAgICAgIGlmIChsYXN0Q2hpbGQgJiYgIWxhc3RDaGlsZC5oYXNBdHRyaWJ1dGUoUEhYX1NUUkVBTV9SRUYpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5vblN0cmVhbUNoaWxkID0gQXJyYXkuZnJvbShwYXJlbnQuY2hpbGRyZW4pLmZpbmQoXG4gICAgICAgICAgICAgICAgKGMpID0+ICFjLmhhc0F0dHJpYnV0ZShQSFhfU1RSRUFNX1JFRiksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIG5vblN0cmVhbUNoaWxkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW1BdCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBBcnJheS5mcm9tKHBhcmVudC5jaGlsZHJlbilbc3RyZWFtQXRdO1xuICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgc2libGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkJlZm9yZU5vZGVBZGRlZDogKGVsKSA9PiB7XG4gICAgICAgICAgLy8gZG9uJ3QgYWRkIHVwZGF0ZV9vbmx5IG5vZGVzIGlmIHRoZXkgZGlkIG5vdCBhbHJlYWR5IGV4aXN0XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5nZXRTdHJlYW1JbnNlcnQoZWwpPy51cGRhdGVPbmx5ICYmXG4gICAgICAgICAgICAhdGhpcy5zdHJlYW1Db21wb25lbnRSZXN0b3JlW2VsLmlkXVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIERPTS5tYWludGFpblByaXZhdGVIb29rcyhlbCwgZWwsIHBoeFZpZXdwb3J0VG9wLCBwaHhWaWV3cG9ydEJvdHRvbSk7XG4gICAgICAgICAgdGhpcy50cmFja0JlZm9yZShcImFkZGVkXCIsIGVsKTtcblxuICAgICAgICAgIGxldCBtb3JwaGVkRWwgPSBlbDtcbiAgICAgICAgICAvLyB0aGlzIGlzIGEgc3RyZWFtIGl0ZW0gdGhhdCB3YXMga2VwdCBvbiByZXNldCwgcmVjdXJzaXZlbHkgbW9ycGggaXRcbiAgICAgICAgICBpZiAodGhpcy5zdHJlYW1Db21wb25lbnRSZXN0b3JlW2VsLmlkXSkge1xuICAgICAgICAgICAgbW9ycGhlZEVsID0gdGhpcy5zdHJlYW1Db21wb25lbnRSZXN0b3JlW2VsLmlkXTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0cmVhbUNvbXBvbmVudFJlc3RvcmVbZWwuaWRdO1xuICAgICAgICAgICAgbW9ycGgobW9ycGhlZEVsLCBlbCwgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG1vcnBoZWRFbDtcbiAgICAgICAgfSxcbiAgICAgICAgb25Ob2RlQWRkZWQ6IChlbCkgPT4ge1xuICAgICAgICAgIGlmIChlbC5nZXRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHRoaXMubWF5YmVSZU9yZGVyU3RyZWFtKGVsLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gcGh4LXBvcnRhbCBoYW5kbGluZ1xuICAgICAgICAgIGlmIChET00uaXNQb3J0YWxUZW1wbGF0ZShlbCkpIHtcbiAgICAgICAgICAgIHBvcnRhbENhbGxiYWNrcy5wdXNoKCgpID0+IHRoaXMudGVsZXBvcnQoZWwsIG1vcnBoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaGFjayB0byBmaXggU2FmYXJpIGhhbmRsaW5nIG9mIGltZyBzcmNzZXQgYW5kIHZpZGVvIHRhZ3NcbiAgICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50ICYmIGVsLnNyY3NldCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtYXNzaWduXG4gICAgICAgICAgICBlbC5zcmNzZXQgPSBlbC5zcmNzZXQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChlbCBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQgJiYgZWwuYXV0b3BsYXkpIHtcbiAgICAgICAgICAgIGVsLnBsYXkoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKERPTS5pc05vd1RyaWdnZXJGb3JtRXh0ZXJuYWwoZWwsIHBoeFRyaWdnZXJFeHRlcm5hbCkpIHtcbiAgICAgICAgICAgIGV4dGVybmFsRm9ybVRyaWdnZXJlZCA9IGVsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIG5lc3RlZCB2aWV3IGhhbmRsaW5nXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKERPTS5pc1BoeENoaWxkKGVsKSAmJiB2aWV3Lm93bnNFbGVtZW50KGVsKSkgfHxcbiAgICAgICAgICAgIChET00uaXNQaHhTdGlja3koZWwpICYmIHZpZXcub3duc0VsZW1lbnQoZWwucGFyZW50Tm9kZSkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNrQWZ0ZXIoXCJwaHhDaGlsZEFkZGVkXCIsIGVsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBkYXRhLXBoeC1ydW50aW1lLWhvb2tcbiAgICAgICAgICBpZiAoZWwubm9kZU5hbWUgPT09IFwiU0NSSVBUXCIgJiYgZWwuaGFzQXR0cmlidXRlKFBIWF9SVU5USU1FX0hPT0spKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVJ1bnRpbWVIb29rKGVsLCBzb3VyY2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFkZGVkLnB1c2goZWwpO1xuICAgICAgICB9LFxuICAgICAgICBvbk5vZGVEaXNjYXJkZWQ6IChlbCkgPT4gdGhpcy5vbk5vZGVEaXNjYXJkZWQoZWwpLFxuICAgICAgICBvbkJlZm9yZU5vZGVEaXNjYXJkZWQ6IChlbCkgPT4ge1xuICAgICAgICAgIGlmIChlbC5nZXRBdHRyaWJ1dGUgJiYgZWwuZ2V0QXR0cmlidXRlKFBIWF9QUlVORSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBlbC5wYXJlbnRFbGVtZW50ICE9PSBudWxsICYmXG4gICAgICAgICAgICBlbC5pZCAmJlxuICAgICAgICAgICAgRE9NLmlzUGh4VXBkYXRlKGVsLnBhcmVudEVsZW1lbnQsIHBoeFVwZGF0ZSwgW1xuICAgICAgICAgICAgICBQSFhfU1RSRUFNLFxuICAgICAgICAgICAgICBcImFwcGVuZFwiLFxuICAgICAgICAgICAgICBcInByZXBlbmRcIixcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGRvbid0IHJlbW92ZSB0ZWxlcG9ydGVkIGVsZW1lbnRzXG4gICAgICAgICAgaWYgKGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUoUEhYX1RFTEVQT1JURURfUkVGKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5tYXliZVBlbmRpbmdSZW1vdmUoZWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLnNraXBDSURTaWJsaW5nKGVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChET00uaXNQb3J0YWxUZW1wbGF0ZShlbCkpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwb3J0YWwgdGVtcGxhdGUgaXRzZWxmIGlzIHJlbW92ZWQsIHJlbW92ZSB0aGUgdGVsZXBvcnRlZCBlbGVtZW50IGFzIHdlbGw7XG4gICAgICAgICAgICAvLyB3ZSBhbHNvIHBlcmZvcm0gYSBjaGVjayBhZnRlciBtb3JwaGRvbSBpcyBmaW5pc2hlZCB0byBjYXRjaCBwYXJlbnQgcmVtb3ZhbHNcbiAgICAgICAgICAgIGNvbnN0IHRlbGVwb3J0ZWRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxuICAgICAgICAgICAgICBlbC5jb250ZW50LmZpcnN0RWxlbWVudENoaWxkLmlkLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICh0ZWxlcG9ydGVkRWwpIHtcbiAgICAgICAgICAgICAgdGVsZXBvcnRlZEVsLnJlbW92ZSgpO1xuICAgICAgICAgICAgICBtb3JwaENhbGxiYWNrcy5vbk5vZGVEaXNjYXJkZWQodGVsZXBvcnRlZEVsKTtcbiAgICAgICAgICAgICAgdGhpcy52aWV3LmRyb3BQb3J0YWxFbGVtZW50SWQodGVsZXBvcnRlZEVsLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FbFVwZGF0ZWQ6IChlbCkgPT4ge1xuICAgICAgICAgIGlmIChET00uaXNOb3dUcmlnZ2VyRm9ybUV4dGVybmFsKGVsLCBwaHhUcmlnZ2VyRXh0ZXJuYWwpKSB7XG4gICAgICAgICAgICBleHRlcm5hbEZvcm1UcmlnZ2VyZWQgPSBlbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlcy5wdXNoKGVsKTtcbiAgICAgICAgICB0aGlzLm1heWJlUmVPcmRlclN0cmVhbShlbCwgZmFsc2UpO1xuICAgICAgICB9LFxuICAgICAgICBvbkJlZm9yZUVsVXBkYXRlZDogKGZyb21FbCwgdG9FbCkgPT4ge1xuICAgICAgICAgIC8vIGlmIHdlIGFyZSBwYXRjaGluZyB0aGUgcm9vdCB0YXJnZXQgY29udGFpbmVyIGFuZCB0aGUgaWQgaGFzIGNoYW5nZWQsIHRyZWF0IGl0IGFzIGEgbmV3IG5vZGVcbiAgICAgICAgICAvLyBieSByZXBsYWNpbmcgdGhlIGZyb21FbCB3aXRoIHRoZSB0b0VsLCB3aGljaCBlbnN1cmVzIGhvb2tzIGFyZSB0b3JuIGRvd24gYW5kIHJlLWNyZWF0ZWRcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBmcm9tRWwuaWQgJiZcbiAgICAgICAgICAgIGZyb21FbC5pc1NhbWVOb2RlKHRhcmdldENvbnRhaW5lcikgJiZcbiAgICAgICAgICAgIGZyb21FbC5pZCAhPT0gdG9FbC5pZFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgbW9ycGhDYWxsYmFja3Mub25Ob2RlRGlzY2FyZGVkKGZyb21FbCk7XG4gICAgICAgICAgICBmcm9tRWwucmVwbGFjZVdpdGgodG9FbCk7XG4gICAgICAgICAgICByZXR1cm4gbW9ycGhDYWxsYmFja3Mub25Ob2RlQWRkZWQodG9FbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIERPTS5zeW5jUGVuZGluZ0F0dHJzKGZyb21FbCwgdG9FbCk7XG4gICAgICAgICAgRE9NLm1haW50YWluUHJpdmF0ZUhvb2tzKFxuICAgICAgICAgICAgZnJvbUVsLFxuICAgICAgICAgICAgdG9FbCxcbiAgICAgICAgICAgIHBoeFZpZXdwb3J0VG9wLFxuICAgICAgICAgICAgcGh4Vmlld3BvcnRCb3R0b20sXG4gICAgICAgICAgKTtcbiAgICAgICAgICBET00uY2xlYW5DaGlsZE5vZGVzKHRvRWwsIHBoeFVwZGF0ZSk7XG4gICAgICAgICAgaWYgKHRoaXMuc2tpcENJRFNpYmxpbmcodG9FbCkpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBsaXZlIGNvbXBvbmVudCB1c2VkIGluIGEgc3RyZWFtLCB3ZSBtYXkgbmVlZCB0byByZW9yZGVyIGl0XG4gICAgICAgICAgICB0aGlzLm1heWJlUmVPcmRlclN0cmVhbShmcm9tRWwpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoRE9NLmlzUGh4U3RpY2t5KGZyb21FbCkpIHtcbiAgICAgICAgICAgIFtQSFhfU0VTU0lPTiwgUEhYX1NUQVRJQywgUEhYX1JPT1RfSURdXG4gICAgICAgICAgICAgIC5tYXAoKGF0dHIpID0+IFtcbiAgICAgICAgICAgICAgICBhdHRyLFxuICAgICAgICAgICAgICAgIGZyb21FbC5nZXRBdHRyaWJ1dGUoYXR0ciksXG4gICAgICAgICAgICAgICAgdG9FbC5nZXRBdHRyaWJ1dGUoYXR0ciksXG4gICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgIC5mb3JFYWNoKChbYXR0ciwgZnJvbVZhbCwgdG9WYWxdKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRvVmFsICYmIGZyb21WYWwgIT09IHRvVmFsKSB7XG4gICAgICAgICAgICAgICAgICBmcm9tRWwuc2V0QXR0cmlidXRlKGF0dHIsIHRvVmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIERPTS5pc0lnbm9yZWQoZnJvbUVsLCBwaHhVcGRhdGUpIHx8XG4gICAgICAgICAgICAoZnJvbUVsLmZvcm0gJiYgZnJvbUVsLmZvcm0uaXNTYW1lTm9kZShleHRlcm5hbEZvcm1UcmlnZ2VyZWQpKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy50cmFja0JlZm9yZShcInVwZGF0ZWRcIiwgZnJvbUVsLCB0b0VsKTtcbiAgICAgICAgICAgIERPTS5tZXJnZUF0dHJzKGZyb21FbCwgdG9FbCwge1xuICAgICAgICAgICAgICBpc0lnbm9yZWQ6IERPTS5pc0lnbm9yZWQoZnJvbUVsLCBwaHhVcGRhdGUpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB1cGRhdGVzLnB1c2goZnJvbUVsKTtcbiAgICAgICAgICAgIERPTS5hcHBseVN0aWNreU9wZXJhdGlvbnMoZnJvbUVsKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZnJvbUVsLnR5cGUgPT09IFwibnVtYmVyXCIgJiZcbiAgICAgICAgICAgIGZyb21FbC52YWxpZGl0eSAmJlxuICAgICAgICAgICAgZnJvbUVsLnZhbGlkaXR5LmJhZElucHV0XG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIElmIHRoZSBlbGVtZW50IGhhcyBQSFhfUkVGX1NSQywgaXQgaXMgbG9hZGluZyBvciBsb2NrZWQgYW5kIGF3YWl0aW5nIGFuIGFjay5cbiAgICAgICAgICAvLyBJZiBpdCdzIGxvY2tlZCwgd2UgY2xvbmUgdGhlIGZyb21FbCB0cmVlIGFuZCBpbnN0cnVjdCBtb3JwaGRvbSB0byB1c2VcbiAgICAgICAgICAvLyB0aGUgY2xvbmVkIHRyZWUgYXMgdGhlIHNvdXJjZSBvZiB0aGUgbW9ycGggZm9yIHRoaXMgYnJhbmNoIGZyb20gaGVyZSBvbiBvdXQuXG4gICAgICAgICAgLy8gV2Uga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgY2xvbmVkIHRyZWUgaW4gdGhlIGVsZW1lbnQncyBwcml2YXRlIGRhdGEsIGFuZFxuICAgICAgICAgIC8vIG9uIGFjayAodmlldy51bmRvUmVmcyksIHdlIG1vcnBoIHRoZSBjbG9uZWQgdHJlZSB3aXRoIHRoZSB0cnVlIGZyb21FbCBpbiB0aGUgRE9NIHRvXG4gICAgICAgICAgLy8gYXBwbHkgYW55IGNoYW5nZXMgdGhhdCBoYXBwZW5lZCB3aGlsZSB0aGUgZWxlbWVudCB3YXMgbG9ja2VkLlxuICAgICAgICAgIGNvbnN0IGlzRm9jdXNlZEZvcm1FbCA9XG4gICAgICAgICAgICBmb2N1c2VkICYmIGZyb21FbC5pc1NhbWVOb2RlKGZvY3VzZWQpICYmIERPTS5pc0Zvcm1JbnB1dChmcm9tRWwpO1xuICAgICAgICAgIGNvbnN0IGZvY3VzZWRTZWxlY3RDaGFuZ2VkID1cbiAgICAgICAgICAgIGlzRm9jdXNlZEZvcm1FbCAmJiB0aGlzLmlzQ2hhbmdlZFNlbGVjdChmcm9tRWwsIHRvRWwpO1xuICAgICAgICAgIGlmIChmcm9tRWwuaGFzQXR0cmlidXRlKFBIWF9SRUZfU1JDKSkge1xuICAgICAgICAgICAgY29uc3QgcmVmID0gbmV3IEVsZW1lbnRSZWYoZnJvbUVsKTtcbiAgICAgICAgICAgIC8vIG9ubHkgcGVyZm9ybSB0aGUgY2xvbmUgc3RlcCBpZiB0aGlzIGlzIG5vdCBhIHBhdGNoIHRoYXQgdW5sb2Nrc1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICByZWYubG9ja1JlZiAmJlxuICAgICAgICAgICAgICAoIXRoaXMudW5kb1JlZiB8fCAhcmVmLmlzTG9ja1VuZG9uZUJ5KHRoaXMudW5kb1JlZikpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgRE9NLmFwcGx5U3RpY2t5T3BlcmF0aW9ucyhmcm9tRWwpO1xuICAgICAgICAgICAgICBjb25zdCBpc0xvY2tlZCA9IGZyb21FbC5oYXNBdHRyaWJ1dGUoUEhYX1JFRl9MT0NLKTtcbiAgICAgICAgICAgICAgY29uc3QgY2xvbmUgPSBpc0xvY2tlZFxuICAgICAgICAgICAgICAgID8gRE9NLnByaXZhdGUoZnJvbUVsLCBQSFhfUkVGX0xPQ0spIHx8IGZyb21FbC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgIGlmIChjbG9uZSkge1xuICAgICAgICAgICAgICAgIERPTS5wdXRQcml2YXRlKGZyb21FbCwgUEhYX1JFRl9MT0NLLCBjbG9uZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0ZvY3VzZWRGb3JtRWwpIHtcbiAgICAgICAgICAgICAgICAgIGZyb21FbCA9IGNsb25lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIG5lc3RlZCB2aWV3IGhhbmRsaW5nXG4gICAgICAgICAgaWYgKERPTS5pc1BoeENoaWxkKHRvRWwpKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2U2Vzc2lvbiA9IGZyb21FbC5nZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04pO1xuICAgICAgICAgICAgRE9NLm1lcmdlQXR0cnMoZnJvbUVsLCB0b0VsLCB7IGV4Y2x1ZGU6IFtQSFhfU1RBVElDXSB9KTtcbiAgICAgICAgICAgIGlmIChwcmV2U2Vzc2lvbiAhPT0gXCJcIikge1xuICAgICAgICAgICAgICBmcm9tRWwuc2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OLCBwcmV2U2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcm9tRWwuc2V0QXR0cmlidXRlKFBIWF9ST09UX0lELCB0aGlzLnJvb3RJRCk7XG4gICAgICAgICAgICBET00uYXBwbHlTdGlja3lPcGVyYXRpb25zKGZyb21FbCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgd2UgYXJlIHVuZG9pbmcgYSBsb2NrLCBjb3B5IHBvdGVudGlhbGx5IG5lc3RlZCBjbG9uZXMgb3ZlclxuICAgICAgICAgIGlmICh0aGlzLnVuZG9SZWYgJiYgRE9NLnByaXZhdGUodG9FbCwgUEhYX1JFRl9MT0NLKSkge1xuICAgICAgICAgICAgRE9NLnB1dFByaXZhdGUoXG4gICAgICAgICAgICAgIGZyb21FbCxcbiAgICAgICAgICAgICAgUEhYX1JFRl9MT0NLLFxuICAgICAgICAgICAgICBET00ucHJpdmF0ZSh0b0VsLCBQSFhfUkVGX0xPQ0spLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gbm93IGNvcHkgcmVndWxhciBET00ucHJpdmF0ZSBkYXRhXG4gICAgICAgICAgRE9NLmNvcHlQcml2YXRlcyh0b0VsLCBmcm9tRWwpO1xuXG4gICAgICAgICAgLy8gcGh4LXBvcnRhbCBoYW5kbGluZ1xuICAgICAgICAgIGlmIChET00uaXNQb3J0YWxUZW1wbGF0ZSh0b0VsKSkge1xuICAgICAgICAgICAgcG9ydGFsQ2FsbGJhY2tzLnB1c2goKCkgPT4gdGhpcy50ZWxlcG9ydCh0b0VsLCBtb3JwaCkpO1xuICAgICAgICAgICAgLy8gZm9yIHRoZSBtYWdpY0lkIG9wdGltaXphdGlvbiB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0IHRoZSB0ZW1wbGF0ZSBjb250ZW50c1xuICAgICAgICAgICAgLy8gYXJlIHByb3Blcmx5IHVwZGF0ZWQgYXMgdGhleSBhcmUgdXNlZCB3aGVuIHJlc3RvcmluZyBhIGNsb25lZCB0cmVlXG4gICAgICAgICAgICBmcm9tRWwuaW5uZXJIVE1MID0gdG9FbC5pbm5lckhUTUw7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gc2tpcCBwYXRjaGluZyBmb2N1c2VkIGlucHV0cyB1bmxlc3MgZm9jdXMgaXMgYSBzZWxlY3QgdGhhdCBoYXMgY2hhbmdlZCBvcHRpb25zXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgaXNGb2N1c2VkRm9ybUVsICYmXG4gICAgICAgICAgICBmcm9tRWwudHlwZSAhPT0gXCJoaWRkZW5cIiAmJlxuICAgICAgICAgICAgIWZvY3VzZWRTZWxlY3RDaGFuZ2VkXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBmcm9tRWwsIHRvRWwpO1xuICAgICAgICAgICAgRE9NLm1lcmdlRm9jdXNlZElucHV0KGZyb21FbCwgdG9FbCk7XG4gICAgICAgICAgICBET00uc3luY0F0dHJzVG9Qcm9wcyhmcm9tRWwpO1xuICAgICAgICAgICAgdXBkYXRlcy5wdXNoKGZyb21FbCk7XG4gICAgICAgICAgICBET00uYXBwbHlTdGlja3lPcGVyYXRpb25zKGZyb21FbCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGJsdXIgZm9jdXNlZCBzZWxlY3QgaWYgaXQgY2hhbmdlZCBzbyBuYXRpdmUgVUkgaXMgdXBkYXRlZCAoaWUgc2FmYXJpIHdvbid0IHVwZGF0ZSB2aXNpYmxlIG9wdGlvbnMpXG4gICAgICAgICAgICBpZiAoZm9jdXNlZFNlbGVjdENoYW5nZWQpIHtcbiAgICAgICAgICAgICAgZnJvbUVsLmJsdXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChET00uaXNQaHhVcGRhdGUodG9FbCwgcGh4VXBkYXRlLCBbXCJhcHBlbmRcIiwgXCJwcmVwZW5kXCJdKSkge1xuICAgICAgICAgICAgICBhcHBlbmRQcmVwZW5kVXBkYXRlcy5wdXNoKFxuICAgICAgICAgICAgICAgIG5ldyBET01Qb3N0TW9ycGhSZXN0b3JlcihcbiAgICAgICAgICAgICAgICAgIGZyb21FbCxcbiAgICAgICAgICAgICAgICAgIHRvRWwsXG4gICAgICAgICAgICAgICAgICB0b0VsLmdldEF0dHJpYnV0ZShwaHhVcGRhdGUpLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIERPTS5zeW5jQXR0cnNUb1Byb3BzKHRvRWwpO1xuICAgICAgICAgICAgRE9NLmFwcGx5U3RpY2t5T3BlcmF0aW9ucyh0b0VsKTtcbiAgICAgICAgICAgIHRoaXMudHJhY2tCZWZvcmUoXCJ1cGRhdGVkXCIsIGZyb21FbCwgdG9FbCk7XG4gICAgICAgICAgICByZXR1cm4gZnJvbUVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIG1vcnBoZG9tKHRhcmdldENvbnRhaW5lciwgc291cmNlLCBtb3JwaENhbGxiYWNrcyk7XG4gICAgfTtcblxuICAgIHRoaXMudHJhY2tCZWZvcmUoXCJhZGRlZFwiLCBjb250YWluZXIpO1xuICAgIHRoaXMudHJhY2tCZWZvcmUoXCJ1cGRhdGVkXCIsIGNvbnRhaW5lciwgY29udGFpbmVyKTtcblxuICAgIGxpdmVTb2NrZXQudGltZShcIm1vcnBoZG9tXCIsICgpID0+IHtcbiAgICAgIHRoaXMuc3RyZWFtcy5mb3JFYWNoKChbcmVmLCBpbnNlcnRzLCBkZWxldGVJZHMsIHJlc2V0XSkgPT4ge1xuICAgICAgICBpbnNlcnRzLmZvckVhY2goKFtrZXksIHN0cmVhbUF0LCBsaW1pdCwgdXBkYXRlT25seV0pID0+IHtcbiAgICAgICAgICB0aGlzLnN0cmVhbUluc2VydHNba2V5XSA9IHsgcmVmLCBzdHJlYW1BdCwgbGltaXQsIHJlc2V0LCB1cGRhdGVPbmx5IH07XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIERPTS5hbGwoY29udGFpbmVyLCBgWyR7UEhYX1NUUkVBTV9SRUZ9PVwiJHtyZWZ9XCJdYCwgKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVN0cmVhbUNoaWxkRWxlbWVudChjaGlsZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlSWRzLmZvckVhY2goKGlkKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2hpbGQgPSBjb250YWluZXIucXVlcnlTZWxlY3RvcihgW2lkPVwiJHtpZH1cIl1gKTtcbiAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlU3RyZWFtQ2hpbGRFbGVtZW50KGNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGNsZWFyIHN0cmVhbSBpdGVtcyBmcm9tIHRoZSBkZWFkIHJlbmRlciBpZiB0aGV5IGFyZSBub3QgaW5zZXJ0ZWQgYWdhaW5cbiAgICAgIGlmIChpc0pvaW5QYXRjaCkge1xuICAgICAgICBET00uYWxsKHRoaXMuY29udGFpbmVyLCBgWyR7cGh4VXBkYXRlfT0ke1BIWF9TVFJFQU19XWApXG4gICAgICAgICAgLy8gaXQgaXMgaW1wb3J0YW50IHRvIGZpbHRlciB0aGUgZWxlbWVudCBiZWZvcmUgcmVtb3ZpbmcgdGhlbSwgYXNcbiAgICAgICAgICAvLyBpdCBtYXkgaGFwcGVuIHRoYXQgc3RyZWFtcyBhcmUgbmVzdGVkIGFuZCB0aGUgb3duZXIgY2hlY2sgZmFpbHMgaWZcbiAgICAgICAgICAvLyBhIHBhcmVudCBpcyByZW1vdmVkIGJlZm9yZSBhIGNoaWxkXG4gICAgICAgICAgLmZpbHRlcigoZWwpID0+IHRoaXMudmlldy5vd25zRWxlbWVudChlbCkpXG4gICAgICAgICAgLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgICAgICBBcnJheS5mcm9tKGVsLmNoaWxkcmVuKS5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAvLyB3ZSBhbHJlYWR5IHBlcmZvcm1lZCB0aGUgb3duZXIgY2hlY2ssIGVhY2ggY2hpbGQgaXMgZ3VhcmFudGVlZCB0byBiZSBvd25lZFxuICAgICAgICAgICAgICAvLyBieSB0aGUgdmlldy4gVG8gcHJldmVudCB0aGUgbmVzdGVkIG93bmVyIGNoZWNrIGZyb20gZmFpbGluZyBpbiBjYXNlIG9mIG5lc3RlZFxuICAgICAgICAgICAgICAvLyBzdHJlYW1zIHdoZXJlIHRoZSBwYXJlbnQgaXMgcmVtb3ZlZCBiZWZvcmUgdGhlIGNoaWxkLCB3ZSBmb3JjZSB0aGUgcmVtb3ZhbFxuICAgICAgICAgICAgICB0aGlzLnJlbW92ZVN0cmVhbUNoaWxkRWxlbWVudChjaGlsZCwgdHJ1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgbW9ycGgodGFyZ2V0Q29udGFpbmVyLCBodG1sKTtcblxuICAgICAgLy8gbm9ybWFsIHBhdGNoIGNvbXBsZXRlLCB0ZWxlcG9ydCBlbGVtZW50cyBub3dcbiAgICAgIC8vIGFuZCBoYW5kbGUgbmVzdGVkIHRlbGVwb3J0YXRpb24gdXAgdG8gZGVwdGggNVxuICAgICAgbGV0IHRlbGVwb3J0Q291bnQgPSAwO1xuICAgICAgd2hpbGUgKHBvcnRhbENhbGxiYWNrcy5sZW5ndGggPiAwICYmIHRlbGVwb3J0Q291bnQgPCA1KSB7XG4gICAgICAgIGNvbnN0IGNvcHkgPSBwb3J0YWxDYWxsYmFja3Muc2xpY2UoKTtcbiAgICAgICAgcG9ydGFsQ2FsbGJhY2tzID0gW107XG4gICAgICAgIGNvcHkuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKCkpO1xuICAgICAgICB0ZWxlcG9ydENvdW50Kys7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGZvciBhbnkgdGVsZXBvcnRlZCBlbGVtZW50cyB0aGF0IGFyZSBub3QgaW4gdGhlIHZpZXcgYW55IG1vcmVcbiAgICAgIC8vIGFuZCByZW1vdmUgdGhlbVxuICAgICAgdGhpcy52aWV3LnBvcnRhbEVsZW1lbnRJZHMuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgICAgY29uc3QgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxuICAgICAgICAgICAgZWwuZ2V0QXR0cmlidXRlKFBIWF9URUxFUE9SVEVEX1NSQyksXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlKCk7XG4gICAgICAgICAgICB0aGlzLm9uTm9kZURpc2NhcmRlZChlbCk7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZHJvcFBvcnRhbEVsZW1lbnRJZChpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGlmIChsaXZlU29ja2V0LmlzRGVidWdFbmFibGVkKCkpIHtcbiAgICAgIGRldGVjdER1cGxpY2F0ZUlkcygpO1xuICAgICAgZGV0ZWN0SW52YWxpZFN0cmVhbUluc2VydHModGhpcy5zdHJlYW1JbnNlcnRzKTtcbiAgICAgIC8vIHdhcm4gaWYgdGhlcmUgYXJlIGFueSBpbnB1dHMgbmFtZWQgXCJpZFwiXG4gICAgICBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFtuYW1lPWlkXVwiKSkuZm9yRWFjaChcbiAgICAgICAgKG5vZGUpID0+IHtcbiAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQgJiYgbm9kZS5mb3JtKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAnRGV0ZWN0ZWQgYW4gaW5wdXQgd2l0aCBuYW1lPVwiaWRcIiBpbnNpZGUgYSBmb3JtISBUaGlzIHdpbGwgY2F1c2UgcHJvYmxlbXMgd2hlbiBwYXRjaGluZyB0aGUgRE9NLlxcbicsXG4gICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGFwcGVuZFByZXBlbmRVcGRhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGxpdmVTb2NrZXQudGltZShcInBvc3QtbW9ycGggYXBwZW5kL3ByZXBlbmQgcmVzdG9yYXRpb25cIiwgKCkgPT4ge1xuICAgICAgICBhcHBlbmRQcmVwZW5kVXBkYXRlcy5mb3JFYWNoKCh1cGRhdGUpID0+IHVwZGF0ZS5wZXJmb3JtKCkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbGl2ZVNvY2tldC5zaWxlbmNlRXZlbnRzKCgpID0+XG4gICAgICBET00ucmVzdG9yZUZvY3VzKGZvY3VzZWQsIHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpLFxuICAgICk7XG4gICAgRE9NLmRpc3BhdGNoRXZlbnQoZG9jdW1lbnQsIFwicGh4OnVwZGF0ZVwiKTtcbiAgICBhZGRlZC5mb3JFYWNoKChlbCkgPT4gdGhpcy50cmFja0FmdGVyKFwiYWRkZWRcIiwgZWwpKTtcbiAgICB1cGRhdGVzLmZvckVhY2goKGVsKSA9PiB0aGlzLnRyYWNrQWZ0ZXIoXCJ1cGRhdGVkXCIsIGVsKSk7XG5cbiAgICB0aGlzLnRyYW5zaXRpb25QZW5kaW5nUmVtb3ZlcygpO1xuXG4gICAgaWYgKGV4dGVybmFsRm9ybVRyaWdnZXJlZCkge1xuICAgICAgbGl2ZVNvY2tldC51bmxvYWQoKTtcbiAgICAgIC8vIGNoZWNrIGZvciBzdWJtaXR0ZXIgYW5kIGluamVjdCBpdCBhcyBoaWRkZW4gaW5wdXQgZm9yIGV4dGVybmFsIHN1Ym1pdDtcbiAgICAgIC8vIEluIHRoZW9yeSwgaXQgY291bGQgaGFwcGVuIHRoYXQgdGhlIHN0b3JlZCBzdWJtaXR0ZXIgaXMgb3V0ZGF0ZWQgYW5kIGRvZXNuJ3RcbiAgICAgIC8vIGV4aXN0IGluIHRoZSBET00gYW55IG1vcmUsIGJ1dCB0aGlzIGlzIHVubGlrZWx5LCBzbyB3ZSBqdXN0IGFjY2VwdCBpdCBmb3Igbm93LlxuICAgICAgY29uc3Qgc3VibWl0dGVyID0gRE9NLnByaXZhdGUoZXh0ZXJuYWxGb3JtVHJpZ2dlcmVkLCBcInN1Ym1pdHRlclwiKTtcbiAgICAgIGlmIChzdWJtaXR0ZXIgJiYgc3VibWl0dGVyLm5hbWUgJiYgdGFyZ2V0Q29udGFpbmVyLmNvbnRhaW5zKHN1Ym1pdHRlcikpIHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgIGlucHV0LnR5cGUgPSBcImhpZGRlblwiO1xuICAgICAgICBjb25zdCBmb3JtSWQgPSBzdWJtaXR0ZXIuZ2V0QXR0cmlidXRlKFwiZm9ybVwiKTtcbiAgICAgICAgaWYgKGZvcm1JZCkge1xuICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcImZvcm1cIiwgZm9ybUlkKTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dC5uYW1lID0gc3VibWl0dGVyLm5hbWU7XG4gICAgICAgIGlucHV0LnZhbHVlID0gc3VibWl0dGVyLnZhbHVlO1xuICAgICAgICBzdWJtaXR0ZXIucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUoaW5wdXQsIHN1Ym1pdHRlcik7XG4gICAgICB9XG4gICAgICAvLyB1c2UgcHJvdG90eXBlJ3Mgc3VibWl0IGluIGNhc2UgdGhlcmUncyBhIGZvcm0gY29udHJvbCB3aXRoIG5hbWUgb3IgaWQgb2YgXCJzdWJtaXRcIlxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxGb3JtRWxlbWVudC9zdWJtaXRcbiAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihleHRlcm5hbEZvcm1UcmlnZ2VyZWQpLnN1Ym1pdC5jYWxsKFxuICAgICAgICBleHRlcm5hbEZvcm1UcmlnZ2VyZWQsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIG9uTm9kZURpc2NhcmRlZChlbCkge1xuICAgIC8vIG5lc3RlZCB2aWV3IGhhbmRsaW5nXG4gICAgaWYgKERPTS5pc1BoeENoaWxkKGVsKSB8fCBET00uaXNQaHhTdGlja3koZWwpKSB7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQuZGVzdHJveVZpZXdCeUVsKGVsKTtcbiAgICB9XG4gICAgdGhpcy50cmFja0FmdGVyKFwiZGlzY2FyZGVkXCIsIGVsKTtcbiAgfVxuXG4gIG1heWJlUGVuZGluZ1JlbW92ZShub2RlKSB7XG4gICAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKHRoaXMucGh4UmVtb3ZlKSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5wZW5kaW5nUmVtb3Zlcy5wdXNoKG5vZGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZW1vdmVTdHJlYW1DaGlsZEVsZW1lbnQoY2hpbGQsIGZvcmNlID0gZmFsc2UpIHtcbiAgICAvLyBtYWtlIHN1cmUgdG8gb25seSByZW1vdmUgZWxlbWVudHMgb3duZWQgYnkgdGhlIGN1cnJlbnQgdmlld1xuICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhvZW5peGZyYW1ld29yay9waG9lbml4X2xpdmVfdmlldy9pc3N1ZXMvMzA0N1xuICAgIC8vIGFuZCBodHRwczovL2dpdGh1Yi5jb20vcGhvZW5peGZyYW1ld29yay9waG9lbml4X2xpdmVfdmlldy9pc3N1ZXMvMzY4MVxuICAgIGlmICghZm9yY2UgJiYgIXRoaXMudmlldy5vd25zRWxlbWVudChjaGlsZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB3ZSBuZWVkIHRvIHN0b3JlIHRoZSBub2RlIGlmIGl0IGlzIGFjdHVhbGx5IHJlLWFkZGVkIGluIHRoZSBzYW1lIHBhdGNoXG4gICAgLy8gd2UgZG8gTk9UIHdhbnQgdG8gZXhlY3V0ZSBwaHgtcmVtb3ZlLCB3ZSBkbyBOT1Qgd2FudCB0byBjYWxsIG9uTm9kZURpc2NhcmRlZFxuICAgIGlmICh0aGlzLnN0cmVhbUluc2VydHNbY2hpbGQuaWRdKSB7XG4gICAgICB0aGlzLnN0cmVhbUNvbXBvbmVudFJlc3RvcmVbY2hpbGQuaWRdID0gY2hpbGQ7XG4gICAgICBjaGlsZC5yZW1vdmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb25seSByZW1vdmUgdGhlIGVsZW1lbnQgbm93IGlmIGl0IGhhcyBubyBwaHgtcmVtb3ZlIGJpbmRpbmdcbiAgICAgIGlmICghdGhpcy5tYXliZVBlbmRpbmdSZW1vdmUoY2hpbGQpKSB7XG4gICAgICAgIGNoaWxkLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLm9uTm9kZURpc2NhcmRlZChjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0U3RyZWFtSW5zZXJ0KGVsKSB7XG4gICAgY29uc3QgaW5zZXJ0ID0gZWwuaWQgPyB0aGlzLnN0cmVhbUluc2VydHNbZWwuaWRdIDoge307XG4gICAgcmV0dXJuIGluc2VydCB8fCB7fTtcbiAgfVxuXG4gIHNldFN0cmVhbVJlZihlbCwgcmVmKSB7XG4gICAgRE9NLnB1dFN0aWNreShlbCwgUEhYX1NUUkVBTV9SRUYsIChlbCkgPT5cbiAgICAgIGVsLnNldEF0dHJpYnV0ZShQSFhfU1RSRUFNX1JFRiwgcmVmKSxcbiAgICApO1xuICB9XG5cbiAgbWF5YmVSZU9yZGVyU3RyZWFtKGVsLCBpc05ldykge1xuICAgIGNvbnN0IHsgcmVmLCBzdHJlYW1BdCwgcmVzZXQgfSA9IHRoaXMuZ2V0U3RyZWFtSW5zZXJ0KGVsKTtcbiAgICBpZiAoc3RyZWFtQXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHdlIG5lZWQgdG8gc2V0IHRoZSBQSFhfU1RSRUFNX1JFRiBoZXJlIGFzIHdlbGwgYXMgYWRkQ2hpbGQgaXMgaW52b2tlZCBvbmx5IGZvciBwYXJlbnRzXG4gICAgdGhpcy5zZXRTdHJlYW1SZWYoZWwsIHJlZik7XG5cbiAgICBpZiAoIXJlc2V0ICYmICFpc05ldykge1xuICAgICAgLy8gd2Ugb25seSByZW9yZGVyIGlmIHRoZSBlbGVtZW50IGlzIG5ldyBvciBpdCdzIGEgc3RyZWFtIHJlc2V0XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgdGhlIGVsZW1lbnQgaGFzIGEgcGFyZW50IGVsZW1lbnQ7XG4gICAgLy8gaXQgZG9lc24ndCBpZiB3ZSBhcmUgY3VycmVudGx5IHJlY3Vyc2l2ZWx5IG1vcnBoaW5nIChyZXN0b3JpbmcgYSBzYXZlZCBzdHJlYW0gY2hpbGQpXG4gICAgLy8gYmVjYXVzZSB0aGUgZWxlbWVudCBpcyBub3QgeWV0IGFkZGVkIHRvIHRoZSByZWFsIGRvbTtcbiAgICAvLyByZW9yZGVyaW5nIGRvZXMgbm90IG1ha2Ugc2Vuc2UgaW4gdGhhdCBjYXNlIGFueXdheVxuICAgIGlmICghZWwucGFyZW50RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzdHJlYW1BdCA9PT0gMCkge1xuICAgICAgZWwucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUoZWwsIGVsLnBhcmVudEVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpO1xuICAgIH0gZWxzZSBpZiAoc3RyZWFtQXQgPiAwKSB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IEFycmF5LmZyb20oZWwucGFyZW50RWxlbWVudC5jaGlsZHJlbik7XG4gICAgICBjb25zdCBvbGRJbmRleCA9IGNoaWxkcmVuLmluZGV4T2YoZWwpO1xuICAgICAgaWYgKHN0cmVhbUF0ID49IGNoaWxkcmVuLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgZWwucGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZChlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzaWJsaW5nID0gY2hpbGRyZW5bc3RyZWFtQXRdO1xuICAgICAgICBpZiAob2xkSW5kZXggPiBzdHJlYW1BdCkge1xuICAgICAgICAgIGVsLnBhcmVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKGVsLCBzaWJsaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbC5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZShlbCwgc2libGluZy5uZXh0RWxlbWVudFNpYmxpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5tYXliZUxpbWl0U3RyZWFtKGVsKTtcbiAgfVxuXG4gIG1heWJlTGltaXRTdHJlYW0oZWwpIHtcbiAgICBjb25zdCB7IGxpbWl0IH0gPSB0aGlzLmdldFN0cmVhbUluc2VydChlbCk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBsaW1pdCAhPT0gbnVsbCAmJiBBcnJheS5mcm9tKGVsLnBhcmVudEVsZW1lbnQuY2hpbGRyZW4pO1xuICAgIGlmIChsaW1pdCAmJiBsaW1pdCA8IDAgJiYgY2hpbGRyZW4ubGVuZ3RoID4gbGltaXQgKiAtMSkge1xuICAgICAgY2hpbGRyZW5cbiAgICAgICAgLnNsaWNlKDAsIGNoaWxkcmVuLmxlbmd0aCArIGxpbWl0KVxuICAgICAgICAuZm9yRWFjaCgoY2hpbGQpID0+IHRoaXMucmVtb3ZlU3RyZWFtQ2hpbGRFbGVtZW50KGNoaWxkKSk7XG4gICAgfSBlbHNlIGlmIChsaW1pdCAmJiBsaW1pdCA+PSAwICYmIGNoaWxkcmVuLmxlbmd0aCA+IGxpbWl0KSB7XG4gICAgICBjaGlsZHJlblxuICAgICAgICAuc2xpY2UobGltaXQpXG4gICAgICAgIC5mb3JFYWNoKChjaGlsZCkgPT4gdGhpcy5yZW1vdmVTdHJlYW1DaGlsZEVsZW1lbnQoY2hpbGQpKTtcbiAgICB9XG4gIH1cblxuICB0cmFuc2l0aW9uUGVuZGluZ1JlbW92ZXMoKSB7XG4gICAgY29uc3QgeyBwZW5kaW5nUmVtb3ZlcywgbGl2ZVNvY2tldCB9ID0gdGhpcztcbiAgICBpZiAocGVuZGluZ1JlbW92ZXMubGVuZ3RoID4gMCkge1xuICAgICAgbGl2ZVNvY2tldC50cmFuc2l0aW9uUmVtb3ZlcyhwZW5kaW5nUmVtb3ZlcywgKCkgPT4ge1xuICAgICAgICBwZW5kaW5nUmVtb3Zlcy5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNoaWxkID0gRE9NLmZpcnN0UGh4Q2hpbGQoZWwpO1xuICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgbGl2ZVNvY2tldC5kZXN0cm95Vmlld0J5RWwoY2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbC5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudHJhY2tBZnRlcihcInRyYW5zaXRpb25zRGlzY2FyZGVkXCIsIHBlbmRpbmdSZW1vdmVzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlzQ2hhbmdlZFNlbGVjdChmcm9tRWwsIHRvRWwpIHtcbiAgICBpZiAoIShmcm9tRWwgaW5zdGFuY2VvZiBIVE1MU2VsZWN0RWxlbWVudCkgfHwgZnJvbUVsLm11bHRpcGxlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChmcm9tRWwub3B0aW9ucy5sZW5ndGggIT09IHRvRWwub3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGtlZXAgdGhlIGN1cnJlbnQgdmFsdWVcbiAgICB0b0VsLnZhbHVlID0gZnJvbUVsLnZhbHVlO1xuXG4gICAgLy8gaW4gZ2VuZXJhbCB3ZSBoYXZlIHRvIGJlIHZlcnkgY2FyZWZ1bCB3aXRoIHVzaW5nIGlzRXF1YWxOb2RlIGFzIGl0IGRvZXMgbm90IGEgcmVsaWFibGVcbiAgICAvLyBET00gdHJlZSBlcXVhbGl0eSBjaGVjaywgYnV0IGZvciBzZWxlY3Rpb24gYXR0cmlidXRlcyBhbmQgb3B0aW9ucyBpdCB3b3JrcyBmaW5lXG4gICAgcmV0dXJuICFmcm9tRWwuaXNFcXVhbE5vZGUodG9FbCk7XG4gIH1cblxuICBpc0NJRFBhdGNoKCkge1xuICAgIHJldHVybiB0aGlzLmNpZFBhdGNoO1xuICB9XG5cbiAgc2tpcENJRFNpYmxpbmcoZWwpIHtcbiAgICByZXR1cm4gZWwubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIGVsLmhhc0F0dHJpYnV0ZShQSFhfU0tJUCk7XG4gIH1cblxuICB0YXJnZXRDSURDb250YWluZXIoaHRtbCkge1xuICAgIGlmICghdGhpcy5pc0NJRFBhdGNoKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgW2ZpcnN0LCAuLi5yZXN0XSA9IERPTS5maW5kQ29tcG9uZW50Tm9kZUxpc3QoXG4gICAgICB0aGlzLnZpZXcuaWQsXG4gICAgICB0aGlzLnRhcmdldENJRCxcbiAgICApO1xuICAgIGlmIChyZXN0Lmxlbmd0aCA9PT0gMCAmJiBET00uY2hpbGROb2RlTGVuZ3RoKGh0bWwpID09PSAxKSB7XG4gICAgICByZXR1cm4gZmlyc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmaXJzdCAmJiBmaXJzdC5wYXJlbnROb2RlO1xuICAgIH1cbiAgfVxuXG4gIGluZGV4T2YocGFyZW50LCBjaGlsZCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHBhcmVudC5jaGlsZHJlbikuaW5kZXhPZihjaGlsZCk7XG4gIH1cblxuICB0ZWxlcG9ydChlbCwgbW9ycGgpIHtcbiAgICBjb25zdCB0YXJnZXRTZWxlY3RvciA9IGVsLmdldEF0dHJpYnV0ZShQSFhfUE9SVEFMKTtcbiAgICBjb25zdCBwb3J0YWxDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldFNlbGVjdG9yKTtcbiAgICBpZiAoIXBvcnRhbENvbnRhaW5lcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcInBvcnRhbCB0YXJnZXQgd2l0aCBzZWxlY3RvciBcIiArIHRhcmdldFNlbGVjdG9yICsgXCIgbm90IGZvdW5kXCIsXG4gICAgICApO1xuICAgIH1cbiAgICAvLyBwaHgtcG9ydGFsIHRlbXBsYXRlcyBtdXN0IGhhdmUgYSBzaW5nbGUgcm9vdCBlbGVtZW50LCBzbyB3ZSBhc3N1bWUgdGhpcyB0byBiZVxuICAgIC8vIHRoZSBjYXNlIGhlcmVcbiAgICBjb25zdCB0b1RlbGVwb3J0ID0gZWwuY29udGVudC5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAvLyB0aGUgUEhYX1NLSVAgb3B0aW1pemF0aW9uIGNhbiBhbHNvIGFwcGx5IGluc2lkZSBvZiB0aGUgPHRlbXBsYXRlPiBlbGVtZW50c1xuICAgIGlmICh0aGlzLnNraXBDSURTaWJsaW5nKHRvVGVsZXBvcnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdG9UZWxlcG9ydD8uaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJwaHgtcG9ydGFsIHRlbXBsYXRlIG11c3QgaGF2ZSBhIHNpbmdsZSByb290IGVsZW1lbnQgd2l0aCBJRCFcIixcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodG9UZWxlcG9ydC5pZCk7XG4gICAgbGV0IHBvcnRhbFRhcmdldDtcbiAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgIC8vIGNoZWNrIGlmIHRoZSBlbGVtZW50IG5lZWRzIHRvIGJlIG1vdmVkIHRvIGFub3RoZXIgdGFyZ2V0XG4gICAgICBpZiAoIXBvcnRhbENvbnRhaW5lci5jb250YWlucyhleGlzdGluZykpIHtcbiAgICAgICAgcG9ydGFsQ29udGFpbmVyLmFwcGVuZENoaWxkKGV4aXN0aW5nKTtcbiAgICAgIH1cbiAgICAgIC8vIHdlIGFscmVhZHkgdGVsZXBvcnRlZCBpbiBhIHByZXZpb3VzIHBhdGNoXG4gICAgICBwb3J0YWxUYXJnZXQgPSBleGlzdGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY3JlYXRlIGVtcHR5IHRhcmdldCBhbmQgbW9ycGggaXQgcmVjdXJzaXZlbHlcbiAgICAgIHBvcnRhbFRhcmdldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodG9UZWxlcG9ydC50YWdOYW1lKTtcbiAgICAgIHBvcnRhbENvbnRhaW5lci5hcHBlbmRDaGlsZChwb3J0YWxUYXJnZXQpO1xuICAgIH1cbiAgICAvLyBtYXJrIHRoZSB0YXJnZXQgYXMgdGVsZXBvcnRlZDtcbiAgICAvLyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IGF0dHJpYnV0ZSBtb2RpZmljYXRpb25zLCB3ZSBzZXQgdGhlIGF0dHJpYnV0ZVxuICAgIC8vIG9uIHRoZSBzb3VyY2UgYW5kIHJlbW92ZSBpdCBhZnRlciBtb3JwaGluZyAod2UgY291bGQgYWxzbyBqdXN0IGtlZXAgaXQpXG4gICAgLy8gb3RoZXJ3aXNlIG1vcnBoZG9tIHdvdWxkIHJlbW92ZSBpdCwgYXMgdGhlIHJlZiBpcyBub3QgcHJlc2VudCBpbiB0aGUgc291cmNlXG4gICAgLy8gYW5kIHdlJ2QgbmVlZCB0byBzZXQgaXQgYmFjayBhZnRlciBlYWNoIG1vcnBoXG4gICAgdG9UZWxlcG9ydC5zZXRBdHRyaWJ1dGUoUEhYX1RFTEVQT1JURURfUkVGLCB0aGlzLnZpZXcuaWQpO1xuICAgIHRvVGVsZXBvcnQuc2V0QXR0cmlidXRlKFBIWF9URUxFUE9SVEVEX1NSQywgZWwuaWQpO1xuICAgIG1vcnBoKHBvcnRhbFRhcmdldCwgdG9UZWxlcG9ydCwgdHJ1ZSk7XG4gICAgdG9UZWxlcG9ydC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1RFTEVQT1JURURfUkVGKTtcbiAgICB0b1RlbGVwb3J0LnJlbW92ZUF0dHJpYnV0ZShQSFhfVEVMRVBPUlRFRF9TUkMpO1xuICAgIC8vIHN0b3JlIGEgcmVmZXJlbmNlIHRvIHRoZSB0ZWxlcG9ydGVkIGVsZW1lbnQgaW4gdGhlIHZpZXdcbiAgICAvLyB0byBjbGVhbnVwIHdoZW4gdGhlIHZpZXcgaXMgZGVzdHJveWVkLCBpbiBjYXNlIHRoZSBwb3J0YWwgdGFyZ2V0XG4gICAgLy8gaXMgb3V0c2lkZSB0aGUgdmlldyBpdHNlbGZcbiAgICB0aGlzLnZpZXcucHVzaFBvcnRhbEVsZW1lbnRJZCh0b1RlbGVwb3J0LmlkKTtcbiAgfVxuXG4gIGhhbmRsZVJ1bnRpbWVIb29rKGVsLCBzb3VyY2UpIHtcbiAgICAvLyB1c3VhbGx5LCBzY3JpcHRzIGFyZSBub3QgZXhlY3V0ZWQgd2hlbiBtb3JwaGRvbSBhZGRzIHRoZW0gdG8gdGhlIERPTVxuICAgIC8vIHdlIHNwZWNpYWwgY2FzZSBydW50aW1lIGNvbG9jYXRlZCBob29rc1xuICAgIGNvbnN0IG5hbWUgPSBlbC5nZXRBdHRyaWJ1dGUoUEhYX1JVTlRJTUVfSE9PSyk7XG4gICAgbGV0IG5vbmNlID0gZWwuaGFzQXR0cmlidXRlKFwibm9uY2VcIikgPyBlbC5nZXRBdHRyaWJ1dGUoXCJub25jZVwiKSA6IG51bGw7XG4gICAgaWYgKGVsLmhhc0F0dHJpYnV0ZShcIm5vbmNlXCIpKSB7XG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbiAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHNvdXJjZTtcbiAgICAgIG5vbmNlID0gdGVtcGxhdGUuY29udGVudFxuICAgICAgICAucXVlcnlTZWxlY3Rvcihgc2NyaXB0WyR7UEhYX1JVTlRJTUVfSE9PS309XCIke0NTUy5lc2NhcGUobmFtZSl9XCJdYClcbiAgICAgICAgLmdldEF0dHJpYnV0ZShcIm5vbmNlXCIpO1xuICAgIH1cbiAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgIHNjcmlwdC50ZXh0Q29udGVudCA9IGVsLnRleHRDb250ZW50O1xuICAgIERPTS5tZXJnZUF0dHJzKHNjcmlwdCwgZWwsIHsgaXNJZ25vcmVkOiBmYWxzZSB9KTtcbiAgICBpZiAobm9uY2UpIHtcbiAgICAgIHNjcmlwdC5ub25jZSA9IG5vbmNlO1xuICAgIH1cbiAgICBlbC5yZXBsYWNlV2l0aChzY3JpcHQpO1xuICAgIGVsID0gc2NyaXB0O1xuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgQ09NUE9ORU5UUyxcbiAgVEVNUExBVEVTLFxuICBFVkVOVFMsXG4gIFBIWF9DT01QT05FTlQsXG4gIFBIWF9WSUVXX1JFRixcbiAgUEhYX1NLSVAsXG4gIFBIWF9NQUdJQ19JRCxcbiAgUkVQTFksXG4gIFNUQVRJQyxcbiAgVElUTEUsXG4gIFNUUkVBTSxcbiAgUk9PVCxcbiAgS0VZRUQsXG4gIEtFWUVEX0NPVU5ULFxufSBmcm9tIFwiLi9jb25zdGFudHNcIjtcblxuaW1wb3J0IHsgaXNPYmplY3QsIGxvZ0Vycm9yLCBpc0NpZCB9IGZyb20gXCIuL3V0aWxzXCI7XG5cbmNvbnN0IFZPSURfVEFHUyA9IG5ldyBTZXQoW1xuICBcImFyZWFcIixcbiAgXCJiYXNlXCIsXG4gIFwiYnJcIixcbiAgXCJjb2xcIixcbiAgXCJjb21tYW5kXCIsXG4gIFwiZW1iZWRcIixcbiAgXCJoclwiLFxuICBcImltZ1wiLFxuICBcImlucHV0XCIsXG4gIFwia2V5Z2VuXCIsXG4gIFwibGlua1wiLFxuICBcIm1ldGFcIixcbiAgXCJwYXJhbVwiLFxuICBcInNvdXJjZVwiLFxuICBcInRyYWNrXCIsXG4gIFwid2JyXCIsXG5dKTtcbmNvbnN0IHF1b3RlQ2hhcnMgPSBuZXcgU2V0KFtcIidcIiwgJ1wiJ10pO1xuXG5leHBvcnQgY29uc3QgbW9kaWZ5Um9vdCA9IChodG1sLCBhdHRycywgY2xlYXJJbm5lckhUTUwpID0+IHtcbiAgbGV0IGkgPSAwO1xuICBsZXQgaW5zaWRlQ29tbWVudCA9IGZhbHNlO1xuICBsZXQgYmVmb3JlVGFnLCBhZnRlclRhZywgdGFnLCB0YWdOYW1lRW5kc0F0LCBpZCwgbmV3SFRNTDtcblxuICBjb25zdCBsb29rYWhlYWQgPSBodG1sLm1hdGNoKC9eKFxccyooPzo8IS0tLio/LS0+XFxzKikqKTwoW15cXHNcXC8+XSspLyk7XG4gIGlmIChsb29rYWhlYWQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG1hbGZvcm1lZCBodG1sICR7aHRtbH1gKTtcbiAgfVxuXG4gIGkgPSBsb29rYWhlYWRbMF0ubGVuZ3RoO1xuICBiZWZvcmVUYWcgPSBsb29rYWhlYWRbMV07XG4gIHRhZyA9IGxvb2thaGVhZFsyXTtcbiAgdGFnTmFtZUVuZHNBdCA9IGk7XG5cbiAgLy8gU2NhbiB0aGUgb3BlbmluZyB0YWcgZm9yIGlkLCBpZiB0aGVyZSBpcyBhbnlcbiAgZm9yIChpOyBpIDwgaHRtbC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChodG1sLmNoYXJBdChpKSA9PT0gXCI+XCIpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoaHRtbC5jaGFyQXQoaSkgPT09IFwiPVwiKSB7XG4gICAgICBjb25zdCBpc0lkID0gaHRtbC5zbGljZShpIC0gMywgaSkgPT09IFwiIGlkXCI7XG4gICAgICBpKys7XG4gICAgICBjb25zdCBjaGFyID0gaHRtbC5jaGFyQXQoaSk7XG4gICAgICBpZiAocXVvdGVDaGFycy5oYXMoY2hhcikpIHtcbiAgICAgICAgY29uc3QgYXR0clN0YXJ0c0F0ID0gaTtcbiAgICAgICAgaSsrO1xuICAgICAgICBmb3IgKGk7IGkgPCBodG1sLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGh0bWwuY2hhckF0KGkpID09PSBjaGFyKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSWQpIHtcbiAgICAgICAgICBpZCA9IGh0bWwuc2xpY2UoYXR0clN0YXJ0c0F0ICsgMSwgaSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsZXQgY2xvc2VBdCA9IGh0bWwubGVuZ3RoIC0gMTtcbiAgaW5zaWRlQ29tbWVudCA9IGZhbHNlO1xuICB3aGlsZSAoY2xvc2VBdCA+PSBiZWZvcmVUYWcubGVuZ3RoICsgdGFnLmxlbmd0aCkge1xuICAgIGNvbnN0IGNoYXIgPSBodG1sLmNoYXJBdChjbG9zZUF0KTtcbiAgICBpZiAoaW5zaWRlQ29tbWVudCkge1xuICAgICAgaWYgKGNoYXIgPT09IFwiLVwiICYmIGh0bWwuc2xpY2UoY2xvc2VBdCAtIDMsIGNsb3NlQXQpID09PSBcIjwhLVwiKSB7XG4gICAgICAgIGluc2lkZUNvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgY2xvc2VBdCAtPSA0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xvc2VBdCAtPSAxO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gXCI+XCIgJiYgaHRtbC5zbGljZShjbG9zZUF0IC0gMiwgY2xvc2VBdCkgPT09IFwiLS1cIikge1xuICAgICAgaW5zaWRlQ29tbWVudCA9IHRydWU7XG4gICAgICBjbG9zZUF0IC09IDM7XG4gICAgfSBlbHNlIGlmIChjaGFyID09PSBcIj5cIikge1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsb3NlQXQgLT0gMTtcbiAgICB9XG4gIH1cbiAgYWZ0ZXJUYWcgPSBodG1sLnNsaWNlKGNsb3NlQXQgKyAxLCBodG1sLmxlbmd0aCk7XG5cbiAgY29uc3QgYXR0cnNTdHIgPSBPYmplY3Qua2V5cyhhdHRycylcbiAgICAubWFwKChhdHRyKSA9PiAoYXR0cnNbYXR0cl0gPT09IHRydWUgPyBhdHRyIDogYCR7YXR0cn09XCIke2F0dHJzW2F0dHJdfVwiYCkpXG4gICAgLmpvaW4oXCIgXCIpO1xuXG4gIGlmIChjbGVhcklubmVySFRNTCkge1xuICAgIC8vIEtlZXAgdGhlIGlkIGlmIGFueVxuICAgIGNvbnN0IGlkQXR0clN0ciA9IGlkID8gYCBpZD1cIiR7aWR9XCJgIDogXCJcIjtcbiAgICBpZiAoVk9JRF9UQUdTLmhhcyh0YWcpKSB7XG4gICAgICBuZXdIVE1MID0gYDwke3RhZ30ke2lkQXR0clN0cn0ke2F0dHJzU3RyID09PSBcIlwiID8gXCJcIiA6IFwiIFwifSR7YXR0cnNTdHJ9Lz5gO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdIVE1MID0gYDwke3RhZ30ke2lkQXR0clN0cn0ke2F0dHJzU3RyID09PSBcIlwiID8gXCJcIiA6IFwiIFwifSR7YXR0cnNTdHJ9PjwvJHt0YWd9PmA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHJlc3QgPSBodG1sLnNsaWNlKHRhZ05hbWVFbmRzQXQsIGNsb3NlQXQgKyAxKTtcbiAgICBuZXdIVE1MID0gYDwke3RhZ30ke2F0dHJzU3RyID09PSBcIlwiID8gXCJcIiA6IFwiIFwifSR7YXR0cnNTdHJ9JHtyZXN0fWA7XG4gIH1cblxuICByZXR1cm4gW25ld0hUTUwsIGJlZm9yZVRhZywgYWZ0ZXJUYWddO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyZWQge1xuICBzdGF0aWMgZXh0cmFjdChkaWZmKSB7XG4gICAgY29uc3QgeyBbUkVQTFldOiByZXBseSwgW0VWRU5UU106IGV2ZW50cywgW1RJVExFXTogdGl0bGUgfSA9IGRpZmY7XG4gICAgZGVsZXRlIGRpZmZbUkVQTFldO1xuICAgIGRlbGV0ZSBkaWZmW0VWRU5UU107XG4gICAgZGVsZXRlIGRpZmZbVElUTEVdO1xuICAgIHJldHVybiB7IGRpZmYsIHRpdGxlLCByZXBseTogcmVwbHkgfHwgbnVsbCwgZXZlbnRzOiBldmVudHMgfHwgW10gfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHZpZXdJZCwgcmVuZGVyZWQpIHtcbiAgICB0aGlzLnZpZXdJZCA9IHZpZXdJZDtcbiAgICB0aGlzLnJlbmRlcmVkID0ge307XG4gICAgdGhpcy5tYWdpY0lkID0gMDtcbiAgICB0aGlzLm1lcmdlRGlmZihyZW5kZXJlZCk7XG4gIH1cblxuICBwYXJlbnRWaWV3SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlld0lkO1xuICB9XG5cbiAgdG9TdHJpbmcob25seUNpZHMpIHtcbiAgICBjb25zdCB7IGJ1ZmZlcjogc3RyLCBzdHJlYW1zOiBzdHJlYW1zIH0gPSB0aGlzLnJlY3Vyc2l2ZVRvU3RyaW5nKFxuICAgICAgdGhpcy5yZW5kZXJlZCxcbiAgICAgIHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU10sXG4gICAgICBvbmx5Q2lkcyxcbiAgICAgIHRydWUsXG4gICAgICB7fSxcbiAgICApO1xuICAgIHJldHVybiB7IGJ1ZmZlcjogc3RyLCBzdHJlYW1zOiBzdHJlYW1zIH07XG4gIH1cblxuICByZWN1cnNpdmVUb1N0cmluZyhcbiAgICByZW5kZXJlZCxcbiAgICBjb21wb25lbnRzID0gcmVuZGVyZWRbQ09NUE9ORU5UU10sXG4gICAgb25seUNpZHMsXG4gICAgY2hhbmdlVHJhY2tpbmcsXG4gICAgcm9vdEF0dHJzLFxuICApIHtcbiAgICBvbmx5Q2lkcyA9IG9ubHlDaWRzID8gbmV3IFNldChvbmx5Q2lkcykgOiBudWxsO1xuICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgIGJ1ZmZlcjogXCJcIixcbiAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHMsXG4gICAgICBvbmx5Q2lkczogb25seUNpZHMsXG4gICAgICBzdHJlYW1zOiBuZXcgU2V0KCksXG4gICAgfTtcbiAgICB0aGlzLnRvT3V0cHV0QnVmZmVyKHJlbmRlcmVkLCBudWxsLCBvdXRwdXQsIGNoYW5nZVRyYWNraW5nLCByb290QXR0cnMpO1xuICAgIHJldHVybiB7IGJ1ZmZlcjogb3V0cHV0LmJ1ZmZlciwgc3RyZWFtczogb3V0cHV0LnN0cmVhbXMgfTtcbiAgfVxuXG4gIGNvbXBvbmVudENJRHMoZGlmZikge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhkaWZmW0NPTVBPTkVOVFNdIHx8IHt9KS5tYXAoKGkpID0+IHBhcnNlSW50KGkpKTtcbiAgfVxuXG4gIGlzQ29tcG9uZW50T25seURpZmYoZGlmZikge1xuICAgIGlmICghZGlmZltDT01QT05FTlRTXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZGlmZikubGVuZ3RoID09PSAxO1xuICB9XG5cbiAgZ2V0Q29tcG9uZW50KGRpZmYsIGNpZCkge1xuICAgIHJldHVybiBkaWZmW0NPTVBPTkVOVFNdW2NpZF07XG4gIH1cblxuICByZXNldFJlbmRlcihjaWQpIHtcbiAgICAvLyB3ZSBhcmUgcmFjaW5nIGEgY29tcG9uZW50IGRlc3Ryb3ksIGl0IGNvdWxkIG5vdCBleGlzdCwgc29cbiAgICAvLyBtYWtlIHN1cmUgdGhhdCB3ZSBkb24ndCB0cnkgdG8gc2V0IHJlc2V0IG9uIHVuZGVmaW5lZFxuICAgIGlmICh0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdW2NpZF0pIHtcbiAgICAgIHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU11bY2lkXS5yZXNldCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgbWVyZ2VEaWZmKGRpZmYpIHtcbiAgICBjb25zdCBuZXdjID0gZGlmZltDT01QT05FTlRTXTtcbiAgICBjb25zdCBjYWNoZSA9IHt9O1xuICAgIGRlbGV0ZSBkaWZmW0NPTVBPTkVOVFNdO1xuICAgIHRoaXMucmVuZGVyZWQgPSB0aGlzLm11dGFibGVNZXJnZSh0aGlzLnJlbmRlcmVkLCBkaWZmKTtcbiAgICB0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdID0gdGhpcy5yZW5kZXJlZFtDT01QT05FTlRTXSB8fCB7fTtcblxuICAgIGlmIChuZXdjKSB7XG4gICAgICBjb25zdCBvbGRjID0gdGhpcy5yZW5kZXJlZFtDT01QT05FTlRTXTtcblxuICAgICAgZm9yIChjb25zdCBjaWQgaW4gbmV3Yykge1xuICAgICAgICBuZXdjW2NpZF0gPSB0aGlzLmNhY2hlZEZpbmRDb21wb25lbnQoY2lkLCBuZXdjW2NpZF0sIG9sZGMsIG5ld2MsIGNhY2hlKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBjaWQgaW4gbmV3Yykge1xuICAgICAgICBvbGRjW2NpZF0gPSBuZXdjW2NpZF07XG4gICAgICB9XG4gICAgICBkaWZmW0NPTVBPTkVOVFNdID0gbmV3YztcbiAgICB9XG4gIH1cblxuICBjYWNoZWRGaW5kQ29tcG9uZW50KGNpZCwgY2RpZmYsIG9sZGMsIG5ld2MsIGNhY2hlKSB7XG4gICAgaWYgKGNhY2hlW2NpZF0pIHtcbiAgICAgIHJldHVybiBjYWNoZVtjaWRdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbmRpZmYsXG4gICAgICAgIHN0YXQsXG4gICAgICAgIHNjaWQgPSBjZGlmZltTVEFUSUNdO1xuXG4gICAgICBpZiAoaXNDaWQoc2NpZCkpIHtcbiAgICAgICAgbGV0IHRkaWZmO1xuXG4gICAgICAgIGlmIChzY2lkID4gMCkge1xuICAgICAgICAgIHRkaWZmID0gdGhpcy5jYWNoZWRGaW5kQ29tcG9uZW50KHNjaWQsIG5ld2Nbc2NpZF0sIG9sZGMsIG5ld2MsIGNhY2hlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZGlmZiA9IG9sZGNbLXNjaWRdO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdCA9IHRkaWZmW1NUQVRJQ107XG4gICAgICAgIG5kaWZmID0gdGhpcy5jbG9uZU1lcmdlKHRkaWZmLCBjZGlmZiwgdHJ1ZSk7XG4gICAgICAgIG5kaWZmW1NUQVRJQ10gPSBzdGF0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmRpZmYgPVxuICAgICAgICAgIGNkaWZmW1NUQVRJQ10gIT09IHVuZGVmaW5lZCB8fCBvbGRjW2NpZF0gPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBjZGlmZlxuICAgICAgICAgICAgOiB0aGlzLmNsb25lTWVyZ2Uob2xkY1tjaWRdLCBjZGlmZiwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBjYWNoZVtjaWRdID0gbmRpZmY7XG4gICAgICByZXR1cm4gbmRpZmY7XG4gICAgfVxuICB9XG5cbiAgbXV0YWJsZU1lcmdlKHRhcmdldCwgc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZVtTVEFUSUNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZG9NdXRhYmxlTWVyZ2UodGFyZ2V0LCBzb3VyY2UpO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH1cblxuICBkb011dGFibGVNZXJnZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2VbS0VZRURdKSB7XG4gICAgICB0aGlzLm1lcmdlS2V5ZWQodGFyZ2V0LCBzb3VyY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgY29uc3QgdmFsID0gc291cmNlW2tleV07XG4gICAgICAgIGNvbnN0IHRhcmdldFZhbCA9IHRhcmdldFtrZXldO1xuICAgICAgICBjb25zdCBpc09ialZhbCA9IGlzT2JqZWN0KHZhbCk7XG4gICAgICAgIGlmIChpc09ialZhbCAmJiB2YWxbU1RBVElDXSA9PT0gdW5kZWZpbmVkICYmIGlzT2JqZWN0KHRhcmdldFZhbCkpIHtcbiAgICAgICAgICB0aGlzLmRvTXV0YWJsZU1lcmdlKHRhcmdldFZhbCwgdmFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGFyZ2V0W1JPT1RdKSB7XG4gICAgICB0YXJnZXQubmV3UmVuZGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBjbG9uZShkaWZmKSB7XG4gICAgaWYgKFwic3RydWN0dXJlZENsb25lXCIgaW4gd2luZG93KSB7XG4gICAgICByZXR1cm4gc3RydWN0dXJlZENsb25lKGRpZmYpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmYWxsYmFjayBmb3IgamVzdFxuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGlmZikpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGtleWVkIGNvbXByZWhlbnNpb25zXG4gIG1lcmdlS2V5ZWQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAvLyB3ZSBuZWVkIHRvIGNsb25lIHRoZSB0YXJnZXQgc2luY2UgZWxlbWVudHMgY2FuIG1vdmUgYW5kIG90aGVyd2lzZVxuICAgIC8vIGl0IGNvdWxkIGhhcHBlbiB0aGF0IHdlIG1vZGlmeSBhbiBlbGVtZW50IHRoYXQgd2UnbGwgbmVlZCB0byByZWZlciB0b1xuICAgIC8vIGxhdGVyXG4gICAgY29uc3QgY2xvbmVkVGFyZ2V0ID0gdGhpcy5jbG9uZSh0YXJnZXQpO1xuICAgIE9iamVjdC5lbnRyaWVzKHNvdXJjZVtLRVlFRF0pLmZvckVhY2goKFtpLCBlbnRyeV0pID0+IHtcbiAgICAgIGlmIChpID09PSBLRVlFRF9DT1VOVCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShlbnRyeSkpIHtcbiAgICAgICAgLy8gW29sZF9pZHgsIGRpZmZdXG4gICAgICAgIC8vIG1vdmVkIHdpdGggZGlmZlxuICAgICAgICBjb25zdCBbb2xkX2lkeCwgZGlmZl0gPSBlbnRyeTtcbiAgICAgICAgdGFyZ2V0W0tFWUVEXVtpXSA9IGNsb25lZFRhcmdldFtLRVlFRF1bb2xkX2lkeF07XG4gICAgICAgIHRoaXMuZG9NdXRhYmxlTWVyZ2UodGFyZ2V0W0tFWUVEXVtpXSwgZGlmZik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbnRyeSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAvLyBtb3ZlZCB3aXRob3V0IGRpZmZcbiAgICAgICAgY29uc3Qgb2xkX2lkeCA9IGVudHJ5O1xuICAgICAgICB0YXJnZXRbS0VZRURdW2ldID0gY2xvbmVkVGFyZ2V0W0tFWUVEXVtvbGRfaWR4XTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVudHJ5ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIC8vIGRpZmYsIHNhbWUgcG9zaXRpb25cbiAgICAgICAgaWYgKCF0YXJnZXRbS0VZRURdW2ldKSB7XG4gICAgICAgICAgdGFyZ2V0W0tFWUVEXVtpXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9NdXRhYmxlTWVyZ2UodGFyZ2V0W0tFWUVEXVtpXSwgZW50cnkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIGRyb3AgZXh0cmEgZW50cmllc1xuICAgIGlmIChzb3VyY2VbS0VZRURdW0tFWUVEX0NPVU5UXSA8IHRhcmdldFtLRVlFRF1bS0VZRURfQ09VTlRdKSB7XG4gICAgICBmb3IgKFxuICAgICAgICBsZXQgaSA9IHNvdXJjZVtLRVlFRF1bS0VZRURfQ09VTlRdO1xuICAgICAgICBpIDwgdGFyZ2V0W0tFWUVEXVtLRVlFRF9DT1VOVF07XG4gICAgICAgIGkrK1xuICAgICAgKSB7XG4gICAgICAgIGRlbGV0ZSB0YXJnZXRbS0VZRURdW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICB0YXJnZXRbS0VZRURdW0tFWUVEX0NPVU5UXSA9IHNvdXJjZVtLRVlFRF1bS0VZRURfQ09VTlRdO1xuICAgIGlmIChzb3VyY2VbU1RSRUFNXSkge1xuICAgICAgdGFyZ2V0W1NUUkVBTV0gPSBzb3VyY2VbU1RSRUFNXTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZVtURU1QTEFURVNdKSB7XG4gICAgICB0YXJnZXRbVEVNUExBVEVTXSA9IHNvdXJjZVtURU1QTEFURVNdO1xuICAgIH1cbiAgfVxuXG4gIC8vIE1lcmdlcyBjaWQgdHJlZXMgdG9nZXRoZXIsIGNvcHlpbmcgc3RhdGljcyBmcm9tIHNvdXJjZSB0cmVlLlxuICAvL1xuICAvLyBUaGUgYHBydW5lTWFnaWNJZGAgaXMgcGFzc2VkIHRvIGNvbnRyb2wgcHJ1bmluZyB0aGUgbWFnaWNJZCBvZiB0aGVcbiAgLy8gdGFyZ2V0LiBXZSBtdXN0IGFsd2F5cyBwcnVuZSB0aGUgbWFnaWNJZCB3aGVuIHdlIGFyZSBzaGFyaW5nIHN0YXRpY3NcbiAgLy8gZnJvbSBhbm90aGVyIGNvbXBvbmVudC4gSWYgbm90IHBydW5pbmcsIHdlIHJlcGxpY2F0ZSB0aGUgbG9naWMgZnJvbVxuICAvLyBtdXRhYmxlTWVyZ2UsIHdoZXJlIHdlIHNldCBuZXdSZW5kZXIgdG8gdHJ1ZSBpZiB0aGVyZSBpcyBhIHJvb3RcbiAgLy8gKGVmZmVjdGl2ZWx5IGZvcmNpbmcgdGhlIG5ldyB2ZXJzaW9uIHRvIGJlIHJlbmRlcmVkIGluc3RlYWQgb2Ygc2tpcHBlZClcbiAgLy9cbiAgY2xvbmVNZXJnZSh0YXJnZXQsIHNvdXJjZSwgcHJ1bmVNYWdpY0lkKSB7XG4gICAgbGV0IG1lcmdlZDtcbiAgICBpZiAoc291cmNlW0tFWUVEXSkge1xuICAgICAgbWVyZ2VkID0gdGhpcy5jbG9uZSh0YXJnZXQpO1xuICAgICAgdGhpcy5tZXJnZUtleWVkKG1lcmdlZCwgc291cmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVyZ2VkID0geyAuLi50YXJnZXQsIC4uLnNvdXJjZSB9O1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gbWVyZ2VkKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHNvdXJjZVtrZXldO1xuICAgICAgICBjb25zdCB0YXJnZXRWYWwgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHZhbCkgJiYgdmFsW1NUQVRJQ10gPT09IHVuZGVmaW5lZCAmJiBpc09iamVjdCh0YXJnZXRWYWwpKSB7XG4gICAgICAgICAgbWVyZ2VkW2tleV0gPSB0aGlzLmNsb25lTWVyZ2UodGFyZ2V0VmFsLCB2YWwsIHBydW5lTWFnaWNJZCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsID09PSB1bmRlZmluZWQgJiYgaXNPYmplY3QodGFyZ2V0VmFsKSkge1xuICAgICAgICAgIG1lcmdlZFtrZXldID0gdGhpcy5jbG9uZU1lcmdlKHRhcmdldFZhbCwge30sIHBydW5lTWFnaWNJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBydW5lTWFnaWNJZCkge1xuICAgICAgZGVsZXRlIG1lcmdlZC5tYWdpY0lkO1xuICAgICAgZGVsZXRlIG1lcmdlZC5uZXdSZW5kZXI7XG4gICAgfSBlbHNlIGlmICh0YXJnZXRbUk9PVF0pIHtcbiAgICAgIG1lcmdlZC5uZXdSZW5kZXIgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VkO1xuICB9XG5cbiAgY29tcG9uZW50VG9TdHJpbmcoY2lkKSB7XG4gICAgY29uc3QgeyBidWZmZXI6IHN0ciwgc3RyZWFtcyB9ID0gdGhpcy5yZWN1cnNpdmVDSURUb1N0cmluZyhcbiAgICAgIHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU10sXG4gICAgICBjaWQsXG4gICAgICBudWxsLFxuICAgICk7XG4gICAgY29uc3QgW3N0cmlwcGVkSFRNTCwgX2JlZm9yZSwgX2FmdGVyXSA9IG1vZGlmeVJvb3Qoc3RyLCB7fSk7XG4gICAgcmV0dXJuIHsgYnVmZmVyOiBzdHJpcHBlZEhUTUwsIHN0cmVhbXM6IHN0cmVhbXMgfTtcbiAgfVxuXG4gIHBydW5lQ0lEcyhjaWRzKSB7XG4gICAgY2lkcy5mb3JFYWNoKChjaWQpID0+IGRlbGV0ZSB0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdW2NpZF0pO1xuICB9XG5cbiAgLy8gcHJpdmF0ZVxuXG4gIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlZDtcbiAgfVxuXG4gIGlzTmV3RmluZ2VycHJpbnQoZGlmZiA9IHt9KSB7XG4gICAgcmV0dXJuICEhZGlmZltTVEFUSUNdO1xuICB9XG5cbiAgdGVtcGxhdGVTdGF0aWMocGFydCwgdGVtcGxhdGVzKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJ0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gdGVtcGxhdGVzW3BhcnRdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFydDtcbiAgICB9XG4gIH1cblxuICBuZXh0TWFnaWNJRCgpIHtcbiAgICB0aGlzLm1hZ2ljSWQrKztcbiAgICByZXR1cm4gYG0ke3RoaXMubWFnaWNJZH0tJHt0aGlzLnBhcmVudFZpZXdJZCgpfWA7XG4gIH1cblxuICAvLyBDb252ZXJ0cyByZW5kZXJlZCB0cmVlIHRvIG91dHB1dCBidWZmZXIuXG4gIC8vXG4gIC8vIGNoYW5nZVRyYWNraW5nIGNvbnRyb2xzIGlmIHdlIGNhbiBhcHBseSB0aGUgUEhYX1NLSVAgb3B0aW1pemF0aW9uLlxuICB0b091dHB1dEJ1ZmZlcihyZW5kZXJlZCwgdGVtcGxhdGVzLCBvdXRwdXQsIGNoYW5nZVRyYWNraW5nLCByb290QXR0cnMgPSB7fSkge1xuICAgIGlmIChyZW5kZXJlZFtLRVlFRF0pIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXByZWhlbnNpb25Ub0J1ZmZlcihcbiAgICAgICAgcmVuZGVyZWQsXG4gICAgICAgIHRlbXBsYXRlcyxcbiAgICAgICAgb3V0cHV0LFxuICAgICAgICBjaGFuZ2VUcmFja2luZyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gVGVtcGxhdGVzIGFyZSBhIHdheSBvZiBzaGFyaW5nIHN0YXRpY3MgYmV0d2VlbiBtdWx0aXBsZSByZW5kZXJlZCBzdHJ1Y3RzLlxuICAgIC8vIFNpbmNlIExpdmVWaWV3IDEuMSwgdGhvc2UgY2FuIGFsc28gYXBwZWFyIGF0IHRoZSByb290IC0gZm9yIGV4YW1wbGUgaWYgb25lIHJlbmRlcnNcbiAgICAvLyB0d28gY29tcHJlaGVuc2lvbnMgdGhhdCBjYW4gc2hhcmUgc3RhdGljcy5cbiAgICAvLyBXaGVuZXZlciB3ZSBmaW5kIHRlbXBsYXRlcywgd2UgbmVlZCB0byB1c2UgdGhlbSByZWN1cnNpdmVseS4gQWxzbywgdGVtcGxhdGVzIGNhblxuICAgIC8vIGJlIHNlbnQgZm9yIGVhY2ggZGlmZiwgbm90IG9ubHkgZm9yIHRoZSBpbml0aWFsIG9uZS4gV2UgZG9uJ3Qgd2FudCB0byBtZXJnZSB0aGVtXG4gICAgLy8gdGhvdWdoLCBzbyB3ZSBhbHdheXMgcmVzb2x2ZSB0aGVtIGFuZCByZW1vdmUgdGhlbSBmcm9tIHRoZSByZW5kZXJlZCBvYmplY3QuXG4gICAgaWYgKHJlbmRlcmVkW1RFTVBMQVRFU10pIHtcbiAgICAgIHRlbXBsYXRlcyA9IHJlbmRlcmVkW1RFTVBMQVRFU107XG4gICAgICBkZWxldGUgcmVuZGVyZWRbVEVNUExBVEVTXTtcbiAgICB9XG5cbiAgICBsZXQgeyBbU1RBVElDXTogc3RhdGljcyB9ID0gcmVuZGVyZWQ7XG4gICAgc3RhdGljcyA9IHRoaXMudGVtcGxhdGVTdGF0aWMoc3RhdGljcywgdGVtcGxhdGVzKTtcbiAgICByZW5kZXJlZFtTVEFUSUNdID0gc3RhdGljcztcbiAgICBjb25zdCBpc1Jvb3QgPSByZW5kZXJlZFtST09UXTtcbiAgICBjb25zdCBwcmV2QnVmZmVyID0gb3V0cHV0LmJ1ZmZlcjtcbiAgICBpZiAoaXNSb290KSB7XG4gICAgICBvdXRwdXQuYnVmZmVyID0gXCJcIjtcbiAgICB9XG5cbiAgICAvLyB0aGlzIGNvbmRpdGlvbiBpcyBjYWxsZWQgd2hlbiBmaXJzdCByZW5kZXJpbmcgYW4gb3B0aW1pemFibGUgZnVuY3Rpb24gY29tcG9uZW50LlxuICAgIC8vIExDIGhhdmUgdGhlaXIgbWFnaWNJZCBwcmV2aW91c2x5IHNldFxuICAgIGlmIChjaGFuZ2VUcmFja2luZyAmJiBpc1Jvb3QgJiYgIXJlbmRlcmVkLm1hZ2ljSWQpIHtcbiAgICAgIHJlbmRlcmVkLm5ld1JlbmRlciA9IHRydWU7XG4gICAgICByZW5kZXJlZC5tYWdpY0lkID0gdGhpcy5uZXh0TWFnaWNJRCgpO1xuICAgIH1cblxuICAgIG91dHB1dC5idWZmZXIgKz0gc3RhdGljc1swXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN0YXRpY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuZHluYW1pY1RvQnVmZmVyKHJlbmRlcmVkW2kgLSAxXSwgdGVtcGxhdGVzLCBvdXRwdXQsIGNoYW5nZVRyYWNraW5nKTtcbiAgICAgIG91dHB1dC5idWZmZXIgKz0gc3RhdGljc1tpXTtcbiAgICB9XG5cbiAgICAvLyBBcHBsaWVzIHRoZSByb290IHRhZyBcInNraXBcIiBvcHRpbWl6YXRpb24gaWYgc3VwcG9ydGVkLCB3aGljaCBjbGVhcnNcbiAgICAvLyB0aGUgcm9vdCB0YWcgYXR0cmlidXRlcyBhbmQgaW5uZXJIVE1MLCBhbmQgb25seSBtYWludGFpbnMgdGhlIG1hZ2ljSWQuXG4gICAgLy8gV2UgY2FuIG9ubHkgc2tpcCB3aGVuIGNoYW5nZVRyYWNraW5nIGlzIHN1cHBvcnRlZCxcbiAgICAvLyBhbmQgd2hlbiB0aGUgcm9vdCBlbGVtZW50IGhhc24ndCBleHBlcmllbmNlZCBhbiB1bnJlbmRlcmVkIG1lcmdlIChuZXdSZW5kZXIgdHJ1ZSkuXG4gICAgaWYgKGlzUm9vdCkge1xuICAgICAgbGV0IHNraXAgPSBmYWxzZTtcbiAgICAgIGxldCBhdHRycztcbiAgICAgIC8vIFdoZW4gYSBMQyBpcyByZS1hZGRlZCB0byB0aGUgcGFnZSwgd2UgbmVlZCB0byByZS1yZW5kZXIgdGhlIGVudGlyZSBMQyB0cmVlLFxuICAgICAgLy8gdGhlcmVmb3JlIGNoYW5nZVRyYWNraW5nIGlzIGZhbHNlOyBob3dldmVyLCB3ZSBuZWVkIHRvIGtlZXAgYWxsIHRoZSBtYWdpY0lkc1xuICAgICAgLy8gZnJvbSBhbnkgZnVuY3Rpb24gY29tcG9uZW50IHNvIHRoZSBuZXh0IHRpbWUgdGhlIExDIGlzIHVwZGF0ZWQsIHdlIGNhbiBhcHBseVxuICAgICAgLy8gdGhlIHNraXAgb3B0aW1pemF0aW9uXG4gICAgICBpZiAoY2hhbmdlVHJhY2tpbmcgfHwgcmVuZGVyZWQubWFnaWNJZCkge1xuICAgICAgICBza2lwID0gY2hhbmdlVHJhY2tpbmcgJiYgIXJlbmRlcmVkLm5ld1JlbmRlcjtcbiAgICAgICAgYXR0cnMgPSB7IFtQSFhfTUFHSUNfSURdOiByZW5kZXJlZC5tYWdpY0lkLCAuLi5yb290QXR0cnMgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJzID0gcm9vdEF0dHJzO1xuICAgICAgfVxuICAgICAgaWYgKHNraXApIHtcbiAgICAgICAgYXR0cnNbUEhYX1NLSVBdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFtuZXdSb290LCBjb21tZW50QmVmb3JlLCBjb21tZW50QWZ0ZXJdID0gbW9kaWZ5Um9vdChcbiAgICAgICAgb3V0cHV0LmJ1ZmZlcixcbiAgICAgICAgYXR0cnMsXG4gICAgICAgIHNraXAsXG4gICAgICApO1xuICAgICAgcmVuZGVyZWQubmV3UmVuZGVyID0gZmFsc2U7XG4gICAgICBvdXRwdXQuYnVmZmVyID0gcHJldkJ1ZmZlciArIGNvbW1lbnRCZWZvcmUgKyBuZXdSb290ICsgY29tbWVudEFmdGVyO1xuICAgIH1cbiAgfVxuXG4gIGNvbXByZWhlbnNpb25Ub0J1ZmZlcihyZW5kZXJlZCwgdGVtcGxhdGVzLCBvdXRwdXQsIGNoYW5nZVRyYWNraW5nKSB7XG4gICAgY29uc3Qga2V5ZWRUZW1wbGF0ZXMgPSB0ZW1wbGF0ZXMgfHwgcmVuZGVyZWRbVEVNUExBVEVTXTtcbiAgICBjb25zdCBzdGF0aWNzID0gdGhpcy50ZW1wbGF0ZVN0YXRpYyhyZW5kZXJlZFtTVEFUSUNdLCB0ZW1wbGF0ZXMpO1xuICAgIHJlbmRlcmVkW1NUQVRJQ10gPSBzdGF0aWNzO1xuICAgIGRlbGV0ZSByZW5kZXJlZFtURU1QTEFURVNdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVuZGVyZWRbS0VZRURdW0tFWUVEX0NPVU5UXTsgaSsrKSB7XG4gICAgICBvdXRwdXQuYnVmZmVyICs9IHN0YXRpY3NbMF07XG4gICAgICBmb3IgKGxldCBqID0gMTsgaiA8IHN0YXRpY3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdGhpcy5keW5hbWljVG9CdWZmZXIoXG4gICAgICAgICAgcmVuZGVyZWRbS0VZRURdW2ldW2ogLSAxXSxcbiAgICAgICAgICBrZXllZFRlbXBsYXRlcyxcbiAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgY2hhbmdlVHJhY2tpbmcsXG4gICAgICAgICk7XG4gICAgICAgIG91dHB1dC5idWZmZXIgKz0gc3RhdGljc1tqXTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gd2UgZG9uJ3QgbmVlZCB0byBzdG9yZSB0aGUgcmVuZGVyZWQgdHJlZSBmb3Igc3RyZWFtc1xuICAgIGlmIChyZW5kZXJlZFtTVFJFQU1dKSB7XG4gICAgICBjb25zdCBzdHJlYW0gPSByZW5kZXJlZFtTVFJFQU1dO1xuICAgICAgY29uc3QgW19yZWYsIF9pbnNlcnRzLCBkZWxldGVJZHMsIHJlc2V0XSA9IHN0cmVhbSB8fCBbbnVsbCwge30sIFtdLCBudWxsXTtcbiAgICAgIGlmIChcbiAgICAgICAgc3RyZWFtICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgKHJlbmRlcmVkW0tFWUVEXVtLRVlFRF9DT1VOVF0gPiAwIHx8IGRlbGV0ZUlkcy5sZW5ndGggPiAwIHx8IHJlc2V0KVxuICAgICAgKSB7XG4gICAgICAgIGRlbGV0ZSByZW5kZXJlZFtTVFJFQU1dO1xuICAgICAgICByZW5kZXJlZFtLRVlFRF0gPSB7XG4gICAgICAgICAgW0tFWUVEX0NPVU5UXTogMCxcbiAgICAgICAgfTtcbiAgICAgICAgb3V0cHV0LnN0cmVhbXMuYWRkKHN0cmVhbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZHluYW1pY1RvQnVmZmVyKHJlbmRlcmVkLCB0ZW1wbGF0ZXMsIG91dHB1dCwgY2hhbmdlVHJhY2tpbmcpIHtcbiAgICBpZiAodHlwZW9mIHJlbmRlcmVkID09PSBcIm51bWJlclwiKSB7XG4gICAgICBjb25zdCB7IGJ1ZmZlcjogc3RyLCBzdHJlYW1zIH0gPSB0aGlzLnJlY3Vyc2l2ZUNJRFRvU3RyaW5nKFxuICAgICAgICBvdXRwdXQuY29tcG9uZW50cyxcbiAgICAgICAgcmVuZGVyZWQsXG4gICAgICAgIG91dHB1dC5vbmx5Q2lkcyxcbiAgICAgICk7XG4gICAgICBvdXRwdXQuYnVmZmVyICs9IHN0cjtcbiAgICAgIG91dHB1dC5zdHJlYW1zID0gbmV3IFNldChbLi4ub3V0cHV0LnN0cmVhbXMsIC4uLnN0cmVhbXNdKTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHJlbmRlcmVkKSkge1xuICAgICAgdGhpcy50b091dHB1dEJ1ZmZlcihyZW5kZXJlZCwgdGVtcGxhdGVzLCBvdXRwdXQsIGNoYW5nZVRyYWNraW5nLCB7fSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5idWZmZXIgKz0gcmVuZGVyZWQ7XG4gICAgfVxuICB9XG5cbiAgcmVjdXJzaXZlQ0lEVG9TdHJpbmcoY29tcG9uZW50cywgY2lkLCBvbmx5Q2lkcykge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9XG4gICAgICBjb21wb25lbnRzW2NpZF0gfHwgbG9nRXJyb3IoYG5vIGNvbXBvbmVudCBmb3IgQ0lEICR7Y2lkfWAsIGNvbXBvbmVudHMpO1xuICAgIGNvbnN0IGF0dHJzID0geyBbUEhYX0NPTVBPTkVOVF06IGNpZCwgW1BIWF9WSUVXX1JFRl06IHRoaXMudmlld0lkIH07XG4gICAgY29uc3Qgc2tpcCA9IG9ubHlDaWRzICYmICFvbmx5Q2lkcy5oYXMoY2lkKTtcbiAgICAvLyBUd28gb3B0aW1pemF0aW9uIHBhdGhzIGFwcGx5IGhlcmU6XG4gICAgLy9cbiAgICAvLyAgIDEuIFRoZSBvbmx5Q2lkcyBvcHRpbWl6YXRpb24gd29ya3MgYnkgdGhlIHNlcnZlciBkaWZmIHRlbGxpbmcgdXMgb25seSBzcGVjaWZpY1xuICAgIC8vICAgICBjaWQncyBoYXZlIGNoYW5nZWQuIFRoaXMgYWxsb3dzIHVzIHRvIHNraXAgcmVuZGVyaW5nIGFueSBjb21wb25lbnQgdGhhdCBoYXNuJ3QgY2hhbmdlZCxcbiAgICAvLyAgICAgd2hpY2ggdWx0aW1hdGVseSBzZXRzIFBIWF9TS0lQIHJvb3QgYXR0cmlidXRlIGFuZCBhdm9pZHMgcmVuZGVyaW5nIHRoZSBpbm5lckhUTUwuXG4gICAgLy9cbiAgICAvLyAgIDIuIFRoZSByb290IFBIWF9TS0lQIG9wdGltaXphdGlvbiBnZW5lcmFsaXplcyB0byBhbGwgSEVFeCBmdW5jdGlvbiBjb21wb25lbnRzLCBhbmRcbiAgICAvLyAgICAgd29ya3MgaW4gdGhlIHNhbWUgUEhYX1NLSVAgYXR0cmlidXRlIGZhc2hpb24gYXMgMSwgYnV0IHRoZSBuZXdSZW5kZXIgdHJhY2tpbmcgaXMgZG9uZVxuICAgIC8vICAgICBhdCB0aGUgZ2VuZXJhbCBkaWZmIG1lcmdlIGxldmVsLiBJZiB3ZSBtZXJnZSBhIGRpZmYgd2l0aCBuZXcgZHluYW1pY3MsIHdlIG5lY2Vzc2FyaWx5IGhhdmVcbiAgICAvLyAgICAgZXhwZXJpZW5jZWQgYSBjaGFuZ2Ugd2hpY2ggbXVzdCBiZSBhIG5ld1JlbmRlciwgYW5kIHRodXMgd2UgY2FuJ3Qgc2tpcCB0aGUgcmVuZGVyLlxuICAgIC8vXG4gICAgLy8gQm90aCBvcHRpbWl6YXRpb24gZmxvd3MgYXBwbHkgaGVyZS4gbmV3UmVuZGVyIGlzIHNldCBiYXNlZCBvbiB0aGUgb25seUNpZHMgb3B0aW1pemF0aW9uLCBhbmRcbiAgICAvLyB3ZSB0cmFjayBhIGRldGVybWluaXN0aWMgbWFnaWNJZCBiYXNlZCBvbiB0aGUgY2lkLlxuICAgIC8vXG4gICAgLy8gY2hhbmdlVHJhY2tpbmcgaXMgYWJvdXQgdGhlIGVudGlyZSB0cmVlXG4gICAgLy8gbmV3UmVuZGVyIGlzIGFib3V0IHRoZSBjdXJyZW50IHJvb3QgaW4gdGhlIHRyZWVcbiAgICAvL1xuICAgIC8vIEJ5IGRlZmF1bHQgY2hhbmdlVHJhY2tpbmcgaXMgZW5hYmxlZCwgYnV0IHdlIHNwZWNpYWwgY2FzZSB0aGUgZmxvdyB3aGVyZSB0aGUgY2xpZW50IGlzIHBydW5pbmdcbiAgICAvLyBjaWRzIGFuZCB0aGUgc2VydmVyIGFkZHMgdGhlIGNvbXBvbmVudCBiYWNrLiBJbiBzdWNoIGNhc2VzLCB3ZSBleHBsaWNpdGx5IGRpc2FibGUgY2hhbmdlVHJhY2tpbmdcbiAgICAvLyB3aXRoIHJlc2V0UmVuZGVyIGZvciB0aGlzIGNpZCwgdGhlbiByZS1lbmFibGUgaXQgYWZ0ZXIgdGhlIHJlY3Vyc2l2ZSBjYWxsIHRvIHNraXAgdGhlIG9wdGltaXphdGlvblxuICAgIC8vIGZvciB0aGUgZW50aXJlIGNvbXBvbmVudCB0cmVlLlxuICAgIGNvbXBvbmVudC5uZXdSZW5kZXIgPSAhc2tpcDtcbiAgICBjb21wb25lbnQubWFnaWNJZCA9IGBjJHtjaWR9LSR7dGhpcy5wYXJlbnRWaWV3SWQoKX1gO1xuICAgIC8vIGVuYWJsZSBjaGFuZ2UgdHJhY2tpbmcgYXMgbG9uZyBhcyB0aGUgY29tcG9uZW50IGhhc24ndCBiZWVuIHJlc2V0XG4gICAgY29uc3QgY2hhbmdlVHJhY2tpbmcgPSAhY29tcG9uZW50LnJlc2V0O1xuICAgIGNvbnN0IHsgYnVmZmVyOiBodG1sLCBzdHJlYW1zIH0gPSB0aGlzLnJlY3Vyc2l2ZVRvU3RyaW5nKFxuICAgICAgY29tcG9uZW50LFxuICAgICAgY29tcG9uZW50cyxcbiAgICAgIG9ubHlDaWRzLFxuICAgICAgY2hhbmdlVHJhY2tpbmcsXG4gICAgICBhdHRycyxcbiAgICApO1xuICAgIC8vIGRpc2FibGUgcmVzZXQgYWZ0ZXIgd2UndmUgcmVuZGVyZWRcbiAgICBkZWxldGUgY29tcG9uZW50LnJlc2V0O1xuXG4gICAgcmV0dXJuIHsgYnVmZmVyOiBodG1sLCBzdHJlYW1zOiBzdHJlYW1zIH07XG4gIH1cbn1cbiIsICJpbXBvcnQgRE9NIGZyb20gXCIuL2RvbVwiO1xuaW1wb3J0IEFSSUEgZnJvbSBcIi4vYXJpYVwiO1xuXG5jb25zdCBmb2N1c1N0YWNrID0gW107XG5jb25zdCBkZWZhdWx0X3RyYW5zaXRpb25fdGltZSA9IDIwMDtcblxuY29uc3QgSlMgPSB7XG4gIC8vIHByaXZhdGVcbiAgZXhlYyhlLCBldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZGVmYXVsdHMpIHtcbiAgICBjb25zdCBbZGVmYXVsdEtpbmQsIGRlZmF1bHRBcmdzXSA9IGRlZmF1bHRzIHx8IFtcbiAgICAgIG51bGwsXG4gICAgICB7IGNhbGxiYWNrOiBkZWZhdWx0cyAmJiBkZWZhdWx0cy5jYWxsYmFjayB9LFxuICAgIF07XG4gICAgY29uc3QgY29tbWFuZHMgPVxuICAgICAgcGh4RXZlbnQuY2hhckF0KDApID09PSBcIltcIlxuICAgICAgICA/IEpTT04ucGFyc2UocGh4RXZlbnQpXG4gICAgICAgIDogW1tkZWZhdWx0S2luZCwgZGVmYXVsdEFyZ3NdXTtcblxuICAgIGNvbW1hbmRzLmZvckVhY2goKFtraW5kLCBhcmdzXSkgPT4ge1xuICAgICAgaWYgKGtpbmQgPT09IGRlZmF1bHRLaW5kKSB7XG4gICAgICAgIC8vIGFsd2F5cyBwcmVmZXIgdGhlIGFyZ3MsIGJ1dCBrZWVwIGV4aXN0aW5nIGtleXMgZnJvbSB0aGUgZGVmYXVsdEFyZ3NcbiAgICAgICAgYXJncyA9IHsgLi4uZGVmYXVsdEFyZ3MsIC4uLmFyZ3MgfTtcbiAgICAgICAgYXJncy5jYWxsYmFjayA9IGFyZ3MuY2FsbGJhY2sgfHwgZGVmYXVsdEFyZ3MuY2FsbGJhY2s7XG4gICAgICB9XG4gICAgICB0aGlzLmZpbHRlclRvRWxzKHZpZXcubGl2ZVNvY2tldCwgc291cmNlRWwsIGFyZ3MpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgIHRoaXNbYGV4ZWNfJHtraW5kfWBdKGUsIGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwgYXJncyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcblxuICBpc1Zpc2libGUoZWwpIHtcbiAgICByZXR1cm4gISEoXG4gICAgICBlbC5vZmZzZXRXaWR0aCB8fFxuICAgICAgZWwub2Zmc2V0SGVpZ2h0IHx8XG4gICAgICBlbC5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCA+IDBcbiAgICApO1xuICB9LFxuXG4gIC8vIHJldHVybnMgdHJ1ZSBpZiBhbnkgcGFydCBvZiB0aGUgZWxlbWVudCBpcyBpbnNpZGUgdGhlIHZpZXdwb3J0XG4gIGlzSW5WaWV3cG9ydChlbCkge1xuICAgIGNvbnN0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCB3aW5kb3dIZWlnaHQgPVxuICAgICAgd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgY29uc3Qgd2luZG93V2lkdGggPVxuICAgICAgd2luZG93LmlubmVyV2lkdGggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIHJlY3QucmlnaHQgPiAwICYmXG4gICAgICByZWN0LmJvdHRvbSA+IDAgJiZcbiAgICAgIHJlY3QubGVmdCA8IHdpbmRvd1dpZHRoICYmXG4gICAgICByZWN0LnRvcCA8IHdpbmRvd0hlaWdodFxuICAgICk7XG4gIH0sXG5cbiAgLy8gcHJpdmF0ZVxuXG4gIC8vIGNvbW1hbmRzXG5cbiAgZXhlY19leGVjKGUsIGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwgeyBhdHRyLCB0byB9KSB7XG4gICAgY29uc3QgZW5jb2RlZEpTID0gZWwuZ2V0QXR0cmlidXRlKGF0dHIpO1xuICAgIGlmICghZW5jb2RlZEpTKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7YXR0cn0gdG8gY29udGFpbiBKUyBjb21tYW5kIG9uIFwiJHt0b31cImApO1xuICAgIH1cbiAgICB2aWV3LmxpdmVTb2NrZXQuZXhlY0pTKGVsLCBlbmNvZGVkSlMsIGV2ZW50VHlwZSk7XG4gIH0sXG5cbiAgZXhlY19kaXNwYXRjaChcbiAgICBlLFxuICAgIGV2ZW50VHlwZSxcbiAgICBwaHhFdmVudCxcbiAgICB2aWV3LFxuICAgIHNvdXJjZUVsLFxuICAgIGVsLFxuICAgIHsgZXZlbnQsIGRldGFpbCwgYnViYmxlcywgYmxvY2tpbmcgfSxcbiAgKSB7XG4gICAgZGV0YWlsID0gZGV0YWlsIHx8IHt9O1xuICAgIGRldGFpbC5kaXNwYXRjaGVyID0gc291cmNlRWw7XG4gICAgaWYgKGJsb2NraW5nKSB7XG4gICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIF9yZWplY3QpID0+IHtcbiAgICAgICAgZGV0YWlsLmRvbmUgPSByZXNvbHZlO1xuICAgICAgfSk7XG4gICAgICB2aWV3LmxpdmVTb2NrZXQuYXN5bmNUcmFuc2l0aW9uKHByb21pc2UpO1xuICAgIH1cbiAgICBET00uZGlzcGF0Y2hFdmVudChlbCwgZXZlbnQsIHsgZGV0YWlsLCBidWJibGVzIH0pO1xuICB9LFxuXG4gIGV4ZWNfcHVzaChlLCBldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIGFyZ3MpIHtcbiAgICBjb25zdCB7XG4gICAgICBldmVudCxcbiAgICAgIGRhdGEsXG4gICAgICB0YXJnZXQsXG4gICAgICBwYWdlX2xvYWRpbmcsXG4gICAgICBsb2FkaW5nLFxuICAgICAgdmFsdWUsXG4gICAgICBkaXNwYXRjaGVyLFxuICAgICAgY2FsbGJhY2ssXG4gICAgfSA9IGFyZ3M7XG4gICAgY29uc3QgcHVzaE9wdHMgPSB7XG4gICAgICBsb2FkaW5nLFxuICAgICAgdmFsdWUsXG4gICAgICB0YXJnZXQsXG4gICAgICBwYWdlX2xvYWRpbmc6ICEhcGFnZV9sb2FkaW5nLFxuICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICB9O1xuICAgIGNvbnN0IHRhcmdldFNyYyA9XG4gICAgICBldmVudFR5cGUgPT09IFwiY2hhbmdlXCIgJiYgZGlzcGF0Y2hlciA/IGRpc3BhdGNoZXIgOiBzb3VyY2VFbDtcbiAgICBjb25zdCBwaHhUYXJnZXQgPVxuICAgICAgdGFyZ2V0IHx8IHRhcmdldFNyYy5nZXRBdHRyaWJ1dGUodmlldy5iaW5kaW5nKFwidGFyZ2V0XCIpKSB8fCB0YXJnZXRTcmM7XG4gICAgY29uc3QgaGFuZGxlciA9ICh0YXJnZXRWaWV3LCB0YXJnZXRDdHgpID0+IHtcbiAgICAgIGlmICghdGFyZ2V0Vmlldy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudFR5cGUgPT09IFwiY2hhbmdlXCIpIHtcbiAgICAgICAgbGV0IHsgbmV3Q2lkLCBfdGFyZ2V0IH0gPSBhcmdzO1xuICAgICAgICBfdGFyZ2V0ID1cbiAgICAgICAgICBfdGFyZ2V0IHx8IChET00uaXNGb3JtSW5wdXQoc291cmNlRWwpID8gc291cmNlRWwubmFtZSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChfdGFyZ2V0KSB7XG4gICAgICAgICAgcHVzaE9wdHMuX3RhcmdldCA9IF90YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0Vmlldy5wdXNoSW5wdXQoXG4gICAgICAgICAgc291cmNlRWwsXG4gICAgICAgICAgdGFyZ2V0Q3R4LFxuICAgICAgICAgIG5ld0NpZCxcbiAgICAgICAgICBldmVudCB8fCBwaHhFdmVudCxcbiAgICAgICAgICBwdXNoT3B0cyxcbiAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSBcInN1Ym1pdFwiKSB7XG4gICAgICAgIGNvbnN0IHsgc3VibWl0dGVyIH0gPSBhcmdzO1xuICAgICAgICB0YXJnZXRWaWV3LnN1Ym1pdEZvcm0oXG4gICAgICAgICAgc291cmNlRWwsXG4gICAgICAgICAgdGFyZ2V0Q3R4LFxuICAgICAgICAgIGV2ZW50IHx8IHBoeEV2ZW50LFxuICAgICAgICAgIHN1Ym1pdHRlcixcbiAgICAgICAgICBwdXNoT3B0cyxcbiAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFZpZXcucHVzaEV2ZW50KFxuICAgICAgICAgIGV2ZW50VHlwZSxcbiAgICAgICAgICBzb3VyY2VFbCxcbiAgICAgICAgICB0YXJnZXRDdHgsXG4gICAgICAgICAgZXZlbnQgfHwgcGh4RXZlbnQsXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBwdXNoT3B0cyxcbiAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIC8vIGluIGNhc2Ugb2YgZm9ybVJlY292ZXJ5LCB0YXJnZXRWaWV3IGFuZCB0YXJnZXRDdHggYXJlIHBhc3NlZCBhcyBhcmd1bWVudFxuICAgIC8vIGFzIHRoZXkgYXJlIGxvb2tlZCB1cCBpbiBhIHRlbXBsYXRlIGVsZW1lbnQsIG5vdCB0aGUgcmVhbCBET01cbiAgICBpZiAoYXJncy50YXJnZXRWaWV3ICYmIGFyZ3MudGFyZ2V0Q3R4KSB7XG4gICAgICBoYW5kbGVyKGFyZ3MudGFyZ2V0VmlldywgYXJncy50YXJnZXRDdHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2aWV3LndpdGhpblRhcmdldHMocGh4VGFyZ2V0LCBoYW5kbGVyKTtcbiAgICB9XG4gIH0sXG5cbiAgZXhlY19uYXZpZ2F0ZShlLCBldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHsgaHJlZiwgcmVwbGFjZSB9KSB7XG4gICAgdmlldy5saXZlU29ja2V0Lmhpc3RvcnlSZWRpcmVjdChcbiAgICAgIGUsXG4gICAgICBocmVmLFxuICAgICAgcmVwbGFjZSA/IFwicmVwbGFjZVwiIDogXCJwdXNoXCIsXG4gICAgICBudWxsLFxuICAgICAgc291cmNlRWwsXG4gICAgKTtcbiAgfSxcblxuICBleGVjX3BhdGNoKGUsIGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwgeyBocmVmLCByZXBsYWNlIH0pIHtcbiAgICB2aWV3LmxpdmVTb2NrZXQucHVzaEhpc3RvcnlQYXRjaChcbiAgICAgIGUsXG4gICAgICBocmVmLFxuICAgICAgcmVwbGFjZSA/IFwicmVwbGFjZVwiIDogXCJwdXNoXCIsXG4gICAgICBzb3VyY2VFbCxcbiAgICApO1xuICB9LFxuXG4gIGV4ZWNfZm9jdXMoZSwgZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsKSB7XG4gICAgQVJJQS5hdHRlbXB0Rm9jdXMoZWwpO1xuICAgIC8vIGluIGNhc2UgdGhlIEpTLmZvY3VzIGNvbW1hbmQgaXMgaW4gYSBKUy5zaG93L2hpZGUvdG9nZ2xlIGNoYWluLCBmb3Igc2hvdyB3ZSBuZWVkXG4gICAgLy8gdG8gd2FpdCBmb3IgSlMuc2hvdyB0byBoYXZlIHVwZGF0ZWQgdGhlIGVsZW1lbnQncyBkaXNwbGF5IHByb3BlcnR5IChzZWUgZXhlY190b2dnbGUpXG4gICAgLy8gYnV0IHRoYXQgcnVuIGluIG5lc3RlZCBhbmltYXRpb24gZnJhbWVzLCB0aGVyZWZvcmUgd2UgbmVlZCB0byB1c2UgdGhlbSBoZXJlIGFzIHdlbGxcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gQVJJQS5hdHRlbXB0Rm9jdXMoZWwpKTtcbiAgICB9KTtcbiAgfSxcblxuICBleGVjX2ZvY3VzX2ZpcnN0KGUsIGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCkge1xuICAgIEFSSUEuZm9jdXNGaXJzdEludGVyYWN0aXZlKGVsKSB8fCBBUklBLmZvY3VzRmlyc3QoZWwpO1xuICAgIC8vIGlmIHlvdSB3b25kZXIgYWJvdXQgdGhlIG5lc3RlZCBhbmltYXRpb24gZnJhbWVzLCBzZWUgZXhlY19mb2N1c1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShcbiAgICAgICAgKCkgPT4gQVJJQS5mb2N1c0ZpcnN0SW50ZXJhY3RpdmUoZWwpIHx8IEFSSUEuZm9jdXNGaXJzdChlbCksXG4gICAgICApO1xuICAgIH0pO1xuICB9LFxuXG4gIGV4ZWNfcHVzaF9mb2N1cyhlLCBldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwpIHtcbiAgICBmb2N1c1N0YWNrLnB1c2goZWwgfHwgc291cmNlRWwpO1xuICB9LFxuXG4gIGV4ZWNfcG9wX2ZvY3VzKF9lLCBfZXZlbnRUeXBlLCBfcGh4RXZlbnQsIF92aWV3LCBfc291cmNlRWwsIF9lbCkge1xuICAgIGNvbnN0IGVsID0gZm9jdXNTdGFjay5wb3AoKTtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLmZvY3VzKCk7XG4gICAgICAvLyBpZiB5b3Ugd29uZGVyIGFib3V0IHRoZSBuZXN0ZWQgYW5pbWF0aW9uIGZyYW1lcywgc2VlIGV4ZWNfZm9jdXNcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IGVsLmZvY3VzKCkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIGV4ZWNfYWRkX2NsYXNzKFxuICAgIGUsXG4gICAgZXZlbnRUeXBlLFxuICAgIHBoeEV2ZW50LFxuICAgIHZpZXcsXG4gICAgc291cmNlRWwsXG4gICAgZWwsXG4gICAgeyBuYW1lcywgdHJhbnNpdGlvbiwgdGltZSwgYmxvY2tpbmcgfSxcbiAgKSB7XG4gICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIG5hbWVzLCBbXSwgdHJhbnNpdGlvbiwgdGltZSwgdmlldywgYmxvY2tpbmcpO1xuICB9LFxuXG4gIGV4ZWNfcmVtb3ZlX2NsYXNzKFxuICAgIGUsXG4gICAgZXZlbnRUeXBlLFxuICAgIHBoeEV2ZW50LFxuICAgIHZpZXcsXG4gICAgc291cmNlRWwsXG4gICAgZWwsXG4gICAgeyBuYW1lcywgdHJhbnNpdGlvbiwgdGltZSwgYmxvY2tpbmcgfSxcbiAgKSB7XG4gICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIFtdLCBuYW1lcywgdHJhbnNpdGlvbiwgdGltZSwgdmlldywgYmxvY2tpbmcpO1xuICB9LFxuXG4gIGV4ZWNfdG9nZ2xlX2NsYXNzKFxuICAgIGUsXG4gICAgZXZlbnRUeXBlLFxuICAgIHBoeEV2ZW50LFxuICAgIHZpZXcsXG4gICAgc291cmNlRWwsXG4gICAgZWwsXG4gICAgeyBuYW1lcywgdHJhbnNpdGlvbiwgdGltZSwgYmxvY2tpbmcgfSxcbiAgKSB7XG4gICAgdGhpcy50b2dnbGVDbGFzc2VzKGVsLCBuYW1lcywgdHJhbnNpdGlvbiwgdGltZSwgdmlldywgYmxvY2tpbmcpO1xuICB9LFxuXG4gIGV4ZWNfdG9nZ2xlX2F0dHIoXG4gICAgZSxcbiAgICBldmVudFR5cGUsXG4gICAgcGh4RXZlbnQsXG4gICAgdmlldyxcbiAgICBzb3VyY2VFbCxcbiAgICBlbCxcbiAgICB7IGF0dHI6IFthdHRyLCB2YWwxLCB2YWwyXSB9LFxuICApIHtcbiAgICB0aGlzLnRvZ2dsZUF0dHIoZWwsIGF0dHIsIHZhbDEsIHZhbDIpO1xuICB9LFxuXG4gIGV4ZWNfaWdub3JlX2F0dHJzKGUsIGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwgeyBhdHRycyB9KSB7XG4gICAgdGhpcy5pZ25vcmVBdHRycyhlbCwgYXR0cnMpO1xuICB9LFxuXG4gIGV4ZWNfdHJhbnNpdGlvbihcbiAgICBlLFxuICAgIGV2ZW50VHlwZSxcbiAgICBwaHhFdmVudCxcbiAgICB2aWV3LFxuICAgIHNvdXJjZUVsLFxuICAgIGVsLFxuICAgIHsgdGltZSwgdHJhbnNpdGlvbiwgYmxvY2tpbmcgfSxcbiAgKSB7XG4gICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIFtdLCBbXSwgdHJhbnNpdGlvbiwgdGltZSwgdmlldywgYmxvY2tpbmcpO1xuICB9LFxuXG4gIGV4ZWNfdG9nZ2xlKFxuICAgIGUsXG4gICAgZXZlbnRUeXBlLFxuICAgIHBoeEV2ZW50LFxuICAgIHZpZXcsXG4gICAgc291cmNlRWwsXG4gICAgZWwsXG4gICAgeyBkaXNwbGF5LCBpbnMsIG91dHMsIHRpbWUsIGJsb2NraW5nIH0sXG4gICkge1xuICAgIHRoaXMudG9nZ2xlKGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIGlucywgb3V0cywgdGltZSwgYmxvY2tpbmcpO1xuICB9LFxuXG4gIGV4ZWNfc2hvdyhcbiAgICBlLFxuICAgIGV2ZW50VHlwZSxcbiAgICBwaHhFdmVudCxcbiAgICB2aWV3LFxuICAgIHNvdXJjZUVsLFxuICAgIGVsLFxuICAgIHsgZGlzcGxheSwgdHJhbnNpdGlvbiwgdGltZSwgYmxvY2tpbmcgfSxcbiAgKSB7XG4gICAgdGhpcy5zaG93KGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIHRyYW5zaXRpb24sIHRpbWUsIGJsb2NraW5nKTtcbiAgfSxcblxuICBleGVjX2hpZGUoXG4gICAgZSxcbiAgICBldmVudFR5cGUsXG4gICAgcGh4RXZlbnQsXG4gICAgdmlldyxcbiAgICBzb3VyY2VFbCxcbiAgICBlbCxcbiAgICB7IGRpc3BsYXksIHRyYW5zaXRpb24sIHRpbWUsIGJsb2NraW5nIH0sXG4gICkge1xuICAgIHRoaXMuaGlkZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lLCBibG9ja2luZyk7XG4gIH0sXG5cbiAgZXhlY19zZXRfYXR0cihcbiAgICBlLFxuICAgIGV2ZW50VHlwZSxcbiAgICBwaHhFdmVudCxcbiAgICB2aWV3LFxuICAgIHNvdXJjZUVsLFxuICAgIGVsLFxuICAgIHsgYXR0cjogW2F0dHIsIHZhbF0gfSxcbiAgKSB7XG4gICAgdGhpcy5zZXRPclJlbW92ZUF0dHJzKGVsLCBbW2F0dHIsIHZhbF1dLCBbXSk7XG4gIH0sXG5cbiAgZXhlY19yZW1vdmVfYXR0cihlLCBldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHsgYXR0ciB9KSB7XG4gICAgdGhpcy5zZXRPclJlbW92ZUF0dHJzKGVsLCBbXSwgW2F0dHJdKTtcbiAgfSxcblxuICBpZ25vcmVBdHRycyhlbCwgYXR0cnMpIHtcbiAgICBET00ucHV0UHJpdmF0ZShlbCwgXCJKUzppZ25vcmVfYXR0cnNcIiwge1xuICAgICAgYXBwbHk6IChmcm9tRWwsIHRvRWwpID0+IHtcbiAgICAgICAgbGV0IGZyb21BdHRyaWJ1dGVzID0gQXJyYXkuZnJvbShmcm9tRWwuYXR0cmlidXRlcyk7XG4gICAgICAgIGxldCBmcm9tQXR0cmlidXRlTmFtZXMgPSBmcm9tQXR0cmlidXRlcy5tYXAoKGF0dHIpID0+IGF0dHIubmFtZSk7XG4gICAgICAgIEFycmF5LmZyb20odG9FbC5hdHRyaWJ1dGVzKVxuICAgICAgICAgIC5maWx0ZXIoKGF0dHIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAhZnJvbUF0dHJpYnV0ZU5hbWVzLmluY2x1ZGVzKGF0dHIubmFtZSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgICAgICAgICAgaWYgKERPTS5hdHRyaWJ1dGVJZ25vcmVkKGF0dHIsIGF0dHJzKSkge1xuICAgICAgICAgICAgICB0b0VsLnJlbW92ZUF0dHJpYnV0ZShhdHRyLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICBmcm9tQXR0cmlidXRlcy5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgICAgICAgaWYgKERPTS5hdHRyaWJ1dGVJZ25vcmVkKGF0dHIsIGF0dHJzKSkge1xuICAgICAgICAgICAgdG9FbC5zZXRBdHRyaWJ1dGUoYXR0ci5uYW1lLCBhdHRyLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfSxcblxuICBvbkJlZm9yZUVsVXBkYXRlZChmcm9tRWwsIHRvRWwpIHtcbiAgICBjb25zdCBpZ25vcmVBdHRycyA9IERPTS5wcml2YXRlKGZyb21FbCwgXCJKUzppZ25vcmVfYXR0cnNcIik7XG4gICAgaWYgKGlnbm9yZUF0dHJzKSB7XG4gICAgICBpZ25vcmVBdHRycy5hcHBseShmcm9tRWwsIHRvRWwpO1xuICAgIH1cbiAgfSxcblxuICAvLyB1dGlscyBmb3IgY29tbWFuZHNcblxuICBzaG93KGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIHRyYW5zaXRpb24sIHRpbWUsIGJsb2NraW5nKSB7XG4gICAgaWYgKCF0aGlzLmlzVmlzaWJsZShlbCkpIHtcbiAgICAgIHRoaXMudG9nZ2xlKFxuICAgICAgICBldmVudFR5cGUsXG4gICAgICAgIHZpZXcsXG4gICAgICAgIGVsLFxuICAgICAgICBkaXNwbGF5LFxuICAgICAgICB0cmFuc2l0aW9uLFxuICAgICAgICBudWxsLFxuICAgICAgICB0aW1lLFxuICAgICAgICBibG9ja2luZyxcbiAgICAgICk7XG4gICAgfVxuICB9LFxuXG4gIGhpZGUoZXZlbnRUeXBlLCB2aWV3LCBlbCwgZGlzcGxheSwgdHJhbnNpdGlvbiwgdGltZSwgYmxvY2tpbmcpIHtcbiAgICBpZiAodGhpcy5pc1Zpc2libGUoZWwpKSB7XG4gICAgICB0aGlzLnRvZ2dsZShcbiAgICAgICAgZXZlbnRUeXBlLFxuICAgICAgICB2aWV3LFxuICAgICAgICBlbCxcbiAgICAgICAgZGlzcGxheSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgdHJhbnNpdGlvbixcbiAgICAgICAgdGltZSxcbiAgICAgICAgYmxvY2tpbmcsXG4gICAgICApO1xuICAgIH1cbiAgfSxcblxuICB0b2dnbGUoZXZlbnRUeXBlLCB2aWV3LCBlbCwgZGlzcGxheSwgaW5zLCBvdXRzLCB0aW1lLCBibG9ja2luZykge1xuICAgIHRpbWUgPSB0aW1lIHx8IGRlZmF1bHRfdHJhbnNpdGlvbl90aW1lO1xuICAgIGNvbnN0IFtpbkNsYXNzZXMsIGluU3RhcnRDbGFzc2VzLCBpbkVuZENsYXNzZXNdID0gaW5zIHx8IFtbXSwgW10sIFtdXTtcbiAgICBjb25zdCBbb3V0Q2xhc3Nlcywgb3V0U3RhcnRDbGFzc2VzLCBvdXRFbmRDbGFzc2VzXSA9IG91dHMgfHwgW1tdLCBbXSwgW11dO1xuICAgIGlmIChpbkNsYXNzZXMubGVuZ3RoID4gMCB8fCBvdXRDbGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0aGlzLmlzVmlzaWJsZShlbCkpIHtcbiAgICAgICAgY29uc3Qgb25TdGFydCA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhcbiAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgb3V0U3RhcnRDbGFzc2VzLFxuICAgICAgICAgICAgaW5DbGFzc2VzLmNvbmNhdChpblN0YXJ0Q2xhc3NlcykuY29uY2F0KGluRW5kQ2xhc3NlcyksXG4gICAgICAgICAgKTtcbiAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBvdXRDbGFzc2VzLCBbXSk7XG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+XG4gICAgICAgICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBvdXRFbmRDbGFzc2VzLCBvdXRTdGFydENsYXNzZXMpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25FbmQgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIFtdLCBvdXRDbGFzc2VzLmNvbmNhdChvdXRFbmRDbGFzc2VzKSk7XG4gICAgICAgICAgRE9NLnB1dFN0aWNreShcbiAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgXCJ0b2dnbGVcIixcbiAgICAgICAgICAgIChjdXJyZW50RWwpID0+IChjdXJyZW50RWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiKSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicGh4OmhpZGUtZW5kXCIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6aGlkZS1zdGFydFwiKSk7XG4gICAgICAgIGlmIChibG9ja2luZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBvblN0YXJ0KCk7XG4gICAgICAgICAgc2V0VGltZW91dChvbkVuZCwgdGltZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmlldy50cmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRW5kKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gXCJyZW1vdmVcIikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvblN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKFxuICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICBpblN0YXJ0Q2xhc3NlcyxcbiAgICAgICAgICAgIG91dENsYXNzZXMuY29uY2F0KG91dFN0YXJ0Q2xhc3NlcykuY29uY2F0KG91dEVuZENsYXNzZXMpLFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3Qgc3RpY2t5RGlzcGxheSA9IGRpc3BsYXkgfHwgdGhpcy5kZWZhdWx0RGlzcGxheShlbCk7XG4gICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAvLyBmaXJzdCBhZGQgdGhlIHN0YXJ0aW5nICsgYWN0aXZlIGNsYXNzLCBUSEVOIG1ha2UgdGhlIGVsZW1lbnQgdmlzaWJsZVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGlmIHdlIHRvZ2dsZWQgdGhlIHZpc2liaWxpdHkgZWFybGllciBjc3MgYW5pbWF0aW9uc1xuICAgICAgICAgICAgLy8gd291bGQgZmxpY2tlciwgYXMgdGhlIGVsZW1lbnQgYmVjb21lcyB2aXNpYmxlIGJlZm9yZSB0aGUgYWN0aXZlIGFuaW1hdGlvblxuICAgICAgICAgICAgLy8gY2xhc3MgaXMgc2V0IChzZWUgaHR0cHM6Ly9naXRodWIuY29tL3Bob2VuaXhmcmFtZXdvcmsvcGhvZW5peF9saXZlX3ZpZXcvaXNzdWVzLzM0NTYpXG4gICAgICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgaW5DbGFzc2VzLCBbXSk7XG4gICAgICAgICAgICAvLyBhZGRPclJlbW92ZUNsYXNzZXMgdXNlcyBhIHJlcXVlc3RBbmltYXRpb25GcmFtZSBpdHNlbGYsIHRoZXJlZm9yZSB3ZSBuZWVkIHRvIG1vdmUgdGhlIHB1dFN0aWNreVxuICAgICAgICAgICAgLy8gaW50byB0aGUgbmV4dCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuLi5cbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICBET00ucHV0U3RpY2t5KFxuICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgIFwidG9nZ2xlXCIsXG4gICAgICAgICAgICAgICAgKGN1cnJlbnRFbCkgPT4gKGN1cnJlbnRFbC5zdHlsZS5kaXNwbGF5ID0gc3RpY2t5RGlzcGxheSksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBpbkVuZENsYXNzZXMsIGluU3RhcnRDbGFzc2VzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvbkVuZCA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgW10sIGluQ2xhc3Nlcy5jb25jYXQoaW5FbmRDbGFzc2VzKSk7XG4gICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6c2hvdy1lbmRcIikpO1xuICAgICAgICB9O1xuICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpzaG93LXN0YXJ0XCIpKTtcbiAgICAgICAgaWYgKGJsb2NraW5nID09PSBmYWxzZSkge1xuICAgICAgICAgIG9uU3RhcnQoKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KG9uRW5kLCB0aW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2aWV3LnRyYW5zaXRpb24odGltZSwgb25TdGFydCwgb25FbmQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmlzVmlzaWJsZShlbCkpIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6aGlkZS1zdGFydFwiKSk7XG4gICAgICAgICAgRE9NLnB1dFN0aWNreShcbiAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgXCJ0b2dnbGVcIixcbiAgICAgICAgICAgIChjdXJyZW50RWwpID0+IChjdXJyZW50RWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiKSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicGh4OmhpZGUtZW5kXCIpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpzaG93LXN0YXJ0XCIpKTtcbiAgICAgICAgICBjb25zdCBzdGlja3lEaXNwbGF5ID0gZGlzcGxheSB8fCB0aGlzLmRlZmF1bHREaXNwbGF5KGVsKTtcbiAgICAgICAgICBET00ucHV0U3RpY2t5KFxuICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICBcInRvZ2dsZVwiLFxuICAgICAgICAgICAgKGN1cnJlbnRFbCkgPT4gKGN1cnJlbnRFbC5zdHlsZS5kaXNwbGF5ID0gc3RpY2t5RGlzcGxheSksXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpzaG93LWVuZFwiKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB0b2dnbGVDbGFzc2VzKGVsLCBjbGFzc2VzLCB0cmFuc2l0aW9uLCB0aW1lLCB2aWV3LCBibG9ja2luZykge1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgY29uc3QgW3ByZXZBZGRzLCBwcmV2UmVtb3Zlc10gPSBET00uZ2V0U3RpY2t5KGVsLCBcImNsYXNzZXNcIiwgW1tdLCBbXV0pO1xuICAgICAgY29uc3QgbmV3QWRkcyA9IGNsYXNzZXMuZmlsdGVyKFxuICAgICAgICAobmFtZSkgPT4gcHJldkFkZHMuaW5kZXhPZihuYW1lKSA8IDAgJiYgIWVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKSxcbiAgICAgICk7XG4gICAgICBjb25zdCBuZXdSZW1vdmVzID0gY2xhc3Nlcy5maWx0ZXIoXG4gICAgICAgIChuYW1lKSA9PiBwcmV2UmVtb3Zlcy5pbmRleE9mKG5hbWUpIDwgMCAmJiBlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSksXG4gICAgICApO1xuICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoXG4gICAgICAgIGVsLFxuICAgICAgICBuZXdBZGRzLFxuICAgICAgICBuZXdSZW1vdmVzLFxuICAgICAgICB0cmFuc2l0aW9uLFxuICAgICAgICB0aW1lLFxuICAgICAgICB2aWV3LFxuICAgICAgICBibG9ja2luZyxcbiAgICAgICk7XG4gICAgfSk7XG4gIH0sXG5cbiAgdG9nZ2xlQXR0cihlbCwgYXR0ciwgdmFsMSwgdmFsMikge1xuICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoYXR0cikpIHtcbiAgICAgIGlmICh2YWwyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gdG9nZ2xlIGJldHdlZW4gdmFsMSBhbmQgdmFsMlxuICAgICAgICBpZiAoZWwuZ2V0QXR0cmlidXRlKGF0dHIpID09PSB2YWwxKSB7XG4gICAgICAgICAgdGhpcy5zZXRPclJlbW92ZUF0dHJzKGVsLCBbW2F0dHIsIHZhbDJdXSwgW10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2V0T3JSZW1vdmVBdHRycyhlbCwgW1thdHRyLCB2YWwxXV0sIFtdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVtb3ZlIGF0dHJcbiAgICAgICAgdGhpcy5zZXRPclJlbW92ZUF0dHJzKGVsLCBbXSwgW2F0dHJdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRPclJlbW92ZUF0dHJzKGVsLCBbW2F0dHIsIHZhbDFdXSwgW10pO1xuICAgIH1cbiAgfSxcblxuICBhZGRPclJlbW92ZUNsYXNzZXMoZWwsIGFkZHMsIHJlbW92ZXMsIHRyYW5zaXRpb24sIHRpbWUsIHZpZXcsIGJsb2NraW5nKSB7XG4gICAgdGltZSA9IHRpbWUgfHwgZGVmYXVsdF90cmFuc2l0aW9uX3RpbWU7XG4gICAgY29uc3QgW3RyYW5zaXRpb25SdW4sIHRyYW5zaXRpb25TdGFydCwgdHJhbnNpdGlvbkVuZF0gPSB0cmFuc2l0aW9uIHx8IFtcbiAgICAgIFtdLFxuICAgICAgW10sXG4gICAgICBbXSxcbiAgICBdO1xuICAgIGlmICh0cmFuc2l0aW9uUnVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IG9uU3RhcnQgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKFxuICAgICAgICAgIGVsLFxuICAgICAgICAgIHRyYW5zaXRpb25TdGFydCxcbiAgICAgICAgICBbXS5jb25jYXQodHJhbnNpdGlvblJ1bikuY29uY2F0KHRyYW5zaXRpb25FbmQpLFxuICAgICAgICApO1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgdHJhbnNpdGlvblJ1biwgW10pO1xuICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT5cbiAgICAgICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCB0cmFuc2l0aW9uRW5kLCB0cmFuc2l0aW9uU3RhcnQpLFxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG9uRG9uZSA9ICgpID0+XG4gICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKFxuICAgICAgICAgIGVsLFxuICAgICAgICAgIGFkZHMuY29uY2F0KHRyYW5zaXRpb25FbmQpLFxuICAgICAgICAgIHJlbW92ZXMuY29uY2F0KHRyYW5zaXRpb25SdW4pLmNvbmNhdCh0cmFuc2l0aW9uU3RhcnQpLFxuICAgICAgICApO1xuICAgICAgaWYgKGJsb2NraW5nID09PSBmYWxzZSkge1xuICAgICAgICBvblN0YXJ0KCk7XG4gICAgICAgIHNldFRpbWVvdXQob25Eb25lLCB0aW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZpZXcudHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgY29uc3QgW3ByZXZBZGRzLCBwcmV2UmVtb3Zlc10gPSBET00uZ2V0U3RpY2t5KGVsLCBcImNsYXNzZXNcIiwgW1tdLCBbXV0pO1xuICAgICAgY29uc3Qga2VlcEFkZHMgPSBhZGRzLmZpbHRlcihcbiAgICAgICAgKG5hbWUpID0+IHByZXZBZGRzLmluZGV4T2YobmFtZSkgPCAwICYmICFlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSksXG4gICAgICApO1xuICAgICAgY29uc3Qga2VlcFJlbW92ZXMgPSByZW1vdmVzLmZpbHRlcihcbiAgICAgICAgKG5hbWUpID0+IHByZXZSZW1vdmVzLmluZGV4T2YobmFtZSkgPCAwICYmIGVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKSxcbiAgICAgICk7XG4gICAgICBjb25zdCBuZXdBZGRzID0gcHJldkFkZHNcbiAgICAgICAgLmZpbHRlcigobmFtZSkgPT4gcmVtb3Zlcy5pbmRleE9mKG5hbWUpIDwgMClcbiAgICAgICAgLmNvbmNhdChrZWVwQWRkcyk7XG4gICAgICBjb25zdCBuZXdSZW1vdmVzID0gcHJldlJlbW92ZXNcbiAgICAgICAgLmZpbHRlcigobmFtZSkgPT4gYWRkcy5pbmRleE9mKG5hbWUpIDwgMClcbiAgICAgICAgLmNvbmNhdChrZWVwUmVtb3Zlcyk7XG5cbiAgICAgIERPTS5wdXRTdGlja3koZWwsIFwiY2xhc3Nlc1wiLCAoY3VycmVudEVsKSA9PiB7XG4gICAgICAgIGN1cnJlbnRFbC5jbGFzc0xpc3QucmVtb3ZlKC4uLm5ld1JlbW92ZXMpO1xuICAgICAgICBjdXJyZW50RWwuY2xhc3NMaXN0LmFkZCguLi5uZXdBZGRzKTtcbiAgICAgICAgcmV0dXJuIFtuZXdBZGRzLCBuZXdSZW1vdmVzXTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIHNldE9yUmVtb3ZlQXR0cnMoZWwsIHNldHMsIHJlbW92ZXMpIHtcbiAgICBjb25zdCBbcHJldlNldHMsIHByZXZSZW1vdmVzXSA9IERPTS5nZXRTdGlja3koZWwsIFwiYXR0cnNcIiwgW1tdLCBbXV0pO1xuXG4gICAgY29uc3QgYWx0ZXJlZEF0dHJzID0gc2V0cy5tYXAoKFthdHRyLCBfdmFsXSkgPT4gYXR0cikuY29uY2F0KHJlbW92ZXMpO1xuICAgIGNvbnN0IG5ld1NldHMgPSBwcmV2U2V0c1xuICAgICAgLmZpbHRlcigoW2F0dHIsIF92YWxdKSA9PiAhYWx0ZXJlZEF0dHJzLmluY2x1ZGVzKGF0dHIpKVxuICAgICAgLmNvbmNhdChzZXRzKTtcbiAgICBjb25zdCBuZXdSZW1vdmVzID0gcHJldlJlbW92ZXNcbiAgICAgIC5maWx0ZXIoKGF0dHIpID0+ICFhbHRlcmVkQXR0cnMuaW5jbHVkZXMoYXR0cikpXG4gICAgICAuY29uY2F0KHJlbW92ZXMpO1xuXG4gICAgRE9NLnB1dFN0aWNreShlbCwgXCJhdHRyc1wiLCAoY3VycmVudEVsKSA9PiB7XG4gICAgICBuZXdSZW1vdmVzLmZvckVhY2goKGF0dHIpID0+IGN1cnJlbnRFbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cikpO1xuICAgICAgbmV3U2V0cy5mb3JFYWNoKChbYXR0ciwgdmFsXSkgPT4gY3VycmVudEVsLnNldEF0dHJpYnV0ZShhdHRyLCB2YWwpKTtcbiAgICAgIHJldHVybiBbbmV3U2V0cywgbmV3UmVtb3Zlc107XG4gICAgfSk7XG4gIH0sXG5cbiAgaGFzQWxsQ2xhc3NlcyhlbCwgY2xhc3Nlcykge1xuICAgIHJldHVybiBjbGFzc2VzLmV2ZXJ5KChuYW1lKSA9PiBlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSkpO1xuICB9LFxuXG4gIGlzVG9nZ2xlZE91dChlbCwgb3V0Q2xhc3Nlcykge1xuICAgIHJldHVybiAhdGhpcy5pc1Zpc2libGUoZWwpIHx8IHRoaXMuaGFzQWxsQ2xhc3NlcyhlbCwgb3V0Q2xhc3Nlcyk7XG4gIH0sXG5cbiAgZmlsdGVyVG9FbHMobGl2ZVNvY2tldCwgc291cmNlRWwsIHsgdG8gfSkge1xuICAgIGNvbnN0IGRlZmF1bHRRdWVyeSA9ICgpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodG8pO1xuICAgICAgfSBlbHNlIGlmICh0by5jbG9zZXN0KSB7XG4gICAgICAgIGNvbnN0IHRvRWwgPSBzb3VyY2VFbC5jbG9zZXN0KHRvLmNsb3Nlc3QpO1xuICAgICAgICByZXR1cm4gdG9FbCA/IFt0b0VsXSA6IFtdO1xuICAgICAgfSBlbHNlIGlmICh0by5pbm5lcikge1xuICAgICAgICByZXR1cm4gc291cmNlRWwucXVlcnlTZWxlY3RvckFsbCh0by5pbm5lcik7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gdG9cbiAgICAgID8gbGl2ZVNvY2tldC5qc1F1ZXJ5U2VsZWN0b3JBbGwoc291cmNlRWwsIHRvLCBkZWZhdWx0UXVlcnkpXG4gICAgICA6IFtzb3VyY2VFbF07XG4gIH0sXG5cbiAgZGVmYXVsdERpc3BsYXkoZWwpIHtcbiAgICByZXR1cm4gKFxuICAgICAgeyB0cjogXCJ0YWJsZS1yb3dcIiwgdGQ6IFwidGFibGUtY2VsbFwiIH1bZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpXSB8fCBcImJsb2NrXCJcbiAgICApO1xuICB9LFxuXG4gIHRyYW5zaXRpb25DbGFzc2VzKHZhbCkge1xuICAgIGlmICghdmFsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgW3RyYW5zLCB0U3RhcnQsIHRFbmRdID0gQXJyYXkuaXNBcnJheSh2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBbdmFsLnNwbGl0KFwiIFwiKSwgW10sIFtdXTtcbiAgICB0cmFucyA9IEFycmF5LmlzQXJyYXkodHJhbnMpID8gdHJhbnMgOiB0cmFucy5zcGxpdChcIiBcIik7XG4gICAgdFN0YXJ0ID0gQXJyYXkuaXNBcnJheSh0U3RhcnQpID8gdFN0YXJ0IDogdFN0YXJ0LnNwbGl0KFwiIFwiKTtcbiAgICB0RW5kID0gQXJyYXkuaXNBcnJheSh0RW5kKSA/IHRFbmQgOiB0RW5kLnNwbGl0KFwiIFwiKTtcbiAgICByZXR1cm4gW3RyYW5zLCB0U3RhcnQsIHRFbmRdO1xuICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgSlM7XG4iLCAiaW1wb3J0IEpTIGZyb20gXCIuL2pzXCI7XG5pbXBvcnQgTGl2ZVNvY2tldCBmcm9tIFwiLi9saXZlX3NvY2tldFwiO1xuXG50eXBlIFRyYW5zaXRpb24gPSBzdHJpbmcgfCBzdHJpbmdbXTtcblxuLy8gQmFzZSBvcHRpb25zIGZvciBjb21tYW5kcyBpbnZvbHZpbmcgdHJhbnNpdGlvbnMgYW5kIHRpbWluZ1xudHlwZSBCYXNlT3B0cyA9IHtcbiAgLyoqXG4gICAqIFRoZSBDU1MgdHJhbnNpdGlvbiBjbGFzc2VzIHRvIHNldC5cbiAgICogQWNjZXB0cyBhIHN0cmluZyBvZiBjbGFzc2VzIG9yIGEgMy10dXBsZSBsaWtlOlxuICAgKiBgW1wiZWFzZS1vdXQgZHVyYXRpb24tMzAwXCIsIFwib3BhY2l0eS0wXCIsIFwib3BhY2l0eS0xMDBcIl1gXG4gICAqL1xuICB0cmFuc2l0aW9uPzogVHJhbnNpdGlvbjtcbiAgLyoqIFRoZSB0cmFuc2l0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy4gRGVmYXVsdHMgMjAwLiAqL1xuICB0aW1lPzogbnVtYmVyO1xuICAvKiogV2hldGhlciB0byBibG9jayBVSSBkdXJpbmcgdHJhbnNpdGlvbi4gRGVmYXVsdHMgYHRydWVgLiAqL1xuICBibG9ja2luZz86IGJvb2xlYW47XG59O1xuXG50eXBlIFNob3dPcHRzID0gQmFzZU9wdHMgJiB7XG4gIC8qKiBUaGUgQ1NTIGRpc3BsYXkgdmFsdWUgdG8gc2V0LiBEZWZhdWx0cyBcImJsb2NrXCIuICovXG4gIGRpc3BsYXk/OiBzdHJpbmc7XG59O1xuXG50eXBlIFRvZ2dsZU9wdHMgPSB7XG4gIC8qKiBUaGUgQ1NTIGRpc3BsYXkgdmFsdWUgdG8gc2V0LiBEZWZhdWx0cyBcImJsb2NrXCIuICovXG4gIGRpc3BsYXk/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgQ1NTIHRyYW5zaXRpb24gY2xhc3NlcyBmb3Igc2hvd2luZy5cbiAgICogQWNjZXB0cyBlaXRoZXIgdGhlIHN0cmluZyBvZiBjbGFzc2VzIHRvIGFwcGx5IHdoZW4gdG9nZ2xpbmcgaW4sIG9yXG4gICAqIGEgMy10dXBsZSBjb250YWluaW5nIHRoZSB0cmFuc2l0aW9uIGNsYXNzLCB0aGUgY2xhc3MgdG8gYXBwbHlcbiAgICogdG8gc3RhcnQgdGhlIHRyYW5zaXRpb24sIGFuZCB0aGUgZW5kaW5nIHRyYW5zaXRpb24gY2xhc3MsIHN1Y2ggYXM6XG4gICAqIGBbXCJlYXNlLW91dCBkdXJhdGlvbi0zMDBcIiwgXCJvcGFjaXR5LTBcIiwgXCJvcGFjaXR5LTEwMFwiXWBcbiAgICovXG4gIGluPzogVHJhbnNpdGlvbjtcbiAgLyoqXG4gICAqIFRoZSBDU1MgdHJhbnNpdGlvbiBjbGFzc2VzIGZvciBoaWRpbmcuXG4gICAqIEFjY2VwdHMgZWl0aGVyIHN0cmluZyBvZiBjbGFzc2VzIHRvIGFwcGx5IHdoZW4gdG9nZ2xpbmcgb3V0LCBvclxuICAgKiBhIDMtdHVwbGUgY29udGFpbmluZyB0aGUgdHJhbnNpdGlvbiBjbGFzcywgdGhlIGNsYXNzIHRvIGFwcGx5XG4gICAqIHRvIHN0YXJ0IHRoZSB0cmFuc2l0aW9uLCBhbmQgdGhlIGVuZGluZyB0cmFuc2l0aW9uIGNsYXNzLCBzdWNoIGFzOlxuICAgKiBgW1wiZWFzZS1vdXQgZHVyYXRpb24tMzAwXCIsIFwib3BhY2l0eS0xMDBcIiwgXCJvcGFjaXR5LTBcIl1gXG4gICAqL1xuICBvdXQ/OiBUcmFuc2l0aW9uO1xuICAvKiogVGhlIHRyYW5zaXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLiAqL1xuICB0aW1lPzogbnVtYmVyO1xuICAvKiogV2hldGhlciB0byBibG9jayBVSSBkdXJpbmcgdHJhbnNpdGlvbi4gRGVmYXVsdHMgYHRydWVgLiAqL1xuICBibG9ja2luZz86IGJvb2xlYW47XG59O1xuXG4vLyBPcHRpb25zIHNwZWNpZmljIHRvIHRoZSAndHJhbnNpdGlvbicgY29tbWFuZFxudHlwZSBUcmFuc2l0aW9uQ29tbWFuZE9wdHMgPSB7XG4gIC8qKiBUaGUgdHJhbnNpdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuICovXG4gIHRpbWU/OiBudW1iZXI7XG4gIC8qKiBXaGV0aGVyIHRvIGJsb2NrIFVJIGR1cmluZyB0cmFuc2l0aW9uLiBEZWZhdWx0cyBgdHJ1ZWAuICovXG4gIGJsb2NraW5nPzogYm9vbGVhbjtcbn07XG5cbnR5cGUgUHVzaE9wdHMgPSB7XG4gIC8qKiBEYXRhIHRvIGJlIG1lcmdlZCBpbnRvIHRoZSBldmVudCBwYXlsb2FkLiAqL1xuICB2YWx1ZT86IGFueTtcbiAgLyoqIEZvciB0YXJnZXRpbmcgYSBMaXZlQ29tcG9uZW50IGJ5IGl0cyBJRCwgYSBjb21wb25lbnQgSUQgKG51bWJlciksIG9yIGEgQ1NTIHNlbGVjdG9yIHN0cmluZy4gKi9cbiAgdGFyZ2V0PzogSFRNTEVsZW1lbnQgfCBudW1iZXIgfCBzdHJpbmc7XG4gIC8qKiBJbmRpY2F0ZXMgaWYgYSBwYWdlIGxvYWRpbmcgc3RhdGUgc2hvdWxkIGJlIHNob3duLiAqL1xuICBwYWdlX2xvYWRpbmc/OiBib29sZWFuO1xuICBba2V5OiBzdHJpbmddOiBhbnk7IC8vIEFsbG93IG90aGVyIHByb3BlcnRpZXMgbGlrZSAnY2lkJywgJ3JlZGlyZWN0JywgZXRjLlxufTtcblxudHlwZSBOYXZpZ2F0aW9uT3B0cyA9IHtcbiAgLyoqIFdoZXRoZXIgdG8gcmVwbGFjZSB0aGUgY3VycmVudCBoaXN0b3J5IGVudHJ5IGluc3RlYWQgb2YgcHVzaGluZyBhIG5ldyBvbmUuICovXG4gIHJlcGxhY2U/OiBib29sZWFuO1xufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFsbCBwb3NzaWJsZSBKUyBjb21tYW5kcyB0aGF0IGNhbiBiZSBnZW5lcmF0ZWQgYnkgdGhlIGZhY3RvcnkuXG4gKiBUaGlzIGlzIHVzZWQgYXMgYSBiYXNlIGZvciBMaXZlU29ja2V0SlNDb21tYW5kcyBhbmQgSG9va0pTQ29tbWFuZHMuXG4gKi9cbmludGVyZmFjZSBBbGxKU0NvbW1hbmRzIHtcbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGVuY29kZWQgSmF2YVNjcmlwdCBpbiB0aGUgY29udGV4dCBvZiB0aGUgZWxlbWVudC5cbiAgICogVGhpcyB2ZXJzaW9uIGlzIGZvciBnZW5lcmFsIHVzZSB2aWEgbGl2ZVNvY2tldC5qcygpLlxuICAgKlxuICAgKiBAcGFyYW0gZWwgLSBUaGUgZWxlbWVudCBpbiB3aG9zZSBjb250ZXh0IHRvIGV4ZWN1dGUgdGhlIEphdmFTY3JpcHQuXG4gICAqIEBwYXJhbSBlbmNvZGVkSlMgLSBUaGUgZW5jb2RlZCBKYXZhU2NyaXB0IHN0cmluZyB0byBleGVjdXRlLlxuICAgKi9cbiAgZXhlYyhlbDogSFRNTEVsZW1lbnQsIGVuY29kZWRKUzogc3RyaW5nKTogdm9pZDtcblxuICAvKipcbiAgICogU2hvd3MgYW4gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIGVsIC0gVGhlIGVsZW1lbnQgdG8gc2hvdy5cbiAgICogQHBhcmFtIHtTaG93T3B0c30gW29wdHM9e31dIC0gT3B0aW9uYWwgc2V0dGluZ3MuXG4gICAqICAgQWNjZXB0czogYGRpc3BsYXlgLCBgdHJhbnNpdGlvbmAsIGB0aW1lYCwgYW5kIGBibG9ja2luZ2AuXG4gICAqL1xuICBzaG93KGVsOiBIVE1MRWxlbWVudCwgb3B0cz86IFNob3dPcHRzKTogdm9pZDtcblxuICAvKipcbiAgICogSGlkZXMgYW4gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIGVsIC0gVGhlIGVsZW1lbnQgdG8gaGlkZS5cbiAgICogQHBhcmFtIFtvcHRzPXt9XSAtIE9wdGlvbmFsIHNldHRpbmdzLlxuICAgKiAgIEFjY2VwdHM6IGB0cmFuc2l0aW9uYCwgYHRpbWVgLCBhbmQgYGJsb2NraW5nYC5cbiAgICovXG4gIGhpZGUoZWw6IEhUTUxFbGVtZW50LCBvcHRzPzogQmFzZU9wdHMpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSB2aXNpYmlsaXR5IG9mIGFuIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSBlbCAtIFRoZSBlbGVtZW50IHRvIHRvZ2dsZS5cbiAgICogQHBhcmFtIFtvcHRzPXt9XSAtIE9wdGlvbmFsIHNldHRpbmdzLlxuICAgKiAgIEFjY2VwdHM6IGBkaXNwbGF5YCwgYGluYCwgYG91dGAsIGB0aW1lYCwgYW5kIGBibG9ja2luZ2AuXG4gICAqL1xuICB0b2dnbGUoZWw6IEhUTUxFbGVtZW50LCBvcHRzPzogVG9nZ2xlT3B0cyk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEFkZHMgQ1NTIGNsYXNzZXMgdG8gYW4gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIGVsIC0gVGhlIGVsZW1lbnQgdG8gYWRkIGNsYXNzZXMgdG8uXG4gICAqIEBwYXJhbSBuYW1lcyAtIFRoZSBjbGFzcyBuYW1lKHMpIHRvIGFkZC5cbiAgICogQHBhcmFtIFtvcHRzPXt9XSAtIE9wdGlvbmFsIHNldHRpbmdzLlxuICAgKiAgIEFjY2VwdHM6IGB0cmFuc2l0aW9uYCwgYHRpbWVgLCBhbmQgYGJsb2NraW5nYC5cbiAgICovXG4gIGFkZENsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZXM6IHN0cmluZyB8IHN0cmluZ1tdLCBvcHRzPzogQmFzZU9wdHMpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIENTUyBjbGFzc2VzIGZyb20gYW4gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIGVsIC0gVGhlIGVsZW1lbnQgdG8gcmVtb3ZlIGNsYXNzZXMgZnJvbS5cbiAgICogQHBhcmFtIG5hbWVzIC0gVGhlIGNsYXNzIG5hbWUocykgdG8gcmVtb3ZlLlxuICAgKiBAcGFyYW0gW29wdHM9e31dIC0gT3B0aW9uYWwgc2V0dGluZ3MuXG4gICAqICAgQWNjZXB0czogYHRyYW5zaXRpb25gLCBgdGltZWAsIGFuZCBgYmxvY2tpbmdgLlxuICAgKi9cbiAgcmVtb3ZlQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lczogc3RyaW5nIHwgc3RyaW5nW10sIG9wdHM/OiBCYXNlT3B0cyk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgQ1NTIGNsYXNzZXMgb24gYW4gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIGVsIC0gVGhlIGVsZW1lbnQgdG8gdG9nZ2xlIGNsYXNzZXMgb24uXG4gICAqIEBwYXJhbSBuYW1lcyAtIFRoZSBjbGFzcyBuYW1lKHMpIHRvIHRvZ2dsZS5cbiAgICogQHBhcmFtIFtvcHRzPXt9XSAtIE9wdGlvbmFsIHNldHRpbmdzLlxuICAgKiAgIEFjY2VwdHM6IGB0cmFuc2l0aW9uYCwgYHRpbWVgLCBhbmQgYGJsb2NraW5nYC5cbiAgICovXG4gIHRvZ2dsZUNsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZXM6IHN0cmluZyB8IHN0cmluZ1tdLCBvcHRzPzogQmFzZU9wdHMpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBBcHBsaWVzIGEgQ1NTIHRyYW5zaXRpb24gdG8gYW4gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIGVsIC0gVGhlIGVsZW1lbnQgdG8gYXBwbHkgdGhlIHRyYW5zaXRpb24gdG8uXG4gICAqIEBwYXJhbSB0cmFuc2l0aW9uIC0gVGhlIHRyYW5zaXRpb24gY2xhc3MoZXMpIHRvIGFwcGx5LlxuICAgKiAgIEFjY2VwdHMgYSBzdHJpbmcgb2YgY2xhc3NlcyB0byBhcHBseSB3aGVuIHRyYW5zaXRpb25pbmcgb3JcbiAgICogICBhIDMtdHVwbGUgY29udGFpbmluZyB0aGUgdHJhbnNpdGlvbiBjbGFzcywgdGhlIGNsYXNzIHRvIGFwcGx5XG4gICAqICAgdG8gc3RhcnQgdGhlIHRyYW5zaXRpb24sIGFuZCB0aGUgZW5kaW5nIHRyYW5zaXRpb24gY2xhc3MsIHN1Y2ggYXM6XG4gICAqXG4gICAqICAgICAgIFtcImVhc2Utb3V0IGR1cmF0aW9uLTMwMFwiLCBcIm9wYWNpdHktMTAwXCIsIFwib3BhY2l0eS0wXCJdXG4gICAqXG4gICAqIEBwYXJhbSBbb3B0cz17fV0gLSBPcHRpb25hbCBzZXR0aW5ncyBmb3IgdGltaW5nIGFuZCBibG9ja2luZyBiZWhhdmlvci5cbiAgICogICBBY2NlcHRzOiBgdGltZWAgYW5kIGBibG9ja2luZ2AuXG4gICAqL1xuICB0cmFuc2l0aW9uKFxuICAgIGVsOiBIVE1MRWxlbWVudCxcbiAgICB0cmFuc2l0aW9uOiBzdHJpbmcgfCBzdHJpbmdbXSxcbiAgICBvcHRzPzogVHJhbnNpdGlvbkNvbW1hbmRPcHRzLFxuICApOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBTZXRzIGFuIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0gZWwgLSBUaGUgZWxlbWVudCB0byBzZXQgdGhlIGF0dHJpYnV0ZSBvbi5cbiAgICogQHBhcmFtIGF0dHIgLSBUaGUgYXR0cmlidXRlIG5hbWUgdG8gc2V0LlxuICAgKiBAcGFyYW0gdmFsIC0gVGhlIHZhbHVlIHRvIHNldCBmb3IgdGhlIGF0dHJpYnV0ZS5cbiAgICovXG4gIHNldEF0dHJpYnV0ZShlbDogSFRNTEVsZW1lbnQsIGF0dHI6IHN0cmluZywgdmFsOiBzdHJpbmcpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGF0dHJpYnV0ZSBmcm9tIGFuIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSBlbCAtIFRoZSBlbGVtZW50IHRvIHJlbW92ZSB0aGUgYXR0cmlidXRlIGZyb20uXG4gICAqIEBwYXJhbSBhdHRyIC0gVGhlIGF0dHJpYnV0ZSBuYW1lIHRvIHJlbW92ZS5cbiAgICovXG4gIHJlbW92ZUF0dHJpYnV0ZShlbDogSFRNTEVsZW1lbnQsIGF0dHI6IHN0cmluZyk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgYW4gYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQgYmV0d2VlbiB0d28gdmFsdWVzLlxuICAgKlxuICAgKiBAcGFyYW0gZWwgLSBUaGUgZWxlbWVudCB0byB0b2dnbGUgdGhlIGF0dHJpYnV0ZSBvbi5cbiAgICogQHBhcmFtIGF0dHIgLSBUaGUgYXR0cmlidXRlIG5hbWUgdG8gdG9nZ2xlLlxuICAgKiBAcGFyYW0gdmFsMSAtIFRoZSBmaXJzdCB2YWx1ZSB0byB0b2dnbGUgYmV0d2Vlbi5cbiAgICogQHBhcmFtIHZhbDIgLSBUaGUgc2Vjb25kIHZhbHVlIHRvIHRvZ2dsZSBiZXR3ZWVuLlxuICAgKi9cbiAgdG9nZ2xlQXR0cmlidXRlKFxuICAgIGVsOiBIVE1MRWxlbWVudCxcbiAgICBhdHRyOiBzdHJpbmcsXG4gICAgdmFsMTogc3RyaW5nLFxuICAgIHZhbDI6IHN0cmluZyxcbiAgKTogdm9pZDtcblxuICAvKipcbiAgICogUHVzaGVzIGFuIGV2ZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEBwYXJhbSBlbCAtIEFuIGVsZW1lbnQgdGhhdCBiZWxvbmdzIHRvIHRoZSB0YXJnZXQgTGl2ZVZpZXcgLyBMaXZlQ29tcG9uZW50IG9yIGEgY29tcG9uZW50IElELlxuICAgKiAgIFRvIHRhcmdldCBhIExpdmVDb21wb25lbnQgYnkgaXRzIElELCBwYXNzIGEgc2VwYXJhdGUgYHRhcmdldGAgaW4gdGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB0eXBlIC0gVGhlIGV2ZW50IG5hbWUgdG8gcHVzaC5cbiAgICogQHBhcmFtIFtvcHRzPXt9XSAtIE9wdGlvbmFsIHNldHRpbmdzLlxuICAgKiAgIEFjY2VwdHM6IGB2YWx1ZWAsIGB0YXJnZXRgLCBgcGFnZV9sb2FkaW5nYC5cbiAgICovXG4gIHB1c2goZWw6IEhUTUxFbGVtZW50LCB0eXBlOiBzdHJpbmcsIG9wdHM/OiBQdXNoT3B0cyk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgbmF2aWdhdGlvbiBldmVudCB0byB0aGUgc2VydmVyIGFuZCB1cGRhdGVzIHRoZSBicm93c2VyJ3MgcHVzaFN0YXRlIGhpc3RvcnkuXG4gICAqXG4gICAqIEBwYXJhbSBocmVmIC0gVGhlIFVSTCB0byBuYXZpZ2F0ZSB0by5cbiAgICogQHBhcmFtIFtvcHRzPXt9XSAtIE9wdGlvbmFsIHNldHRpbmdzLlxuICAgKiAgIEFjY2VwdHM6IGByZXBsYWNlYC5cbiAgICovXG4gIG5hdmlnYXRlKGhyZWY6IHN0cmluZywgb3B0cz86IE5hdmlnYXRpb25PcHRzKTogdm9pZDtcblxuICAvKipcbiAgICogU2VuZHMgYSBwYXRjaCBldmVudCB0byB0aGUgc2VydmVyIGFuZCB1cGRhdGVzIHRoZSBicm93c2VyJ3MgcHVzaFN0YXRlIGhpc3RvcnkuXG4gICAqXG4gICAqIEBwYXJhbSBocmVmIC0gVGhlIFVSTCB0byBwYXRjaCB0by5cbiAgICogQHBhcmFtIFtvcHRzPXt9XSAtIE9wdGlvbmFsIHNldHRpbmdzLlxuICAgKiAgIEFjY2VwdHM6IGByZXBsYWNlYC5cbiAgICovXG4gIHBhdGNoKGhyZWY6IHN0cmluZywgb3B0cz86IE5hdmlnYXRpb25PcHRzKTogdm9pZDtcblxuICAvKipcbiAgICogTWFyayBhdHRyaWJ1dGVzIGFzIGlnbm9yZWQsIHNraXBwaW5nIHRoZW0gd2hlbiBwYXRjaGluZyB0aGUgRE9NLlxuICAgKlxuICAgKiBAcGFyYW0gZWwgLSBUaGUgZWxlbWVudCB0byBpZ25vcmUgYXR0cmlidXRlcyBvbi5cbiAgICogQHBhcmFtIGF0dHJzIC0gVGhlIGF0dHJpYnV0ZSBuYW1lIG9yIG5hbWVzIHRvIGlnbm9yZS5cbiAgICovXG4gIGlnbm9yZUF0dHJpYnV0ZXMoZWw6IEhUTUxFbGVtZW50LCBhdHRyczogc3RyaW5nIHwgc3RyaW5nW10pOiB2b2lkO1xufVxuXG5leHBvcnQgZGVmYXVsdCAoXG4gIGxpdmVTb2NrZXQ6IExpdmVTb2NrZXQsXG4gIGV2ZW50VHlwZTogc3RyaW5nIHwgbnVsbCxcbik6IEFsbEpTQ29tbWFuZHMgPT4ge1xuICByZXR1cm4ge1xuICAgIGV4ZWMoZWwsIGVuY29kZWRKUykge1xuICAgICAgbGl2ZVNvY2tldC5leGVjSlMoZWwsIGVuY29kZWRKUywgZXZlbnRUeXBlKTtcbiAgICB9LFxuICAgIHNob3coZWwsIG9wdHMgPSB7fSkge1xuICAgICAgY29uc3Qgb3duZXIgPSBsaXZlU29ja2V0Lm93bmVyKGVsKTtcbiAgICAgIEpTLnNob3coXG4gICAgICAgIGV2ZW50VHlwZSxcbiAgICAgICAgb3duZXIsXG4gICAgICAgIGVsLFxuICAgICAgICBvcHRzLmRpc3BsYXksXG4gICAgICAgIEpTLnRyYW5zaXRpb25DbGFzc2VzKG9wdHMudHJhbnNpdGlvbiksXG4gICAgICAgIG9wdHMudGltZSxcbiAgICAgICAgb3B0cy5ibG9ja2luZyxcbiAgICAgICk7XG4gICAgfSxcbiAgICBoaWRlKGVsLCBvcHRzID0ge30pIHtcbiAgICAgIGNvbnN0IG93bmVyID0gbGl2ZVNvY2tldC5vd25lcihlbCk7XG4gICAgICBKUy5oaWRlKFxuICAgICAgICBldmVudFR5cGUsXG4gICAgICAgIG93bmVyLFxuICAgICAgICBlbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgSlMudHJhbnNpdGlvbkNsYXNzZXMob3B0cy50cmFuc2l0aW9uKSxcbiAgICAgICAgb3B0cy50aW1lLFxuICAgICAgICBvcHRzLmJsb2NraW5nLFxuICAgICAgKTtcbiAgICB9LFxuICAgIHRvZ2dsZShlbCwgb3B0cyA9IHt9KSB7XG4gICAgICBjb25zdCBvd25lciA9IGxpdmVTb2NrZXQub3duZXIoZWwpO1xuICAgICAgY29uc3QgaW5UcmFuc2l0aW9uID0gSlMudHJhbnNpdGlvbkNsYXNzZXMob3B0cy5pbik7XG4gICAgICBjb25zdCBvdXRUcmFuc2l0aW9uID0gSlMudHJhbnNpdGlvbkNsYXNzZXMob3B0cy5vdXQpO1xuICAgICAgSlMudG9nZ2xlKFxuICAgICAgICBldmVudFR5cGUsXG4gICAgICAgIG93bmVyLFxuICAgICAgICBlbCxcbiAgICAgICAgb3B0cy5kaXNwbGF5LFxuICAgICAgICBpblRyYW5zaXRpb24sXG4gICAgICAgIG91dFRyYW5zaXRpb24sXG4gICAgICAgIG9wdHMudGltZSxcbiAgICAgICAgb3B0cy5ibG9ja2luZyxcbiAgICAgICk7XG4gICAgfSxcbiAgICBhZGRDbGFzcyhlbCwgbmFtZXMsIG9wdHMgPSB7fSkge1xuICAgICAgY29uc3QgY2xhc3NOYW1lcyA9IEFycmF5LmlzQXJyYXkobmFtZXMpID8gbmFtZXMgOiBuYW1lcy5zcGxpdChcIiBcIik7XG4gICAgICBjb25zdCBvd25lciA9IGxpdmVTb2NrZXQub3duZXIoZWwpO1xuICAgICAgSlMuYWRkT3JSZW1vdmVDbGFzc2VzKFxuICAgICAgICBlbCxcbiAgICAgICAgY2xhc3NOYW1lcyxcbiAgICAgICAgW10sXG4gICAgICAgIEpTLnRyYW5zaXRpb25DbGFzc2VzKG9wdHMudHJhbnNpdGlvbiksXG4gICAgICAgIG9wdHMudGltZSxcbiAgICAgICAgb3duZXIsXG4gICAgICAgIG9wdHMuYmxvY2tpbmcsXG4gICAgICApO1xuICAgIH0sXG4gICAgcmVtb3ZlQ2xhc3MoZWwsIG5hbWVzLCBvcHRzID0ge30pIHtcbiAgICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBBcnJheS5pc0FycmF5KG5hbWVzKSA/IG5hbWVzIDogbmFtZXMuc3BsaXQoXCIgXCIpO1xuICAgICAgY29uc3Qgb3duZXIgPSBsaXZlU29ja2V0Lm93bmVyKGVsKTtcbiAgICAgIEpTLmFkZE9yUmVtb3ZlQ2xhc3NlcyhcbiAgICAgICAgZWwsXG4gICAgICAgIFtdLFxuICAgICAgICBjbGFzc05hbWVzLFxuICAgICAgICBKUy50cmFuc2l0aW9uQ2xhc3NlcyhvcHRzLnRyYW5zaXRpb24pLFxuICAgICAgICBvcHRzLnRpbWUsXG4gICAgICAgIG93bmVyLFxuICAgICAgICBvcHRzLmJsb2NraW5nLFxuICAgICAgKTtcbiAgICB9LFxuICAgIHRvZ2dsZUNsYXNzKGVsLCBuYW1lcywgb3B0cyA9IHt9KSB7XG4gICAgICBjb25zdCBjbGFzc05hbWVzID0gQXJyYXkuaXNBcnJheShuYW1lcykgPyBuYW1lcyA6IG5hbWVzLnNwbGl0KFwiIFwiKTtcbiAgICAgIGNvbnN0IG93bmVyID0gbGl2ZVNvY2tldC5vd25lcihlbCk7XG4gICAgICBKUy50b2dnbGVDbGFzc2VzKFxuICAgICAgICBlbCxcbiAgICAgICAgY2xhc3NOYW1lcyxcbiAgICAgICAgSlMudHJhbnNpdGlvbkNsYXNzZXMob3B0cy50cmFuc2l0aW9uKSxcbiAgICAgICAgb3B0cy50aW1lLFxuICAgICAgICBvd25lcixcbiAgICAgICAgb3B0cy5ibG9ja2luZyxcbiAgICAgICk7XG4gICAgfSxcbiAgICB0cmFuc2l0aW9uKGVsLCB0cmFuc2l0aW9uLCBvcHRzID0ge30pIHtcbiAgICAgIGNvbnN0IG93bmVyID0gbGl2ZVNvY2tldC5vd25lcihlbCk7XG4gICAgICBKUy5hZGRPclJlbW92ZUNsYXNzZXMoXG4gICAgICAgIGVsLFxuICAgICAgICBbXSxcbiAgICAgICAgW10sXG4gICAgICAgIEpTLnRyYW5zaXRpb25DbGFzc2VzKHRyYW5zaXRpb24pLFxuICAgICAgICBvcHRzLnRpbWUsXG4gICAgICAgIG93bmVyLFxuICAgICAgICBvcHRzLmJsb2NraW5nLFxuICAgICAgKTtcbiAgICB9LFxuICAgIHNldEF0dHJpYnV0ZShlbCwgYXR0ciwgdmFsKSB7XG4gICAgICBKUy5zZXRPclJlbW92ZUF0dHJzKGVsLCBbW2F0dHIsIHZhbF1dLCBbXSk7XG4gICAgfSxcbiAgICByZW1vdmVBdHRyaWJ1dGUoZWwsIGF0dHIpIHtcbiAgICAgIEpTLnNldE9yUmVtb3ZlQXR0cnMoZWwsIFtdLCBbYXR0cl0pO1xuICAgIH0sXG4gICAgdG9nZ2xlQXR0cmlidXRlKGVsLCBhdHRyLCB2YWwxLCB2YWwyKSB7XG4gICAgICBKUy50b2dnbGVBdHRyKGVsLCBhdHRyLCB2YWwxLCB2YWwyKTtcbiAgICB9LFxuICAgIHB1c2goZWwsIHR5cGUsIG9wdHMgPSB7fSkge1xuICAgICAgbGl2ZVNvY2tldC53aXRoaW5Pd25lcnMoZWwsICh2aWV3KSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBvcHRzLnZhbHVlIHx8IHt9O1xuICAgICAgICBkZWxldGUgb3B0cy52YWx1ZTtcbiAgICAgICAgbGV0IGUgPSBuZXcgQ3VzdG9tRXZlbnQoXCJwaHg6ZXhlY1wiLCB7IGRldGFpbDogeyBzb3VyY2VFbGVtZW50OiBlbCB9IH0pO1xuICAgICAgICBKUy5leGVjKGUsIGV2ZW50VHlwZSwgdHlwZSwgdmlldywgZWwsIFtcInB1c2hcIiwgeyBkYXRhLCAuLi5vcHRzIH1dKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgbmF2aWdhdGUoaHJlZiwgb3B0cyA9IHt9KSB7XG4gICAgICBjb25zdCBjdXN0b21FdmVudCA9IG5ldyBDdXN0b21FdmVudChcInBoeDpleGVjXCIpO1xuICAgICAgbGl2ZVNvY2tldC5oaXN0b3J5UmVkaXJlY3QoXG4gICAgICAgIGN1c3RvbUV2ZW50LFxuICAgICAgICBocmVmLFxuICAgICAgICBvcHRzLnJlcGxhY2UgPyBcInJlcGxhY2VcIiA6IFwicHVzaFwiLFxuICAgICAgICBudWxsLFxuICAgICAgICBudWxsLFxuICAgICAgKTtcbiAgICB9LFxuICAgIHBhdGNoKGhyZWYsIG9wdHMgPSB7fSkge1xuICAgICAgY29uc3QgY3VzdG9tRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoXCJwaHg6ZXhlY1wiKTtcbiAgICAgIGxpdmVTb2NrZXQucHVzaEhpc3RvcnlQYXRjaChcbiAgICAgICAgY3VzdG9tRXZlbnQsXG4gICAgICAgIGhyZWYsXG4gICAgICAgIG9wdHMucmVwbGFjZSA/IFwicmVwbGFjZVwiIDogXCJwdXNoXCIsXG4gICAgICAgIG51bGwsXG4gICAgICApO1xuICAgIH0sXG4gICAgaWdub3JlQXR0cmlidXRlcyhlbCwgYXR0cnMpIHtcbiAgICAgIEpTLmlnbm9yZUF0dHJzKGVsLCBBcnJheS5pc0FycmF5KGF0dHJzKSA/IGF0dHJzIDogW2F0dHJzXSk7XG4gICAgfSxcbiAgfTtcbn07XG5cbi8qKlxuICogSlNDb21tYW5kcyBmb3IgdXNlIHdpdGggYGxpdmVTb2NrZXQuanMoKWAuXG4gKiBJbmNsdWRlcyB0aGUgZ2VuZXJhbCBgZXhlY2AgY29tbWFuZCB0aGF0IHJlcXVpcmVzIGFuIGVsZW1lbnQuXG4gKi9cbmV4cG9ydCB0eXBlIExpdmVTb2NrZXRKU0NvbW1hbmRzID0gQWxsSlNDb21tYW5kcztcblxuLyoqXG4gKiBKU0NvbW1hbmRzIGZvciB1c2Ugd2l0aGluIGEgSG9vay5cbiAqIFRoZSBgZXhlY2AgY29tbWFuZCBpcyB0YWlsb3JlZCBmb3IgaG9va3MsIG5vdCByZXF1aXJpbmcgYW4gZXhwbGljaXQgZWxlbWVudC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBIb29rSlNDb21tYW5kcyBleHRlbmRzIE9taXQ8QWxsSlNDb21tYW5kcywgXCJleGVjXCI+IHtcbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGVuY29kZWQgSmF2YVNjcmlwdCBpbiB0aGUgY29udGV4dCBvZiB0aGUgaG9vaydzIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGVkSlMgLSBUaGUgZW5jb2RlZCBKYXZhU2NyaXB0IHN0cmluZyB0byBleGVjdXRlLlxuICAgKi9cbiAgZXhlYyhlbmNvZGVkSlM6IHN0cmluZyk6IHZvaWQ7XG59XG4iLCAiaW1wb3J0IGpzQ29tbWFuZHMsIHsgSG9va0pTQ29tbWFuZHMgfSBmcm9tIFwiLi9qc19jb21tYW5kc1wiO1xuaW1wb3J0IERPTSBmcm9tIFwiLi9kb21cIjtcbmltcG9ydCBMaXZlU29ja2V0IGZyb20gXCIuL2xpdmVfc29ja2V0XCI7XG5pbXBvcnQgVmlldyBmcm9tIFwiLi92aWV3XCI7XG5cbmNvbnN0IEhPT0tfSUQgPSBcImhvb2tJZFwiO1xubGV0IHZpZXdIb29rSUQgPSAxO1xuXG5leHBvcnQgdHlwZSBPblJlcGx5ID0gKHJlcGx5OiBhbnksIHJlZjogbnVtYmVyKSA9PiBhbnk7XG5leHBvcnQgdHlwZSBDYWxsYmFja1JlZiA9IHsgZXZlbnQ6IHN0cmluZzsgY2FsbGJhY2s6IChwYXlsb2FkOiBhbnkpID0+IGFueSB9O1xuXG5leHBvcnQgdHlwZSBQaHhUYXJnZXQgPSBzdHJpbmcgfCBudW1iZXIgfCBIVE1MRWxlbWVudDtcblxuZXhwb3J0IGludGVyZmFjZSBIb29rSW50ZXJmYWNlPEUgZXh0ZW5kcyBIVE1MRWxlbWVudCA9IEhUTUxFbGVtZW50PiB7XG4gIC8qKlxuICAgKiBUaGUgRE9NIGVsZW1lbnQgdGhhdCB0aGUgaG9vayBpcyBhdHRhY2hlZCB0by5cbiAgICovXG4gIGVsOiBFO1xuXG4gIC8qKlxuICAgKiBUaGUgTGl2ZVNvY2tldCBpbnN0YW5jZSB0aGF0IHRoZSBob29rIGlzIGF0dGFjaGVkIHRvLlxuICAgKi9cbiAgbGl2ZVNvY2tldDogTGl2ZVNvY2tldDtcblxuICAvKipcbiAgICogVGhlIG1vdW50ZWQgY2FsbGJhY2suXG4gICAqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBlbGVtZW50IGhhcyBiZWVuIGFkZGVkIHRvIHRoZSBET00gYW5kIGl0cyBzZXJ2ZXIgTGl2ZVZpZXcgaGFzIGZpbmlzaGVkIG1vdW50aW5nLlxuICAgKi9cbiAgbW91bnRlZD86ICgpID0+IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFRoZSBiZWZvcmVVcGRhdGUgY2FsbGJhY2suXG4gICAqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBlbGVtZW50IGlzIGFib3V0IHRvIGJlIHVwZGF0ZWQgaW4gdGhlIERPTS5cbiAgICogTm90ZTogYW55IGNhbGwgaGVyZSBtdXN0IGJlIHN5bmNocm9ub3VzIGFzIHRoZSBvcGVyYXRpb24gY2Fubm90IGJlIGRlZmVycmVkIG9yIGNhbmNlbGxlZC5cbiAgICovXG4gIGJlZm9yZVVwZGF0ZT86ICgpID0+IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFRoZSB1cGRhdGVkIGNhbGxiYWNrLlxuICAgKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgZWxlbWVudCBoYXMgYmVlbiB1cGRhdGVkIGluIHRoZSBET00gYnkgdGhlIHNlcnZlclxuICAgKi9cbiAgdXBkYXRlZD86ICgpID0+IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFRoZSBkZXN0cm95ZWQgY2FsbGJhY2suXG4gICAqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBlbGVtZW50IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgcGFnZSwgZWl0aGVyIGJ5IGEgcGFyZW50IHVwZGF0ZSwgb3IgYnkgdGhlIHBhcmVudCBiZWluZyByZW1vdmVkIGVudGlyZWx5XG4gICAqL1xuICBkZXN0cm95ZWQ/OiAoKSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBUaGUgZGlzY29ubmVjdGVkIGNhbGxiYWNrLlxuICAgKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgZWxlbWVudCdzIHBhcmVudCBMaXZlVmlldyBoYXMgZGlzY29ubmVjdGVkIGZyb20gdGhlIHNlcnZlci5cbiAgICovXG4gIGRpc2Nvbm5lY3RlZD86ICgpID0+IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFRoZSByZWNvbm5lY3RlZCBjYWxsYmFjay5cbiAgICpcbiAgICogQ2FsbGVkIHdoZW4gdGhlIGVsZW1lbnQncyBwYXJlbnQgTGl2ZVZpZXcgaGFzIHJlY29ubmVjdGVkIHRvIHRoZSBzZXJ2ZXIuXG4gICAqL1xuICByZWNvbm5lY3RlZD86ICgpID0+IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IHdpdGggbWV0aG9kcyB0byBtYW5pcHVsYXRlIHRoZSBET00gYW5kIGV4ZWN1dGUgSmF2YVNjcmlwdC5cbiAgICogVGhlIGFwcGxpZWQgY2hhbmdlcyBpbnRlZ3JhdGUgd2l0aCBzZXJ2ZXIgRE9NIHBhdGNoaW5nLlxuICAgKi9cbiAganMoKTogSG9va0pTQ29tbWFuZHM7XG5cbiAgLyoqXG4gICAqIFB1c2hlcyBhbiBldmVudCB0byB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgZXZlbnQgbmFtZS5cbiAgICogQHBhcmFtIFtwYXlsb2FkXSAtIFRoZSBwYXlsb2FkIHRvIHNlbmQgdG8gdGhlIHNlcnZlci4gRGVmYXVsdHMgdG8gYW4gZW1wdHkgb2JqZWN0LlxuICAgKiBAcGFyYW0gW29uUmVwbHldIC0gQSBjYWxsYmFjayB0byBoYW5kbGUgdGhlIHNlcnZlcidzIHJlcGx5LlxuICAgKlxuICAgKiBXaGVuIG9uUmVwbHkgaXMgbm90IHByb3ZpZGVkLCB0aGUgbWV0aG9kIHJldHVybnMgYSBQcm9taXNlIHRoYXRcbiAgICogV2hlbiBvblJlcGx5IGlzIHByb3ZpZGVkLCB0aGUgbWV0aG9kIHJldHVybnMgdm9pZC5cbiAgICovXG4gIHB1c2hFdmVudChldmVudDogc3RyaW5nLCBwYXlsb2FkOiBhbnksIG9uUmVwbHk6IE9uUmVwbHkpOiB2b2lkO1xuICBwdXNoRXZlbnQoZXZlbnQ6IHN0cmluZywgcGF5bG9hZD86IGFueSk6IFByb21pc2U8YW55PjtcblxuICAvKipcbiAgICogUHVzaGVkIGEgdGFyZ2V0ZWQgZXZlbnQgdG8gdGhlIHNlcnZlci5cbiAgICpcbiAgICogSXQgc2VuZHMgdGhlIGV2ZW50IHRvIHRoZSBMaXZlQ29tcG9uZW50IG9yIExpdmVWaWV3IHRoZSBgc2VsZWN0b3JPclRhcmdldGAgaXMgZGVmaW5lZCBpbixcbiAgICogd2hlcmUgaXRzIHZhbHVlIGNhbiBiZSBlaXRoZXIgYSBxdWVyeSBzZWxlY3RvciwgYW4gYWN0dWFsIERPTSBlbGVtZW50LCBvciBhIENJRCAoY29tcG9uZW50IGlkKVxuICAgKiByZXR1cm5lZCBieSB0aGUgYEBteXNlbGZgIGFzc2lnbi5cbiAgICpcbiAgICogSWYgdGhlIHF1ZXJ5IHNlbGVjdG9yIHJldHVybnMgbW9yZSB0aGFuIG9uZSBlbGVtZW50IGl0IHdpbGwgc2VuZCB0aGUgZXZlbnQgdG8gYWxsIG9mIHRoZW0sXG4gICAqIGV2ZW4gaWYgYWxsIHRoZSBlbGVtZW50cyBhcmUgaW4gdGhlIHNhbWUgTGl2ZUNvbXBvbmVudCBvciBMaXZlVmlldy4gQmVjYXVzZSBvZiB0aGlzLFxuICAgKiBpZiBubyBjYWxsYmFjayBpcyBwYXNzZWQsIGEgcHJvbWlzZSBpcyByZXR1cm5lZCB0aGF0IG1hdGNoZXMgdGhlIHJldHVybiB2YWx1ZSBvZlxuICAgKiBbYFByb21pc2UuYWxsU2V0dGxlZCgpYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZS9hbGxTZXR0bGVkI3JldHVybl92YWx1ZSkuXG4gICAqIEluZGl2aWR1YWwgZnVsZmlsbGVkIHZhbHVlcyBhcmUgb2YgdGhlIGZvcm1hdCBgeyByZXBseSwgcmVmIH1gLCB3aGVyZSBgcmVwbHlgIGlzIHRoZSBzZXJ2ZXIncyByZXBseS5cbiAgICpcbiAgICogQHBhcmFtIHNlbGVjdG9yT3JUYXJnZXQgLSBUaGUgc2VsZWN0b3IsIGVsZW1lbnQsIG9yIENJRCB0byB0YXJnZXQuXG4gICAqIEBwYXJhbSBldmVudCAtIFRoZSBldmVudCBuYW1lLlxuICAgKiBAcGFyYW0gW3BheWxvYWRdIC0gVGhlIHBheWxvYWQgdG8gc2VuZCB0byB0aGUgc2VydmVyLiBEZWZhdWx0cyB0byBhbiBlbXB0eSBvYmplY3QuXG4gICAqIEBwYXJhbSBbb25SZXBseV0gLSBBIGNhbGxiYWNrIHRvIGhhbmRsZSB0aGUgc2VydmVyJ3MgcmVwbHkuXG4gICAqXG4gICAqIFdoZW4gb25SZXBseSBpcyBub3QgcHJvdmlkZWQsIHRoZSBtZXRob2QgcmV0dXJucyBhIFByb21pc2UuXG4gICAqIFdoZW4gb25SZXBseSBpcyBwcm92aWRlZCwgdGhlIG1ldGhvZCByZXR1cm5zIHZvaWQuXG4gICAqL1xuICBwdXNoRXZlbnRUbyhcbiAgICBzZWxlY3Rvck9yVGFyZ2V0OiBQaHhUYXJnZXQsXG4gICAgZXZlbnQ6IHN0cmluZyxcbiAgICBwYXlsb2FkOiBvYmplY3QsXG4gICAgb25SZXBseTogT25SZXBseSxcbiAgKTogdm9pZDtcbiAgcHVzaEV2ZW50VG8oXG4gICAgc2VsZWN0b3JPclRhcmdldDogUGh4VGFyZ2V0LFxuICAgIGV2ZW50OiBzdHJpbmcsXG4gICAgcGF5bG9hZD86IG9iamVjdCxcbiAgKTogUHJvbWlzZTxQcm9taXNlU2V0dGxlZFJlc3VsdDx7IHJlcGx5OiBhbnk7IHJlZjogbnVtYmVyIH0+W10+O1xuXG4gIC8qKlxuICAgKiBBbGxvd3MgdG8gcmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2hlbiBhbiBldmVudCBpcyByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIFRoaXMgaXMgdXNlZCB0byBoYW5kbGUgYHB1c2hFdmVudGAgY2FsbHMgZnJvbSB0aGUgc2VydmVyLiBUaGUgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggdGhlIHBheWxvYWQgZnJvbSB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgZXZlbnQgbmFtZS5cbiAgICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgaXMgcmVjZWl2ZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoZSBjYWxsYmFjaywgd2hpY2ggY2FuIGJlIHVzZWQgaW4gYHJlbW92ZUhhbmRsZUV2ZW50YCB0byByZW1vdmUgdGhlIGNhbGxiYWNrLlxuICAgKi9cbiAgaGFuZGxlRXZlbnQoZXZlbnQ6IHN0cmluZywgY2FsbGJhY2s6IChwYXlsb2FkOiBhbnkpID0+IGFueSk6IENhbGxiYWNrUmVmO1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2FsbGJhY2sgcmVnaXN0ZXJlZCB3aXRoIGBoYW5kbGVFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsYmFja1JlZiAtIFRoZSByZWZlcmVuY2UgdG8gdGhlIGNhbGxiYWNrIHRvIHJlbW92ZS5cbiAgICovXG4gIHJlbW92ZUhhbmRsZUV2ZW50KHJlZjogQ2FsbGJhY2tSZWYpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBBbGxvd3MgdG8gdHJpZ2dlciBhIGxpdmUgZmlsZSB1cGxvYWQuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIC0gVGhlIHVwbG9hZCBuYW1lIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGBQaG9lbml4LkxpdmVWaWV3LmFsbG93X3VwbG9hZC8zYCBjYWxsLlxuICAgKiBAcGFyYW0gZmlsZXMgLSBUaGUgZmlsZXMgdG8gdXBsb2FkLlxuICAgKi9cbiAgdXBsb2FkKG5hbWU6IGFueSwgZmlsZXM6IGFueSk6IGFueTtcblxuICAvKipcbiAgICogQWxsb3dzIHRvIHRyaWdnZXIgYSBsaXZlIGZpbGUgdXBsb2FkIHRvIGEgc3BlY2lmaWMgdGFyZ2V0LlxuICAgKlxuICAgKiBAcGFyYW0gc2VsZWN0b3JPclRhcmdldCAtIFRoZSB0YXJnZXQgdG8gdXBsb2FkIHRoZSBmaWxlcyB0by5cbiAgICogQHBhcmFtIG5hbWUgLSBUaGUgdXBsb2FkIG5hbWUgY29ycmVzcG9uZGluZyB0byB0aGUgYFBob2VuaXguTGl2ZVZpZXcuYWxsb3dfdXBsb2FkLzNgIGNhbGwuXG4gICAqIEBwYXJhbSBmaWxlcyAtIFRoZSBmaWxlcyB0byB1cGxvYWQuXG4gICAqL1xuICB1cGxvYWRUbyhzZWxlY3Rvck9yVGFyZ2V0OiBQaHhUYXJnZXQsIG5hbWU6IGFueSwgZmlsZXM6IGFueSk6IGFueTtcblxuICAvLyBhbGxvdyB1bmtub3duIG1ldGhvZHMsIGFzIHBlb3BsZSBjYW4gZGVmaW5lIHRoZW0gaW4gdGhlaXIgaG9va3NcbiAgW2tleTogUHJvcGVydHlLZXldOiBhbnk7XG59XG5cbi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9EZWZpbml0ZWx5VHlwZWQvRGVmaW5pdGVseVR5cGVkL2Jsb2IvZmFjMWFhNzVhY2RkZGJmNGYxYTk1ZTk4ZWUyMjk3YjU0Y2U0YjRjOS90eXBlcy9waG9lbml4X2xpdmVfdmlldy9ob29rcy5kLnRzI0wyNlxuLy8gbGljZW5zZWQgdW5kZXIgTUlUXG5leHBvcnQgaW50ZXJmYWNlIEhvb2s8VCA9IG9iamVjdCwgRSBleHRlbmRzIEhUTUxFbGVtZW50ID0gSFRNTEVsZW1lbnQ+IHtcbiAgLyoqXG4gICAqIFRoZSBtb3VudGVkIGNhbGxiYWNrLlxuICAgKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgZWxlbWVudCBoYXMgYmVlbiBhZGRlZCB0byB0aGUgRE9NIGFuZCBpdHMgc2VydmVyIExpdmVWaWV3IGhhcyBmaW5pc2hlZCBtb3VudGluZy5cbiAgICovXG4gIG1vdW50ZWQ/OiAodGhpczogVCAmIEhvb2tJbnRlcmZhY2U8RT4pID0+IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFRoZSBiZWZvcmVVcGRhdGUgY2FsbGJhY2suXG4gICAqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBlbGVtZW50IGlzIGFib3V0IHRvIGJlIHVwZGF0ZWQgaW4gdGhlIERPTS5cbiAgICogTm90ZTogYW55IGNhbGwgaGVyZSBtdXN0IGJlIHN5bmNocm9ub3VzIGFzIHRoZSBvcGVyYXRpb24gY2Fubm90IGJlIGRlZmVycmVkIG9yIGNhbmNlbGxlZC5cbiAgICovXG4gIGJlZm9yZVVwZGF0ZT86ICh0aGlzOiBUICYgSG9va0ludGVyZmFjZTxFPikgPT4gdm9pZDtcblxuICAvKipcbiAgICogVGhlIHVwZGF0ZWQgY2FsbGJhY2suXG4gICAqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBlbGVtZW50IGhhcyBiZWVuIHVwZGF0ZWQgaW4gdGhlIERPTSBieSB0aGUgc2VydmVyXG4gICAqL1xuICB1cGRhdGVkPzogKHRoaXM6IFQgJiBIb29rSW50ZXJmYWNlPEU+KSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVzdHJveWVkIGNhbGxiYWNrLlxuICAgKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgZWxlbWVudCBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIHBhZ2UsIGVpdGhlciBieSBhIHBhcmVudCB1cGRhdGUsIG9yIGJ5IHRoZSBwYXJlbnQgYmVpbmcgcmVtb3ZlZCBlbnRpcmVseVxuICAgKi9cbiAgZGVzdHJveWVkPzogKHRoaXM6IFQgJiBIb29rSW50ZXJmYWNlPEU+KSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBUaGUgZGlzY29ubmVjdGVkIGNhbGxiYWNrLlxuICAgKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgZWxlbWVudCdzIHBhcmVudCBMaXZlVmlldyBoYXMgZGlzY29ubmVjdGVkIGZyb20gdGhlIHNlcnZlci5cbiAgICovXG4gIGRpc2Nvbm5lY3RlZD86ICh0aGlzOiBUICYgSG9va0ludGVyZmFjZTxFPikgPT4gdm9pZDtcblxuICAvKipcbiAgICogVGhlIHJlY29ubmVjdGVkIGNhbGxiYWNrLlxuICAgKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgZWxlbWVudCdzIHBhcmVudCBMaXZlVmlldyBoYXMgcmVjb25uZWN0ZWQgdG8gdGhlIHNlcnZlci5cbiAgICovXG4gIHJlY29ubmVjdGVkPzogKHRoaXM6IFQgJiBIb29rSW50ZXJmYWNlPEU+KSA9PiB2b2lkO1xuXG4gIC8vIEFsbG93IGN1c3RvbSBtZXRob2RzIHdpdGggYW55IHNpZ25hdHVyZSBhbmQgY3VzdG9tIHByb3BlcnRpZXNcbiAgW2tleTogUHJvcGVydHlLZXldOiBhbnk7XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgTGl2ZVZpZXcgaG9va3MuIFVzZXJzIGV4dGVuZCB0aGlzIGNsYXNzIHRvIGRlZmluZSB0aGVpciBob29rcy5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgdHlwZXNjcmlwdFxuICogY2xhc3MgTXlDdXN0b21Ib29rIGV4dGVuZHMgVmlld0hvb2sge1xuICogICBteVN0YXRlID0gXCJpbml0aWFsXCI7XG4gKlxuICogICBtb3VudGVkKCkge1xuICogICAgIGNvbnNvbGUubG9nKFwiSG9vayBtb3VudGVkIG9uIGVsZW1lbnQ6XCIsIHRoaXMuZWwpO1xuICogICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAqICAgICAgIHRoaXMucHVzaEV2ZW50KFwiZWxlbWVudC1jbGlja2VkXCIsIHsgc3RhdGU6IHRoaXMubXlTdGF0ZSB9KTtcbiAqICAgICB9KTtcbiAqICAgfVxuICpcbiAqICAgdXBkYXRlZCgpIHtcbiAqICAgICBjb25zb2xlLmxvZyhcIkhvb2sgdXBkYXRlZFwiLCB0aGlzLmVsLmlkKTtcbiAqICAgfVxuICpcbiAqICAgbXlDdXN0b21NZXRob2Qoc29tZUFyZzogc3RyaW5nKSB7XG4gKiAgICAgY29uc29sZS5sb2coXCJteUN1c3RvbU1ldGhvZCBjYWxsZWQgd2l0aDpcIiwgc29tZUFyZywgXCJDdXJyZW50IHN0YXRlOlwiLCB0aGlzLm15U3RhdGUpO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBUaGUgYHRoaXNgIGNvbnRleHQgd2l0aGluIHRoZSBob29rIG1ldGhvZHMgKG1vdW50ZWQsIHVwZGF0ZWQsIGN1c3RvbSBtZXRob2RzLCBldGMuKVxuICogd2lsbCByZWZlciB0byB0aGUgaG9vayBpbnN0YW5jZSwgcHJvdmlkaW5nIGFjY2VzcyB0byBgdGhpcy5lbGAsIGB0aGlzLmxpdmVTb2NrZXRgLFxuICogYHRoaXMucHVzaEV2ZW50KClgLCBldGMuLCBhcyB3ZWxsIGFzIGFueSBwcm9wZXJ0aWVzIG9yIG1ldGhvZHMgZGVmaW5lZCBvbiB0aGUgc3ViY2xhc3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBWaWV3SG9vazxFIGV4dGVuZHMgSFRNTEVsZW1lbnQgPSBIVE1MRWxlbWVudD5cbiAgaW1wbGVtZW50cyBIb29rSW50ZXJmYWNlPEU+XG57XG4gIGVsOiBFO1xuXG4gIHByaXZhdGUgX19saXN0ZW5lcnM6IFNldDxDYWxsYmFja1JlZj47XG4gIHByaXZhdGUgX19pc0Rpc2Nvbm5lY3RlZDogYm9vbGVhbjtcbiAgcHJpdmF0ZSBfX3ZpZXchOiAoKSA9PiBWaWV3O1xuICBwcml2YXRlIF9fbGl2ZVNvY2tldCE6ICgpID0+IExpdmVTb2NrZXQ7XG5cbiAgZ2V0IGxpdmVTb2NrZXQoKTogTGl2ZVNvY2tldCB7XG4gICAgcmV0dXJuIHRoaXMuX19saXZlU29ja2V0KCk7XG4gIH1cblxuICBzdGF0aWMgbWFrZUlEKCkge1xuICAgIHJldHVybiB2aWV3SG9va0lEKys7XG4gIH1cbiAgc3RhdGljIGVsZW1lbnRJRChlbDogSFRNTEVsZW1lbnQpIHtcbiAgICByZXR1cm4gRE9NLnByaXZhdGUoZWwsIEhPT0tfSUQpO1xuICB9XG5cbiAgY29uc3RydWN0b3IodmlldzogVmlldyB8IG51bGwsIGVsOiBFLCBjYWxsYmFja3M/OiBIb29rKSB7XG4gICAgdGhpcy5lbCA9IGVsO1xuICAgIHRoaXMuX19hdHRhY2hWaWV3KHZpZXcpO1xuICAgIHRoaXMuX19saXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5fX2lzRGlzY29ubmVjdGVkID0gZmFsc2U7XG4gICAgRE9NLnB1dFByaXZhdGUodGhpcy5lbCwgSE9PS19JRCwgVmlld0hvb2subWFrZUlEKCkpO1xuXG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgLy8gVGhpcyBpbnN0YW5jZSBpcyBmb3IgYW4gb2JqZWN0LWxpdGVyYWwgaG9vay4gQ29weSBtZXRob2RzL3Byb3BlcnRpZXMuXG4gICAgICAvLyBUaGVzZSBhcmUgcHJvcGVydGllcyB0aGF0IHNob3VsZCBOT1QgYmUgb3ZlcnJpZGRlbiBieSB0aGUgY2FsbGJhY2tzIG9iamVjdC5cbiAgICAgIGNvbnN0IHByb3RlY3RlZFByb3BzID0gbmV3IFNldChbXG4gICAgICAgIFwiZWxcIixcbiAgICAgICAgXCJsaXZlU29ja2V0XCIsXG4gICAgICAgIFwiX192aWV3XCIsXG4gICAgICAgIFwiX19saXN0ZW5lcnNcIixcbiAgICAgICAgXCJfX2lzRGlzY29ubmVjdGVkXCIsXG4gICAgICAgIFwiY29uc3RydWN0b3JcIiwgLy8gU3RhbmRhcmQgb2JqZWN0IHByb3BlcnRpZXNcbiAgICAgICAgLy8gQ29yZSBWaWV3SG9vayBBUEkgbWV0aG9kc1xuICAgICAgICBcImpzXCIsXG4gICAgICAgIFwicHVzaEV2ZW50XCIsXG4gICAgICAgIFwicHVzaEV2ZW50VG9cIixcbiAgICAgICAgXCJoYW5kbGVFdmVudFwiLFxuICAgICAgICBcInJlbW92ZUhhbmRsZUV2ZW50XCIsXG4gICAgICAgIFwidXBsb2FkXCIsXG4gICAgICAgIFwidXBsb2FkVG9cIixcbiAgICAgICAgLy8gSW50ZXJuYWwgbGlmZWN5Y2xlIGNhbGxlcnNcbiAgICAgICAgXCJfX21vdW50ZWRcIixcbiAgICAgICAgXCJfX3VwZGF0ZWRcIixcbiAgICAgICAgXCJfX2JlZm9yZVVwZGF0ZVwiLFxuICAgICAgICBcIl9fZGVzdHJveWVkXCIsXG4gICAgICAgIFwiX19yZWNvbm5lY3RlZFwiLFxuICAgICAgICBcIl9fZGlzY29ubmVjdGVkXCIsXG4gICAgICAgIFwiX19jbGVhbnVwX19cIixcbiAgICAgIF0pO1xuXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBjYWxsYmFja3MpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjYWxsYmFja3MsIGtleSkpIHtcbiAgICAgICAgICAodGhpcyBhcyBhbnkpW2tleV0gPSBjYWxsYmFja3Nba2V5XTtcbiAgICAgICAgICAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIHdlIGFsbG93IHRoZSBvdmVyd3JpdGUsIGJ1dCB3ZSBsb2cgYSB3YXJuaW5nXG4gICAgICAgICAgaWYgKHByb3RlY3RlZFByb3BzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIGBIb29rIG9iamVjdCBmb3IgZWxlbWVudCAjJHtlbC5pZH0gb3ZlcndyaXRlcyBjb3JlIHByb3BlcnR5ICcke2tleX0nIWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBsaWZlY3ljbGVNZXRob2RzOiAoa2V5b2YgSG9vaylbXSA9IFtcbiAgICAgICAgXCJtb3VudGVkXCIsXG4gICAgICAgIFwiYmVmb3JlVXBkYXRlXCIsXG4gICAgICAgIFwidXBkYXRlZFwiLFxuICAgICAgICBcImRlc3Ryb3llZFwiLFxuICAgICAgICBcImRpc2Nvbm5lY3RlZFwiLFxuICAgICAgICBcInJlY29ubmVjdGVkXCIsXG4gICAgICBdO1xuICAgICAgbGlmZWN5Y2xlTWV0aG9kcy5mb3JFYWNoKChtZXRob2ROYW1lKSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjYWxsYmFja3NbbWV0aG9kTmFtZV0gJiZcbiAgICAgICAgICB0eXBlb2YgY2FsbGJhY2tzW21ldGhvZE5hbWVdID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgKHRoaXMgYXMgYW55KVttZXRob2ROYW1lXSA9IGNhbGxiYWNrc1ttZXRob2ROYW1lXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIElmICdjYWxsYmFja3MnIGlzIG5vdCBwcm92aWRlZCwgdGhpcyBpcyBhbiBpbnN0YW5jZSBvZiBhIHVzZXItZGVmaW5lZCBjbGFzcyAoZS5nLiwgTXlIb29rKS5cbiAgICAvLyBJdHMgbWV0aG9kcyAobW91bnRlZCwgdXBkYXRlZCwgY3VzdG9tKSBhcmUgYWxyZWFkeSBwYXJ0IG9mIGl0cyBwcm90b3R5cGUgb3IgaW5zdGFuY2UsXG4gICAgLy8gYW5kIHdpbGwgY29ycmVjdGx5IG92ZXJyaWRlIHRoZSBkZWZhdWx0cyBmcm9tIFZpZXdIb29rLnByb3RvdHlwZS5cbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX19hdHRhY2hWaWV3KHZpZXc6IFZpZXcgfCBudWxsKSB7XG4gICAgaWYgKHZpZXcpIHtcbiAgICAgIHRoaXMuX192aWV3ID0gKCkgPT4gdmlldztcbiAgICAgIHRoaXMuX19saXZlU29ja2V0ID0gKCkgPT4gdmlldy5saXZlU29ja2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9fdmlldyA9ICgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBob29rIG5vdCB5ZXQgYXR0YWNoZWQgdG8gYSBsaXZlIHZpZXc6ICR7dGhpcy5lbC5vdXRlckhUTUx9YCxcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgICB0aGlzLl9fbGl2ZVNvY2tldCA9ICgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBob29rIG5vdCB5ZXQgYXR0YWNoZWQgdG8gYSBsaXZlIHZpZXc6ICR7dGhpcy5lbC5vdXRlckhUTUx9YCxcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLy8gRGVmYXVsdCBsaWZlY3ljbGUgbWV0aG9kc1xuICBtb3VudGVkKCk6IHZvaWQge31cbiAgYmVmb3JlVXBkYXRlKCk6IHZvaWQge31cbiAgdXBkYXRlZCgpOiB2b2lkIHt9XG4gIGRlc3Ryb3llZCgpOiB2b2lkIHt9XG4gIGRpc2Nvbm5lY3RlZCgpOiB2b2lkIHt9XG4gIHJlY29ubmVjdGVkKCk6IHZvaWQge31cblxuICAvLyBJbnRlcm5hbCBsaWZlY3ljbGUgY2FsbGVycyAtIGNhbGxlZCBieSB0aGUgVmlld1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX19tb3VudGVkKCkge1xuICAgIHRoaXMubW91bnRlZCgpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX191cGRhdGVkKCkge1xuICAgIHRoaXMudXBkYXRlZCgpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX19iZWZvcmVVcGRhdGUoKSB7XG4gICAgdGhpcy5iZWZvcmVVcGRhdGUoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9fZGVzdHJveWVkKCkge1xuICAgIHRoaXMuZGVzdHJveWVkKCk7XG4gICAgRE9NLmRlbGV0ZVByaXZhdGUodGhpcy5lbCwgSE9PS19JRCk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXhfbGl2ZV92aWV3L2lzc3Vlcy8zNDk2XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfX3JlY29ubmVjdGVkKCkge1xuICAgIGlmICh0aGlzLl9faXNEaXNjb25uZWN0ZWQpIHtcbiAgICAgIHRoaXMuX19pc0Rpc2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5yZWNvbm5lY3RlZCgpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9fZGlzY29ubmVjdGVkKCkge1xuICAgIHRoaXMuX19pc0Rpc2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgdGhpcy5kaXNjb25uZWN0ZWQoKTtcbiAgfVxuXG4gIGpzKCk6IEhvb2tKU0NvbW1hbmRzIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uanNDb21tYW5kcyh0aGlzLl9fdmlldygpLmxpdmVTb2NrZXQsIFwiaG9va1wiKSxcbiAgICAgIGV4ZWM6IChlbmNvZGVkSlM6IHN0cmluZykgPT4ge1xuICAgICAgICB0aGlzLl9fdmlldygpLmxpdmVTb2NrZXQuZXhlY0pTKHRoaXMuZWwsIGVuY29kZWRKUywgXCJob29rXCIpO1xuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgcHVzaEV2ZW50KGV2ZW50OiBzdHJpbmcsIHBheWxvYWQ6IGFueSwgb25SZXBseTogT25SZXBseSk6IHZvaWQ7XG4gIHB1c2hFdmVudChldmVudDogc3RyaW5nLCBwYXlsb2FkPzogYW55KTogUHJvbWlzZTxhbnk+O1xuICBwdXNoRXZlbnQoXG4gICAgZXZlbnQ6IHN0cmluZyxcbiAgICBwYXlsb2FkPzogYW55LFxuICAgIG9uUmVwbHk/OiBPblJlcGx5LFxuICApOiBQcm9taXNlPGFueT4gfCB2b2lkIHtcbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5fX3ZpZXcoKS5wdXNoSG9va0V2ZW50KFxuICAgICAgdGhpcy5lbCxcbiAgICAgIG51bGwsXG4gICAgICBldmVudCxcbiAgICAgIHBheWxvYWQgfHwge30sXG4gICAgKTtcbiAgICBpZiAob25SZXBseSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZS50aGVuKCh7IHJlcGx5IH06IHsgcmVwbHk6IGFueSB9KSA9PiByZXBseSk7XG4gICAgfVxuICAgIHByb21pc2VcbiAgICAgIC50aGVuKCh7IHJlcGx5LCByZWYgfTogeyByZXBseTogYW55OyByZWY6IG51bWJlciB9KSA9PlxuICAgICAgICBvblJlcGx5KHJlcGx5LCByZWYpLFxuICAgICAgKVxuICAgICAgLmNhdGNoKCgpID0+IHt9KTtcbiAgfVxuXG4gIHB1c2hFdmVudFRvKFxuICAgIHNlbGVjdG9yT3JUYXJnZXQ6IFBoeFRhcmdldCxcbiAgICBldmVudDogc3RyaW5nLFxuICAgIHBheWxvYWQ6IG9iamVjdCxcbiAgICBvblJlcGx5OiBPblJlcGx5LFxuICApOiB2b2lkO1xuICBwdXNoRXZlbnRUbyhcbiAgICBzZWxlY3Rvck9yVGFyZ2V0OiBQaHhUYXJnZXQsXG4gICAgZXZlbnQ6IHN0cmluZyxcbiAgICBwYXlsb2FkPzogb2JqZWN0LFxuICApOiBQcm9taXNlPFByb21pc2VTZXR0bGVkUmVzdWx0PHsgcmVwbHk6IGFueTsgcmVmOiBudW1iZXIgfT5bXT47XG4gIHB1c2hFdmVudFRvKFxuICAgIHNlbGVjdG9yT3JUYXJnZXQ6IFBoeFRhcmdldCxcbiAgICBldmVudDogc3RyaW5nLFxuICAgIHBheWxvYWQ/OiBvYmplY3QsXG4gICAgb25SZXBseT86IE9uUmVwbHksXG4gICk6IFByb21pc2U8UHJvbWlzZVNldHRsZWRSZXN1bHQ8eyByZXBseTogYW55OyByZWY6IG51bWJlciB9PltdPiB8IHZvaWQge1xuICAgIGlmIChvblJlcGx5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHRhcmdldFBhaXI6IHsgdmlldzogVmlldzsgdGFyZ2V0Q3R4OiBhbnkgfVtdID0gW107XG4gICAgICB0aGlzLl9fdmlldygpLndpdGhpblRhcmdldHMoXG4gICAgICAgIHNlbGVjdG9yT3JUYXJnZXQsXG4gICAgICAgICh2aWV3OiBWaWV3LCB0YXJnZXRDdHg6IGFueSkgPT4ge1xuICAgICAgICAgIHRhcmdldFBhaXIucHVzaCh7IHZpZXcsIHRhcmdldEN0eCB9KTtcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgICBjb25zdCBwcm9taXNlcyA9IHRhcmdldFBhaXIubWFwKCh7IHZpZXcsIHRhcmdldEN0eCB9KSA9PiB7XG4gICAgICAgIHJldHVybiB2aWV3LnB1c2hIb29rRXZlbnQodGhpcy5lbCwgdGFyZ2V0Q3R4LCBldmVudCwgcGF5bG9hZCB8fCB7fSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbFNldHRsZWQocHJvbWlzZXMpO1xuICAgIH1cbiAgICB0aGlzLl9fdmlldygpLndpdGhpblRhcmdldHMoXG4gICAgICBzZWxlY3Rvck9yVGFyZ2V0LFxuICAgICAgKHZpZXc6IFZpZXcsIHRhcmdldEN0eDogYW55KSA9PiB7XG4gICAgICAgIHZpZXdcbiAgICAgICAgICAucHVzaEhvb2tFdmVudCh0aGlzLmVsLCB0YXJnZXRDdHgsIGV2ZW50LCBwYXlsb2FkIHx8IHt9KVxuICAgICAgICAgIC50aGVuKCh7IHJlcGx5LCByZWYgfTogeyByZXBseTogYW55OyByZWY6IG51bWJlciB9KSA9PlxuICAgICAgICAgICAgb25SZXBseShyZXBseSwgcmVmKSxcbiAgICAgICAgICApXG4gICAgICAgICAgLmNhdGNoKCgpID0+IHt9KTtcbiAgICAgIH0sXG4gICAgKTtcbiAgfVxuXG4gIGhhbmRsZUV2ZW50KGV2ZW50OiBzdHJpbmcsIGNhbGxiYWNrOiAocGF5bG9hZDogYW55KSA9PiBhbnkpOiBDYWxsYmFja1JlZiB7XG4gICAgY29uc3QgY2FsbGJhY2tSZWY6IENhbGxiYWNrUmVmID0ge1xuICAgICAgZXZlbnQsXG4gICAgICBjYWxsYmFjazogKGN1c3RvbUV2ZW50OiBDdXN0b21FdmVudCkgPT4gY2FsbGJhY2soY3VzdG9tRXZlbnQuZGV0YWlsKSxcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgYHBoeDoke2V2ZW50fWAsXG4gICAgICBjYWxsYmFja1JlZi5jYWxsYmFjayBhcyBFdmVudExpc3RlbmVyLFxuICAgICk7XG4gICAgdGhpcy5fX2xpc3RlbmVycy5hZGQoY2FsbGJhY2tSZWYpO1xuICAgIHJldHVybiBjYWxsYmFja1JlZjtcbiAgfVxuXG4gIHJlbW92ZUhhbmRsZUV2ZW50KHJlZjogQ2FsbGJhY2tSZWYpOiB2b2lkIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgIGBwaHg6JHtyZWYuZXZlbnR9YCxcbiAgICAgIHJlZi5jYWxsYmFjayBhcyBFdmVudExpc3RlbmVyLFxuICAgICk7XG4gICAgdGhpcy5fX2xpc3RlbmVycy5kZWxldGUocmVmKTtcbiAgfVxuXG4gIHVwbG9hZChuYW1lOiBzdHJpbmcsIGZpbGVzOiBGaWxlTGlzdCk6IGFueSB7XG4gICAgcmV0dXJuIHRoaXMuX192aWV3KCkuZGlzcGF0Y2hVcGxvYWRzKG51bGwsIG5hbWUsIGZpbGVzKTtcbiAgfVxuXG4gIHVwbG9hZFRvKHNlbGVjdG9yT3JUYXJnZXQ6IFBoeFRhcmdldCwgbmFtZTogc3RyaW5nLCBmaWxlczogRmlsZUxpc3QpOiBhbnkge1xuICAgIHJldHVybiB0aGlzLl9fdmlldygpLndpdGhpblRhcmdldHMoXG4gICAgICBzZWxlY3Rvck9yVGFyZ2V0LFxuICAgICAgKHZpZXc6IFZpZXcsIHRhcmdldEN0eDogYW55KSA9PiB7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2hVcGxvYWRzKHRhcmdldEN0eCwgbmFtZSwgZmlsZXMpO1xuICAgICAgfSxcbiAgICApO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfX2NsZWFudXBfXygpIHtcbiAgICB0aGlzLl9fbGlzdGVuZXJzLmZvckVhY2goKGNhbGxiYWNrUmVmKSA9PlxuICAgICAgdGhpcy5yZW1vdmVIYW5kbGVFdmVudChjYWxsYmFja1JlZiksXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBIb29rc09wdGlvbnMgPSBSZWNvcmQ8c3RyaW5nLCB0eXBlb2YgVmlld0hvb2sgfCBIb29rPGFueSwgYW55Pj47XG5cbmV4cG9ydCBkZWZhdWx0IFZpZXdIb29rO1xuIiwgImltcG9ydCB7XG4gIEJFRk9SRV9VTkxPQURfTE9BREVSX1RJTUVPVVQsXG4gIENIRUNLQUJMRV9JTlBVVFMsXG4gIENPTlNFQ1VUSVZFX1JFTE9BRFMsXG4gIFBIWF9BVVRPX1JFQ09WRVIsXG4gIFBIWF9DT01QT05FTlQsXG4gIFBIWF9WSUVXX1JFRixcbiAgUEhYX0NPTk5FQ1RFRF9DTEFTUyxcbiAgUEhYX0RJU0FCTEVfV0lUSCxcbiAgUEhYX0RJU0FCTEVfV0lUSF9SRVNUT1JFLFxuICBQSFhfRElTQUJMRUQsXG4gIFBIWF9MT0FESU5HX0NMQVNTLFxuICBQSFhfRVJST1JfQ0xBU1MsXG4gIFBIWF9DTElFTlRfRVJST1JfQ0xBU1MsXG4gIFBIWF9TRVJWRVJfRVJST1JfQ0xBU1MsXG4gIFBIWF9IQVNfRk9DVVNFRCxcbiAgUEhYX0hBU19TVUJNSVRURUQsXG4gIFBIWF9IT09LLFxuICBQSFhfUEFSRU5UX0lELFxuICBQSFhfUFJPR1JFU1MsXG4gIFBIWF9SRUFET05MWSxcbiAgUEhYX1JFRl9MT0FESU5HLFxuICBQSFhfUkVGX1NSQyxcbiAgUEhYX1JFRl9MT0NLLFxuICBQSFhfUk9PVF9JRCxcbiAgUEhYX1NFU1NJT04sXG4gIFBIWF9TVEFUSUMsXG4gIFBIWF9TVElDS1ksXG4gIFBIWF9UUkFDS19TVEFUSUMsXG4gIFBIWF9UUkFDS19VUExPQURTLFxuICBQSFhfVVBEQVRFLFxuICBQSFhfVVBMT0FEX1JFRixcbiAgUEhYX1ZJRVdfU0VMRUNUT1IsXG4gIFBIWF9NQUlOLFxuICBQSFhfTU9VTlRFRCxcbiAgUFVTSF9USU1FT1VULFxuICBQSFhfVklFV1BPUlRfVE9QLFxuICBQSFhfVklFV1BPUlRfQk9UVE9NLFxuICBNQVhfQ0hJTERfSk9JTl9BVFRFTVBUUyxcbiAgUEhYX0xWX1BJRCxcbiAgUEhYX1BPUlRBTCxcbiAgUEhYX1RFTEVQT1JURURfUkVGLFxuICBQSFhfVEVMRVBPUlRFRF9TUkMsXG59IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuXG5pbXBvcnQge1xuICBjbG9uZSxcbiAgY2xvc2VzdFBoeEJpbmRpbmcsXG4gIGlzRW1wdHksXG4gIGlzRXF1YWxPYmosXG4gIGxvZ0Vycm9yLFxuICBtYXliZSxcbiAgaXNDaWQsXG59IGZyb20gXCIuL3V0aWxzXCI7XG5cbmltcG9ydCBCcm93c2VyIGZyb20gXCIuL2Jyb3dzZXJcIjtcbmltcG9ydCBET00gZnJvbSBcIi4vZG9tXCI7XG5pbXBvcnQgRWxlbWVudFJlZiBmcm9tIFwiLi9lbGVtZW50X3JlZlwiO1xuaW1wb3J0IERPTVBhdGNoIGZyb20gXCIuL2RvbV9wYXRjaFwiO1xuaW1wb3J0IExpdmVVcGxvYWRlciBmcm9tIFwiLi9saXZlX3VwbG9hZGVyXCI7XG5pbXBvcnQgUmVuZGVyZWQgZnJvbSBcIi4vcmVuZGVyZWRcIjtcbmltcG9ydCB7IFZpZXdIb29rIH0gZnJvbSBcIi4vdmlld19ob29rXCI7XG5pbXBvcnQgSlMgZnJvbSBcIi4vanNcIjtcblxuaW1wb3J0IG1vcnBoZG9tIGZyb20gXCJtb3JwaGRvbVwiO1xuXG5leHBvcnQgY29uc3QgcHJlcGVuZEZvcm1EYXRhS2V5ID0gKGtleSwgcHJlZml4KSA9PiB7XG4gIGNvbnN0IGlzQXJyYXkgPSBrZXkuZW5kc1dpdGgoXCJbXVwiKTtcbiAgLy8gUmVtb3ZlIHRoZSBcIltdXCIgaWYgaXQncyBhbiBhcnJheVxuICBsZXQgYmFzZUtleSA9IGlzQXJyYXkgPyBrZXkuc2xpY2UoMCwgLTIpIDoga2V5O1xuICAvLyBSZXBsYWNlIGxhc3Qgb2NjdXJyZW5jZSBvZiBrZXkgYmVmb3JlIGEgY2xvc2luZyBicmFja2V0IG9yIHRoZSBlbmQgd2l0aCBrZXkgcGx1cyBzdWZmaXhcbiAgYmFzZUtleSA9IGJhc2VLZXkucmVwbGFjZSgvKFteXFxbXFxdXSspKFxcXT8kKS8sIGAke3ByZWZpeH0kMSQyYCk7XG4gIC8vIEFkZCBiYWNrIHRoZSBcIltdXCIgaWYgaXQgd2FzIGFuIGFycmF5XG4gIGlmIChpc0FycmF5KSB7XG4gICAgYmFzZUtleSArPSBcIltdXCI7XG4gIH1cbiAgcmV0dXJuIGJhc2VLZXk7XG59O1xuXG5jb25zdCBzZXJpYWxpemVGb3JtID0gKGZvcm0sIG9wdHMsIG9ubHlOYW1lcyA9IFtdKSA9PiB7XG4gIGNvbnN0IHsgc3VibWl0dGVyIH0gPSBvcHRzO1xuXG4gIC8vIFdlIG11c3QgaW5qZWN0IHRoZSBzdWJtaXR0ZXIgaW4gdGhlIG9yZGVyIHRoYXQgaXQgZXhpc3RzIGluIHRoZSBET01cbiAgLy8gcmVsYXRpdmUgdG8gb3RoZXIgaW5wdXRzLiBGb3IgZXhhbXBsZSwgZm9yIGNoZWNrYm94IGdyb3VwcywgdGhlIG9yZGVyIG11c3QgYmUgbWFpbnRhaW5lZC5cbiAgbGV0IGluamVjdGVkRWxlbWVudDtcbiAgaWYgKHN1Ym1pdHRlciAmJiBzdWJtaXR0ZXIubmFtZSkge1xuICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIGlucHV0LnR5cGUgPSBcImhpZGRlblwiO1xuICAgIC8vIHNldCB0aGUgZm9ybSBhdHRyaWJ1dGUgaWYgdGhlIHN1Ym1pdHRlciBoYXMgb25lO1xuICAgIC8vIHRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgZWxlbWVudCBpcyBvdXRzaWRlIHRoZSBhY3R1YWwgZm9ybSBlbGVtZW50XG4gICAgY29uc3QgZm9ybUlkID0gc3VibWl0dGVyLmdldEF0dHJpYnV0ZShcImZvcm1cIik7XG4gICAgaWYgKGZvcm1JZCkge1xuICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwiZm9ybVwiLCBmb3JtSWQpO1xuICAgIH1cbiAgICBpbnB1dC5uYW1lID0gc3VibWl0dGVyLm5hbWU7XG4gICAgaW5wdXQudmFsdWUgPSBzdWJtaXR0ZXIudmFsdWU7XG4gICAgc3VibWl0dGVyLnBhcmVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKGlucHV0LCBzdWJtaXR0ZXIpO1xuICAgIGluamVjdGVkRWxlbWVudCA9IGlucHV0O1xuICB9XG5cbiAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoZm9ybSk7XG4gIGNvbnN0IHRvUmVtb3ZlID0gW107XG5cbiAgZm9ybURhdGEuZm9yRWFjaCgodmFsLCBrZXksIF9pbmRleCkgPT4ge1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICB0b1JlbW92ZS5wdXNoKGtleSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBDbGVhbnVwIGFmdGVyIGJ1aWxkaW5nIGZpbGVEYXRhXG4gIHRvUmVtb3ZlLmZvckVhY2goKGtleSkgPT4gZm9ybURhdGEuZGVsZXRlKGtleSkpO1xuXG4gIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcblxuICBjb25zdCB7IGlucHV0c1VudXNlZCwgb25seUhpZGRlbklucHV0cyB9ID0gQXJyYXkuZnJvbShmb3JtLmVsZW1lbnRzKS5yZWR1Y2UoXG4gICAgKGFjYywgaW5wdXQpID0+IHtcbiAgICAgIGNvbnN0IHsgaW5wdXRzVW51c2VkLCBvbmx5SGlkZGVuSW5wdXRzIH0gPSBhY2M7XG4gICAgICBjb25zdCBrZXkgPSBpbnB1dC5uYW1lO1xuICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cblxuICAgICAgaWYgKGlucHV0c1VudXNlZFtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5wdXRzVW51c2VkW2tleV0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKG9ubHlIaWRkZW5JbnB1dHNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9ubHlIaWRkZW5JbnB1dHNba2V5XSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzVXNlZCA9XG4gICAgICAgIERPTS5wcml2YXRlKGlucHV0LCBQSFhfSEFTX0ZPQ1VTRUQpIHx8XG4gICAgICAgIERPTS5wcml2YXRlKGlucHV0LCBQSFhfSEFTX1NVQk1JVFRFRCk7XG4gICAgICBjb25zdCBpc0hpZGRlbiA9IGlucHV0LnR5cGUgPT09IFwiaGlkZGVuXCI7XG4gICAgICBpbnB1dHNVbnVzZWRba2V5XSA9IGlucHV0c1VudXNlZFtrZXldICYmICFpc1VzZWQ7XG4gICAgICBvbmx5SGlkZGVuSW5wdXRzW2tleV0gPSBvbmx5SGlkZGVuSW5wdXRzW2tleV0gJiYgaXNIaWRkZW47XG5cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSxcbiAgICB7IGlucHV0c1VudXNlZDoge30sIG9ubHlIaWRkZW5JbnB1dHM6IHt9IH0sXG4gICk7XG5cbiAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIGZvcm1EYXRhLmVudHJpZXMoKSkge1xuICAgIGlmIChvbmx5TmFtZXMubGVuZ3RoID09PSAwIHx8IG9ubHlOYW1lcy5pbmRleE9mKGtleSkgPj0gMCkge1xuICAgICAgY29uc3QgaXNVbnVzZWQgPSBpbnB1dHNVbnVzZWRba2V5XTtcbiAgICAgIGNvbnN0IGhpZGRlbiA9IG9ubHlIaWRkZW5JbnB1dHNba2V5XTtcbiAgICAgIGlmIChpc1VudXNlZCAmJiAhKHN1Ym1pdHRlciAmJiBzdWJtaXR0ZXIubmFtZSA9PSBrZXkpICYmICFoaWRkZW4pIHtcbiAgICAgICAgcGFyYW1zLmFwcGVuZChwcmVwZW5kRm9ybURhdGFLZXkoa2V5LCBcIl91bnVzZWRfXCIpLCBcIlwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHBhcmFtcy5hcHBlbmQoa2V5LCB2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHJlbW92ZSB0aGUgaW5qZWN0ZWQgZWxlbWVudCBhZ2FpblxuICAvLyAoaXQgd291bGQgYmUgcmVtb3ZlZCBieSB0aGUgbmV4dCBkb20gcGF0Y2ggYW55d2F5LCBidXQgdGhpcyBpcyBjbGVhbmVyKVxuICBpZiAoc3VibWl0dGVyICYmIGluamVjdGVkRWxlbWVudCkge1xuICAgIHN1Ym1pdHRlci5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGluamVjdGVkRWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gcGFyYW1zLnRvU3RyaW5nKCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaWV3IHtcbiAgc3RhdGljIGNsb3Nlc3RWaWV3KGVsKSB7XG4gICAgY29uc3QgbGl2ZVZpZXdFbCA9IGVsLmNsb3Nlc3QoUEhYX1ZJRVdfU0VMRUNUT1IpO1xuICAgIHJldHVybiBsaXZlVmlld0VsID8gRE9NLnByaXZhdGUobGl2ZVZpZXdFbCwgXCJ2aWV3XCIpIDogbnVsbDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGVsLCBsaXZlU29ja2V0LCBwYXJlbnRWaWV3LCBmbGFzaCwgbGl2ZVJlZmVyZXIpIHtcbiAgICB0aGlzLmlzRGVhZCA9IGZhbHNlO1xuICAgIHRoaXMubGl2ZVNvY2tldCA9IGxpdmVTb2NrZXQ7XG4gICAgdGhpcy5mbGFzaCA9IGZsYXNoO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50VmlldztcbiAgICB0aGlzLnJvb3QgPSBwYXJlbnRWaWV3ID8gcGFyZW50Vmlldy5yb290IDogdGhpcztcbiAgICB0aGlzLmVsID0gZWw7XG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXhfbGl2ZV92aWV3L3B1bGwvMzcyMVxuICAgIC8vIGNoZWNrIGlmIHRoZSBlbGVtZW50IGlzIGFscmVhZHkgYm91bmQgdG8gYSB2aWV3XG4gICAgY29uc3QgYm91bmRWaWV3ID0gRE9NLnByaXZhdGUodGhpcy5lbCwgXCJ2aWV3XCIpO1xuICAgIGlmIChib3VuZFZpZXcgIT09IHVuZGVmaW5lZCAmJiBib3VuZFZpZXcuaXNEZWFkICE9PSB0cnVlKSB7XG4gICAgICBsb2dFcnJvcihcbiAgICAgICAgYFRoZSBET00gZWxlbWVudCBmb3IgdGhpcyB2aWV3IGhhcyBhbHJlYWR5IGJlZW4gYm91bmQgdG8gYSB2aWV3LlxuXG4gICAgICAgIEFuIGVsZW1lbnQgY2FuIG9ubHkgZXZlciBiZSBhc3NvY2lhdGVkIHdpdGggYSBzaW5nbGUgdmlldyFcbiAgICAgICAgUGxlYXNlIGVuc3VyZSB0aGF0IHlvdSBhcmUgbm90IHRyeWluZyB0byBpbml0aWFsaXplIG11bHRpcGxlIExpdmVTb2NrZXRzIG9uIHRoZSBzYW1lIHBhZ2UuXG4gICAgICAgIFRoaXMgY291bGQgaGFwcGVuIGlmIHlvdSdyZSBhY2NpZGVudGFsbHkgdHJ5aW5nIHRvIHJlbmRlciB5b3VyIHJvb3QgbGF5b3V0IG1vcmUgdGhhbiBvbmNlLlxuICAgICAgICBFbnN1cmUgdGhhdCB0aGUgdGVtcGxhdGUgc2V0IG9uIHRoZSBMaXZlVmlldyBpcyBkaWZmZXJlbnQgdGhhbiB0aGUgcm9vdCBsYXlvdXQuXG4gICAgICBgLFxuICAgICAgICB7IHZpZXc6IGJvdW5kVmlldyB9LFxuICAgICAgKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBiaW5kIG11bHRpcGxlIHZpZXdzIHRvIHRoZSBzYW1lIERPTSBlbGVtZW50LlwiKTtcbiAgICB9XG4gICAgLy8gYmluZCB0aGUgdmlldyB0byB0aGUgZWxlbWVudFxuICAgIERPTS5wdXRQcml2YXRlKHRoaXMuZWwsIFwidmlld1wiLCB0aGlzKTtcbiAgICB0aGlzLmlkID0gdGhpcy5lbC5pZDtcbiAgICB0aGlzLnJlZiA9IDA7XG4gICAgdGhpcy5sYXN0QWNrUmVmID0gbnVsbDtcbiAgICB0aGlzLmNoaWxkSm9pbnMgPSAwO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0PiB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5sb2FkZXJUaW1lciA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1JldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+IHwgbnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmRpc2Nvbm5lY3RlZFRpbWVyID0gbnVsbDtcbiAgICB0aGlzLnBlbmRpbmdEaWZmcyA9IFtdO1xuICAgIHRoaXMucGVuZGluZ0Zvcm1zID0gbmV3IFNldCgpO1xuICAgIHRoaXMucmVkaXJlY3QgPSBmYWxzZTtcbiAgICB0aGlzLmhyZWYgPSBudWxsO1xuICAgIHRoaXMuam9pbkNvdW50ID0gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5qb2luQ291bnQgLSAxIDogMDtcbiAgICB0aGlzLmpvaW5BdHRlbXB0cyA9IDA7XG4gICAgdGhpcy5qb2luUGVuZGluZyA9IHRydWU7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmpvaW5DYWxsYmFjayA9IGZ1bmN0aW9uIChvbkRvbmUpIHtcbiAgICAgIG9uRG9uZSAmJiBvbkRvbmUoKTtcbiAgICB9O1xuICAgIHRoaXMuc3RvcENhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgLy8gdXN1YWxseSwgb25seSB0aGUgcm9vdCBMaXZlVmlldyBzdG9yZXMgcGVuZGluZ1xuICAgIC8vIGpvaW4gb3BlcmF0aW9ucyBmb3IgYWxsIGNoaWxkcmVuIChhbmQgaXRzZWxmKSxcbiAgICAvLyBidXQgaW4gY2FzZSBvZiByZWpvaW5zIChqb2luQ291bnQgPiAxKSBlYWNoIGNoaWxkXG4gICAgLy8gc3RvcmVzIGl0cyBvd24gZXZlbnRzIGluc3RlYWRcbiAgICB0aGlzLnBlbmRpbmdKb2luT3BzID0gW107XG4gICAgdGhpcy52aWV3SG9va3MgPSB7fTtcbiAgICB0aGlzLmZvcm1TdWJtaXRzID0gW107XG4gICAgdGhpcy5jaGlsZHJlbiA9IHRoaXMucGFyZW50ID8gbnVsbCA6IHt9O1xuICAgIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLmlkXSA9IHt9O1xuICAgIHRoaXMuZm9ybXNGb3JSZWNvdmVyeSA9IHt9O1xuICAgIHRoaXMuY2hhbm5lbCA9IHRoaXMubGl2ZVNvY2tldC5jaGFubmVsKGBsdjoke3RoaXMuaWR9YCwgKCkgPT4ge1xuICAgICAgY29uc3QgdXJsID0gdGhpcy5ocmVmICYmIHRoaXMuZXhwYW5kVVJMKHRoaXMuaHJlZik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWRpcmVjdDogdGhpcy5yZWRpcmVjdCA/IHVybCA6IHVuZGVmaW5lZCxcbiAgICAgICAgdXJsOiB0aGlzLnJlZGlyZWN0ID8gdW5kZWZpbmVkIDogdXJsIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgcGFyYW1zOiB0aGlzLmNvbm5lY3RQYXJhbXMobGl2ZVJlZmVyZXIpLFxuICAgICAgICBzZXNzaW9uOiB0aGlzLmdldFNlc3Npb24oKSxcbiAgICAgICAgc3RhdGljOiB0aGlzLmdldFN0YXRpYygpLFxuICAgICAgICBmbGFzaDogdGhpcy5mbGFzaCxcbiAgICAgICAgc3RpY2t5OiB0aGlzLmVsLmhhc0F0dHJpYnV0ZShQSFhfU1RJQ0tZKSxcbiAgICAgIH07XG4gICAgfSk7XG4gICAgdGhpcy5wb3J0YWxFbGVtZW50SWRzID0gbmV3IFNldCgpO1xuICB9XG5cbiAgc2V0SHJlZihocmVmKSB7XG4gICAgdGhpcy5ocmVmID0gaHJlZjtcbiAgfVxuXG4gIHNldFJlZGlyZWN0KGhyZWYpIHtcbiAgICB0aGlzLnJlZGlyZWN0ID0gdHJ1ZTtcbiAgICB0aGlzLmhyZWYgPSBocmVmO1xuICB9XG5cbiAgaXNNYWluKCkge1xuICAgIHJldHVybiB0aGlzLmVsLmhhc0F0dHJpYnV0ZShQSFhfTUFJTik7XG4gIH1cblxuICBjb25uZWN0UGFyYW1zKGxpdmVSZWZlcmVyKSB7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5saXZlU29ja2V0LnBhcmFtcyh0aGlzLmVsKTtcbiAgICBjb25zdCBtYW5pZmVzdCA9IERPTS5hbGwoZG9jdW1lbnQsIGBbJHt0aGlzLmJpbmRpbmcoUEhYX1RSQUNLX1NUQVRJQyl9XWApXG4gICAgICAubWFwKChub2RlKSA9PiBub2RlLnNyYyB8fCBub2RlLmhyZWYpXG4gICAgICAuZmlsdGVyKCh1cmwpID0+IHR5cGVvZiB1cmwgPT09IFwic3RyaW5nXCIpO1xuXG4gICAgaWYgKG1hbmlmZXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHBhcmFtc1tcIl90cmFja19zdGF0aWNcIl0gPSBtYW5pZmVzdDtcbiAgICB9XG4gICAgcGFyYW1zW1wiX21vdW50c1wiXSA9IHRoaXMuam9pbkNvdW50O1xuICAgIHBhcmFtc1tcIl9tb3VudF9hdHRlbXB0c1wiXSA9IHRoaXMuam9pbkF0dGVtcHRzO1xuICAgIHBhcmFtc1tcIl9saXZlX3JlZmVyZXJcIl0gPSBsaXZlUmVmZXJlcjtcbiAgICB0aGlzLmpvaW5BdHRlbXB0cysrO1xuXG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIGlzQ29ubmVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuY2FuUHVzaCgpO1xuICB9XG5cbiAgZ2V0U2Vzc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04pO1xuICB9XG5cbiAgZ2V0U3RhdGljKCkge1xuICAgIGNvbnN0IHZhbCA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9TVEFUSUMpO1xuICAgIHJldHVybiB2YWwgPT09IFwiXCIgPyBudWxsIDogdmFsO1xuICB9XG5cbiAgZGVzdHJveShjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9KSB7XG4gICAgdGhpcy5kZXN0cm95QWxsQ2hpbGRyZW4oKTtcbiAgICB0aGlzLmRlc3Ryb3lQb3J0YWxFbGVtZW50cygpO1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICBET00uZGVsZXRlUHJpdmF0ZSh0aGlzLmVsLCBcInZpZXdcIik7XG4gICAgZGVsZXRlIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLmlkXTtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5wYXJlbnQuaWRdW3RoaXMuaWRdO1xuICAgIH1cbiAgICBjbGVhclRpbWVvdXQodGhpcy5sb2FkZXJUaW1lcik7XG4gICAgY29uc3Qgb25GaW5pc2hlZCA9ICgpID0+IHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgICBmb3IgKGNvbnN0IGlkIGluIHRoaXMudmlld0hvb2tzKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveUhvb2sodGhpcy52aWV3SG9va3NbaWRdKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgRE9NLm1hcmtQaHhDaGlsZERlc3Ryb3llZCh0aGlzLmVsKTtcblxuICAgIHRoaXMubG9nKFwiZGVzdHJveWVkXCIsICgpID0+IFtcInRoZSBjaGlsZCBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIHBhcmVudFwiXSk7XG4gICAgdGhpcy5jaGFubmVsXG4gICAgICAubGVhdmUoKVxuICAgICAgLnJlY2VpdmUoXCJva1wiLCBvbkZpbmlzaGVkKVxuICAgICAgLnJlY2VpdmUoXCJlcnJvclwiLCBvbkZpbmlzaGVkKVxuICAgICAgLnJlY2VpdmUoXCJ0aW1lb3V0XCIsIG9uRmluaXNoZWQpO1xuICB9XG5cbiAgc2V0Q29udGFpbmVyQ2xhc3NlcyguLi5jbGFzc2VzKSB7XG4gICAgdGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgUEhYX0NPTk5FQ1RFRF9DTEFTUyxcbiAgICAgIFBIWF9MT0FESU5HX0NMQVNTLFxuICAgICAgUEhYX0VSUk9SX0NMQVNTLFxuICAgICAgUEhYX0NMSUVOVF9FUlJPUl9DTEFTUyxcbiAgICAgIFBIWF9TRVJWRVJfRVJST1JfQ0xBU1MsXG4gICAgKTtcbiAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoLi4uY2xhc3Nlcyk7XG4gIH1cblxuICBzaG93TG9hZGVyKHRpbWVvdXQpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5sb2FkZXJUaW1lcik7XG4gICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgIHRoaXMubG9hZGVyVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2hvd0xvYWRlcigpLCB0aW1lb3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBpZCBpbiB0aGlzLnZpZXdIb29rcykge1xuICAgICAgICB0aGlzLnZpZXdIb29rc1tpZF0uX19kaXNjb25uZWN0ZWQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0Q29udGFpbmVyQ2xhc3NlcyhQSFhfTE9BRElOR19DTEFTUyk7XG4gICAgfVxuICB9XG5cbiAgZXhlY0FsbChiaW5kaW5nKSB7XG4gICAgRE9NLmFsbCh0aGlzLmVsLCBgWyR7YmluZGluZ31dYCwgKGVsKSA9PlxuICAgICAgdGhpcy5saXZlU29ja2V0LmV4ZWNKUyhlbCwgZWwuZ2V0QXR0cmlidXRlKGJpbmRpbmcpKSxcbiAgICApO1xuICB9XG5cbiAgaGlkZUxvYWRlcigpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5sb2FkZXJUaW1lcik7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuZGlzY29ubmVjdGVkVGltZXIpO1xuICAgIHRoaXMuc2V0Q29udGFpbmVyQ2xhc3NlcyhQSFhfQ09OTkVDVEVEX0NMQVNTKTtcbiAgICB0aGlzLmV4ZWNBbGwodGhpcy5iaW5kaW5nKFwiY29ubmVjdGVkXCIpKTtcbiAgfVxuXG4gIHRyaWdnZXJSZWNvbm5lY3RlZCgpIHtcbiAgICBmb3IgKGNvbnN0IGlkIGluIHRoaXMudmlld0hvb2tzKSB7XG4gICAgICB0aGlzLnZpZXdIb29rc1tpZF0uX19yZWNvbm5lY3RlZCgpO1xuICAgIH1cbiAgfVxuXG4gIGxvZyhraW5kLCBtc2dDYWxsYmFjaykge1xuICAgIHRoaXMubGl2ZVNvY2tldC5sb2codGhpcywga2luZCwgbXNnQ2FsbGJhY2spO1xuICB9XG5cbiAgdHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUgPSBmdW5jdGlvbiAoKSB7fSkge1xuICAgIHRoaXMubGl2ZVNvY2tldC50cmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRG9uZSk7XG4gIH1cblxuICAvLyBjYWxscyB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgdmlldyBhbmQgdGFyZ2V0IGVsZW1lbnQgZm9yIHRoZSBnaXZlbiBwaHhUYXJnZXRcbiAgLy8gdGFyZ2V0cyBjYW4gYmU6XG4gIC8vICAqIGFuIGVsZW1lbnQgaXRzZWxmLCB0aGVuIGl0IGlzIHNpbXBseSBwYXNzZWQgdG8gbGl2ZVNvY2tldC5vd25lcjtcbiAgLy8gICogYSBDSUQgKENvbXBvbmVudCBJRCksIHRoZW4gd2UgZmlyc3Qgc2VhcmNoIHRoZSBjb21wb25lbnQncyBlbGVtZW50IGluIHRoZSBET01cbiAgLy8gICogYSBzZWxlY3RvciwgdGhlbiB3ZSBzZWFyY2ggdGhlIHNlbGVjdG9yIGluIHRoZSBET00gYW5kIGNhbGwgdGhlIGNhbGxiYWNrXG4gIC8vICAgIGZvciBlYWNoIGVsZW1lbnQgZm91bmQgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBvd25lciB2aWV3XG4gIHdpdGhpblRhcmdldHMocGh4VGFyZ2V0LCBjYWxsYmFjaywgZG9tID0gZG9jdW1lbnQpIHtcbiAgICAvLyBpbiB0aGUgZm9ybSByZWNvdmVyeSBjYXNlIHdlIHNlYXJjaCBpbiBhIHRlbXBsYXRlIGZyYWdtZW50IGluc3RlYWQgb2ZcbiAgICAvLyB0aGUgcmVhbCBkb20sIHRoZXJlZm9yZSB3ZSBvcHRpb25hbGx5IHBhc3MgZG9tIGFuZCB2aWV3RWxcblxuICAgIGlmIChwaHhUYXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCBwaHhUYXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5saXZlU29ja2V0Lm93bmVyKHBoeFRhcmdldCwgKHZpZXcpID0+XG4gICAgICAgIGNhbGxiYWNrKHZpZXcsIHBoeFRhcmdldCksXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChpc0NpZChwaHhUYXJnZXQpKSB7XG4gICAgICBjb25zdCB0YXJnZXRzID0gRE9NLmZpbmRDb21wb25lbnROb2RlTGlzdCh0aGlzLmlkLCBwaHhUYXJnZXQsIGRvbSk7XG4gICAgICBpZiAodGFyZ2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbG9nRXJyb3IoYG5vIGNvbXBvbmVudCBmb3VuZCBtYXRjaGluZyBwaHgtdGFyZ2V0IG9mICR7cGh4VGFyZ2V0fWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sodGhpcywgcGFyc2VJbnQocGh4VGFyZ2V0KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRhcmdldHMgPSBBcnJheS5mcm9tKGRvbS5xdWVyeVNlbGVjdG9yQWxsKHBoeFRhcmdldCkpO1xuICAgICAgaWYgKHRhcmdldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGxvZ0Vycm9yKFxuICAgICAgICAgIGBub3RoaW5nIGZvdW5kIG1hdGNoaW5nIHRoZSBwaHgtdGFyZ2V0IHNlbGVjdG9yIFwiJHtwaHhUYXJnZXR9XCJgLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGFyZ2V0cy5mb3JFYWNoKCh0YXJnZXQpID0+XG4gICAgICAgIHRoaXMubGl2ZVNvY2tldC5vd25lcih0YXJnZXQsICh2aWV3KSA9PiBjYWxsYmFjayh2aWV3LCB0YXJnZXQpKSxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgYXBwbHlEaWZmKHR5cGUsIHJhd0RpZmYsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5sb2codHlwZSwgKCkgPT4gW1wiXCIsIGNsb25lKHJhd0RpZmYpXSk7XG4gICAgY29uc3QgeyBkaWZmLCByZXBseSwgZXZlbnRzLCB0aXRsZSB9ID0gUmVuZGVyZWQuZXh0cmFjdChyYXdEaWZmKTtcblxuICAgIC8vIEV2ZW50cyBhcmUgZWl0aGVyIFtldmVudCwgcGF5bG9hZF0gb3IgW2V2ZW50LCBwYXlsb2FkLCB0cnVlXVxuICAgIC8vIHdoZXJlIHRoZSBvcHRpb25hbCB0aGlyZCBlbGVtZW50ICh0cnVlKSBpbmRpY2F0ZXMgdGhhdCB0aGUgZXZlbnQgc2hvdWxkXG4gICAgLy8gYmUgZGlzcGF0Y2hlZCBiZWZvcmUgdGhlIERPTSBwYXRjaC4gVGhpcyBpcyB1c2VmdWwgaW4gY29tYmluYXRpb24gd2l0aFxuICAgIC8vIHRoZSBvbkRvY3VtZW50UGF0Y2ggZG9tIGNhbGxiYWNrLlxuICAgIGNvbnN0IGV2ID0gZXZlbnRzLnJlZHVjZShcbiAgICAgIChhY2MsIGFyZ3MpID0+IHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAzICYmIGFyZ3NbMl0gPT0gdHJ1ZSkge1xuICAgICAgICAgIGFjYy5wcmUucHVzaChhcmdzLnNsaWNlKDAsIC0xKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWNjLnBvc3QucHVzaChhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSxcbiAgICAgIHsgcHJlOiBbXSwgcG9zdDogW10gfSxcbiAgICApO1xuXG4gICAgdGhpcy5saXZlU29ja2V0LmRpc3BhdGNoRXZlbnRzKGV2LnByZSk7XG5cbiAgICBjb25zdCB1cGRhdGUgPSAoKSA9PiB7XG4gICAgICBjYWxsYmFjayh7IGRpZmYsIHJlcGx5LCBldmVudHM6IGV2LnBvc3QgfSk7XG4gICAgICBpZiAodHlwZW9mIHRpdGxlID09PSBcInN0cmluZ1wiIHx8ICh0eXBlID09IFwibW91bnRcIiAmJiB0aGlzLmlzTWFpbigpKSkge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IERPTS5wdXRUaXRsZSh0aXRsZSkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoXCJvbkRvY3VtZW50UGF0Y2hcIiBpbiB0aGlzLmxpdmVTb2NrZXQuZG9tQ2FsbGJhY2tzKSB7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQudHJpZ2dlckRPTShcIm9uRG9jdW1lbnRQYXRjaFwiLCBbdXBkYXRlXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIG9uSm9pbihyZXNwKSB7XG4gICAgY29uc3QgeyByZW5kZXJlZCwgY29udGFpbmVyLCBsaXZldmlld192ZXJzaW9uLCBwaWQgfSA9IHJlc3A7XG4gICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgY29uc3QgW3RhZywgYXR0cnNdID0gY29udGFpbmVyO1xuICAgICAgdGhpcy5lbCA9IERPTS5yZXBsYWNlUm9vdENvbnRhaW5lcih0aGlzLmVsLCB0YWcsIGF0dHJzKTtcbiAgICB9XG4gICAgdGhpcy5jaGlsZEpvaW5zID0gMDtcbiAgICB0aGlzLmpvaW5QZW5kaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmZsYXNoID0gbnVsbDtcbiAgICBpZiAodGhpcy5yb290ID09PSB0aGlzKSB7XG4gICAgICB0aGlzLmZvcm1zRm9yUmVjb3ZlcnkgPSB0aGlzLmdldEZvcm1zRm9yUmVjb3ZlcnkoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNNYWluKCkgJiYgd2luZG93Lmhpc3Rvcnkuc3RhdGUgPT09IG51bGwpIHtcbiAgICAgIC8vIHNldCBpbml0aWFsIGhpc3RvcnkgZW50cnkgaWYgdGhpcyBpcyB0aGUgZmlyc3QgcGFnZSBsb2FkIChubyBoaXN0b3J5KVxuICAgICAgQnJvd3Nlci5wdXNoU3RhdGUoXCJyZXBsYWNlXCIsIHtcbiAgICAgICAgdHlwZTogXCJwYXRjaFwiLFxuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgcG9zaXRpb246IHRoaXMubGl2ZVNvY2tldC5jdXJyZW50SGlzdG9yeVBvc2l0aW9uLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGxpdmV2aWV3X3ZlcnNpb24gIT09IHRoaXMubGl2ZVNvY2tldC52ZXJzaW9uKCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYExpdmVWaWV3IGFzc2V0IHZlcnNpb24gbWlzbWF0Y2guIEphdmFTY3JpcHQgdmVyc2lvbiAke3RoaXMubGl2ZVNvY2tldC52ZXJzaW9uKCl9IHZzLiBzZXJ2ZXIgJHtsaXZldmlld192ZXJzaW9ufS4gVG8gYXZvaWQgaXNzdWVzLCBwbGVhc2UgZW5zdXJlIHRoYXQgeW91ciBhc3NldHMgdXNlIHRoZSBzYW1lIHZlcnNpb24gYXMgdGhlIHNlcnZlci5gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgcGlkIGlzIG9ubHkgc2VudCBpZlxuICAgIC8vXG4gICAgLy8gICAgY29uZmlnIDpwaG9lbml4X2xpdmVfdmlldywgOmRlYnVnX2F0dHJpYnV0ZXNcbiAgICAvL1xuICAgIC8vIGlmIHNldCB0byB0cnVlLiBJdCBpcyB0byBoZWxwIGRlYnVnZ2luZyBpbiBkZXZlbG9wbWVudC5cbiAgICBpZiAocGlkKSB7XG4gICAgICB0aGlzLmVsLnNldEF0dHJpYnV0ZShQSFhfTFZfUElELCBwaWQpO1xuICAgIH1cblxuICAgIEJyb3dzZXIuZHJvcExvY2FsKFxuICAgICAgdGhpcy5saXZlU29ja2V0LmxvY2FsU3RvcmFnZSxcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgIENPTlNFQ1VUSVZFX1JFTE9BRFMsXG4gICAgKTtcbiAgICB0aGlzLmFwcGx5RGlmZihcIm1vdW50XCIsIHJlbmRlcmVkLCAoeyBkaWZmLCBldmVudHMgfSkgPT4ge1xuICAgICAgdGhpcy5yZW5kZXJlZCA9IG5ldyBSZW5kZXJlZCh0aGlzLmlkLCBkaWZmKTtcbiAgICAgIGNvbnN0IFtodG1sLCBzdHJlYW1zXSA9IHRoaXMucmVuZGVyQ29udGFpbmVyKG51bGwsIFwiam9pblwiKTtcbiAgICAgIHRoaXMuZHJvcFBlbmRpbmdSZWZzKCk7XG4gICAgICB0aGlzLmpvaW5Db3VudCsrO1xuICAgICAgdGhpcy5qb2luQXR0ZW1wdHMgPSAwO1xuXG4gICAgICB0aGlzLm1heWJlUmVjb3ZlckZvcm1zKGh0bWwsICgpID0+IHtcbiAgICAgICAgdGhpcy5vbkpvaW5Db21wbGV0ZShyZXNwLCBodG1sLCBzdHJlYW1zLCBldmVudHMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBkcm9wUGVuZGluZ1JlZnMoKSB7XG4gICAgRE9NLmFsbChkb2N1bWVudCwgYFske1BIWF9SRUZfU1JDfT1cIiR7dGhpcy5yZWZTcmMoKX1cIl1gLCAoZWwpID0+IHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfUkVGX0xPQURJTkcpO1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9SRUZfU1JDKTtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfUkVGX0xPQ0spO1xuICAgIH0pO1xuICB9XG5cbiAgb25Kb2luQ29tcGxldGUoeyBsaXZlX3BhdGNoIH0sIGh0bWwsIHN0cmVhbXMsIGV2ZW50cykge1xuICAgIC8vIEluIG9yZGVyIHRvIHByb3ZpZGUgYSBiZXR0ZXIgZXhwZXJpZW5jZSwgd2Ugd2FudCB0byBqb2luXG4gICAgLy8gYWxsIExpdmVWaWV3cyBmaXJzdCBhbmQgb25seSB0aGVuIGFwcGx5IHRoZWlyIHBhdGNoZXMuXG4gICAgaWYgKHRoaXMuam9pbkNvdW50ID4gMSB8fCAodGhpcy5wYXJlbnQgJiYgIXRoaXMucGFyZW50LmlzSm9pblBlbmRpbmcoKSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmFwcGx5Sm9pblBhdGNoKGxpdmVfcGF0Y2gsIGh0bWwsIHN0cmVhbXMsIGV2ZW50cyk7XG4gICAgfVxuXG4gICAgLy8gT25lIGRvd25zaWRlIG9mIHRoaXMgYXBwcm9hY2ggaXMgdGhhdCB3ZSBuZWVkIHRvIGZpbmQgcGh4Q2hpbGRyZW5cbiAgICAvLyBpbiB0aGUgaHRtbCBmcmFnbWVudCwgaW5zdGVhZCBvZiBkaXJlY3RseSBvbiB0aGUgRE9NLiBUaGUgZnJhZ21lbnRcbiAgICAvLyBhbHNvIGRvZXMgbm90IGluY2x1ZGUgUEhYX1NUQVRJQywgc28gd2UgbmVlZCB0byBjb3B5IGl0IG92ZXIgZnJvbVxuICAgIC8vIHRoZSBET00uXG4gICAgY29uc3QgbmV3Q2hpbGRyZW4gPSBET00uZmluZFBoeENoaWxkcmVuSW5GcmFnbWVudChodG1sLCB0aGlzLmlkKS5maWx0ZXIoXG4gICAgICAodG9FbCkgPT4ge1xuICAgICAgICBjb25zdCBmcm9tRWwgPSB0b0VsLmlkICYmIHRoaXMuZWwucXVlcnlTZWxlY3RvcihgW2lkPVwiJHt0b0VsLmlkfVwiXWApO1xuICAgICAgICBjb25zdCBwaHhTdGF0aWMgPSBmcm9tRWwgJiYgZnJvbUVsLmdldEF0dHJpYnV0ZShQSFhfU1RBVElDKTtcbiAgICAgICAgaWYgKHBoeFN0YXRpYykge1xuICAgICAgICAgIHRvRWwuc2V0QXR0cmlidXRlKFBIWF9TVEFUSUMsIHBoeFN0YXRpYyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IFBIWF9ST09UX0lEIHRvIHByZXZlbnQgZXZlbnRzIGZyb20gYmVpbmcgZGlzcGF0Y2hlZCB0byB0aGUgcm9vdCB2aWV3XG4gICAgICAgIC8vIHdoaWxlIHRoZSBjaGlsZCBqb2luIGlzIHN0aWxsIHBlbmRpbmdcbiAgICAgICAgaWYgKGZyb21FbCkge1xuICAgICAgICAgIGZyb21FbC5zZXRBdHRyaWJ1dGUoUEhYX1JPT1RfSUQsIHRoaXMucm9vdC5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuam9pbkNoaWxkKHRvRWwpO1xuICAgICAgfSxcbiAgICApO1xuXG4gICAgaWYgKG5ld0NoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgIHRoaXMucm9vdC5wZW5kaW5nSm9pbk9wcy5wdXNoKFtcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgICgpID0+IHRoaXMuYXBwbHlKb2luUGF0Y2gobGl2ZV9wYXRjaCwgaHRtbCwgc3RyZWFtcywgZXZlbnRzKSxcbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMucGFyZW50LmFja0pvaW4odGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uQWxsQ2hpbGRKb2luc0NvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMuYXBwbHlKb2luUGF0Y2gobGl2ZV9wYXRjaCwgaHRtbCwgc3RyZWFtcywgZXZlbnRzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yb290LnBlbmRpbmdKb2luT3BzLnB1c2goW1xuICAgICAgICB0aGlzLFxuICAgICAgICAoKSA9PiB0aGlzLmFwcGx5Sm9pblBhdGNoKGxpdmVfcGF0Y2gsIGh0bWwsIHN0cmVhbXMsIGV2ZW50cyksXG4gICAgICBdKTtcbiAgICB9XG4gIH1cblxuICBhdHRhY2hUcnVlRG9jRWwoKSB7XG4gICAgdGhpcy5lbCA9IERPTS5ieUlkKHRoaXMuaWQpO1xuICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKFBIWF9ST09UX0lELCB0aGlzLnJvb3QuaWQpO1xuICB9XG5cbiAgLy8gdGhpcyBpcyBpbnZva2VkIGZvciBkZWFkIGFuZCBsaXZlIHZpZXdzLCBzbyB3ZSBtdXN0IGZpbHRlciBieVxuICAvLyBieSBvd25lciB0byBlbnN1cmUgd2UgYXJlbid0IGR1cGxpY2F0aW5nIGhvb2tzIGFjcm9zcyBkaXNjb25uZWN0XG4gIC8vIGFuZCBjb25uZWN0ZWQgc3RhdGVzLiBUaGlzIGFsc28gaGFuZGxlcyBjYXNlcyB3aGVyZSBob29rcyBleGlzdFxuICAvLyBpbiBhIHJvb3QgbGF5b3V0IHdpdGggYSBMViBpbiB0aGUgYm9keVxuICBleGVjTmV3TW91bnRlZChwYXJlbnQgPSBkb2N1bWVudCkge1xuICAgIGxldCBwaHhWaWV3cG9ydFRvcCA9IHRoaXMuYmluZGluZyhQSFhfVklFV1BPUlRfVE9QKTtcbiAgICBsZXQgcGh4Vmlld3BvcnRCb3R0b20gPSB0aGlzLmJpbmRpbmcoUEhYX1ZJRVdQT1JUX0JPVFRPTSk7XG4gICAgdGhpcy5hbGwoXG4gICAgICBwYXJlbnQsXG4gICAgICBgWyR7cGh4Vmlld3BvcnRUb3B9XSwgWyR7cGh4Vmlld3BvcnRCb3R0b219XWAsXG4gICAgICAoaG9va0VsKSA9PiB7XG4gICAgICAgIERPTS5tYWludGFpblByaXZhdGVIb29rcyhcbiAgICAgICAgICBob29rRWwsXG4gICAgICAgICAgaG9va0VsLFxuICAgICAgICAgIHBoeFZpZXdwb3J0VG9wLFxuICAgICAgICAgIHBoeFZpZXdwb3J0Qm90dG9tLFxuICAgICAgICApO1xuICAgICAgICB0aGlzLm1heWJlQWRkTmV3SG9vayhob29rRWwpO1xuICAgICAgfSxcbiAgICApO1xuICAgIHRoaXMuYWxsKFxuICAgICAgcGFyZW50LFxuICAgICAgYFske3RoaXMuYmluZGluZyhQSFhfSE9PSyl9XSwgW2RhdGEtcGh4LSR7UEhYX0hPT0t9XWAsXG4gICAgICAoaG9va0VsKSA9PiB7XG4gICAgICAgIHRoaXMubWF5YmVBZGROZXdIb29rKGhvb2tFbCk7XG4gICAgICB9LFxuICAgICk7XG4gICAgdGhpcy5hbGwocGFyZW50LCBgWyR7dGhpcy5iaW5kaW5nKFBIWF9NT1VOVEVEKX1dYCwgKGVsKSA9PiB7XG4gICAgICB0aGlzLm1heWJlTW91bnRlZChlbCk7XG4gICAgfSk7XG4gIH1cblxuICBhbGwocGFyZW50LCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICBET00uYWxsKHBhcmVudCwgc2VsZWN0b3IsIChlbCkgPT4ge1xuICAgICAgaWYgKHRoaXMub3duc0VsZW1lbnQoZWwpKSB7XG4gICAgICAgIGNhbGxiYWNrKGVsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFwcGx5Sm9pblBhdGNoKGxpdmVfcGF0Y2gsIGh0bWwsIHN0cmVhbXMsIGV2ZW50cykge1xuICAgIC8vIGluIGNhc2Ugb2YgcmVqb2lucywgd2UgbmVlZCB0byBtYW51YWxseSBwZXJmb3JtIGFsbFxuICAgIC8vIHBlbmRpbmcgb3BzXG4gICAgaWYgKHRoaXMuam9pbkNvdW50ID4gMSkge1xuICAgICAgaWYgKHRoaXMucGVuZGluZ0pvaW5PcHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucGVuZGluZ0pvaW5PcHMuZm9yRWFjaCgoY2IpID0+IHR5cGVvZiBjYiA9PT0gXCJmdW5jdGlvblwiICYmIGNiKCkpO1xuICAgICAgICB0aGlzLnBlbmRpbmdKb2luT3BzID0gW107XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYXR0YWNoVHJ1ZURvY0VsKCk7XG4gICAgY29uc3QgcGF0Y2ggPSBuZXcgRE9NUGF0Y2godGhpcywgdGhpcy5lbCwgdGhpcy5pZCwgaHRtbCwgc3RyZWFtcywgbnVsbCk7XG4gICAgcGF0Y2gubWFya1BydW5hYmxlQ29udGVudEZvclJlbW92YWwoKTtcbiAgICB0aGlzLnBlcmZvcm1QYXRjaChwYXRjaCwgZmFsc2UsIHRydWUpO1xuICAgIHRoaXMuam9pbk5ld0NoaWxkcmVuKCk7XG4gICAgdGhpcy5leGVjTmV3TW91bnRlZCgpO1xuXG4gICAgdGhpcy5qb2luUGVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMubGl2ZVNvY2tldC5kaXNwYXRjaEV2ZW50cyhldmVudHMpO1xuICAgIHRoaXMuYXBwbHlQZW5kaW5nVXBkYXRlcygpO1xuXG4gICAgaWYgKGxpdmVfcGF0Y2gpIHtcbiAgICAgIGNvbnN0IHsga2luZCwgdG8gfSA9IGxpdmVfcGF0Y2g7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQuaGlzdG9yeVBhdGNoKHRvLCBraW5kKTtcbiAgICB9XG4gICAgdGhpcy5oaWRlTG9hZGVyKCk7XG4gICAgaWYgKHRoaXMuam9pbkNvdW50ID4gMSkge1xuICAgICAgdGhpcy50cmlnZ2VyUmVjb25uZWN0ZWQoKTtcbiAgICB9XG4gICAgdGhpcy5zdG9wQ2FsbGJhY2soKTtcbiAgfVxuXG4gIHRyaWdnZXJCZWZvcmVVcGRhdGVIb29rKGZyb21FbCwgdG9FbCkge1xuICAgIHRoaXMubGl2ZVNvY2tldC50cmlnZ2VyRE9NKFwib25CZWZvcmVFbFVwZGF0ZWRcIiwgW2Zyb21FbCwgdG9FbF0pO1xuICAgIGNvbnN0IGhvb2sgPSB0aGlzLmdldEhvb2soZnJvbUVsKTtcbiAgICBjb25zdCBpc0lnbm9yZWQgPSBob29rICYmIERPTS5pc0lnbm9yZWQoZnJvbUVsLCB0aGlzLmJpbmRpbmcoUEhYX1VQREFURSkpO1xuICAgIGlmIChcbiAgICAgIGhvb2sgJiZcbiAgICAgICFmcm9tRWwuaXNFcXVhbE5vZGUodG9FbCkgJiZcbiAgICAgICEoaXNJZ25vcmVkICYmIGlzRXF1YWxPYmooZnJvbUVsLmRhdGFzZXQsIHRvRWwuZGF0YXNldCkpXG4gICAgKSB7XG4gICAgICBob29rLl9fYmVmb3JlVXBkYXRlKCk7XG4gICAgICByZXR1cm4gaG9vaztcbiAgICB9XG4gIH1cblxuICBtYXliZU1vdW50ZWQoZWwpIHtcbiAgICBjb25zdCBwaHhNb3VudGVkID0gZWwuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhQSFhfTU9VTlRFRCkpO1xuICAgIGNvbnN0IGhhc0JlZW5JbnZva2VkID0gcGh4TW91bnRlZCAmJiBET00ucHJpdmF0ZShlbCwgXCJtb3VudGVkXCIpO1xuICAgIGlmIChwaHhNb3VudGVkICYmICFoYXNCZWVuSW52b2tlZCkge1xuICAgICAgdGhpcy5saXZlU29ja2V0LmV4ZWNKUyhlbCwgcGh4TW91bnRlZCk7XG4gICAgICBET00ucHV0UHJpdmF0ZShlbCwgXCJtb3VudGVkXCIsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIG1heWJlQWRkTmV3SG9vayhlbCkge1xuICAgIGNvbnN0IG5ld0hvb2sgPSB0aGlzLmFkZEhvb2soZWwpO1xuICAgIGlmIChuZXdIb29rKSB7XG4gICAgICBuZXdIb29rLl9fbW91bnRlZCgpO1xuICAgIH1cbiAgfVxuXG4gIHBlcmZvcm1QYXRjaChwYXRjaCwgcHJ1bmVDaWRzLCBpc0pvaW5QYXRjaCA9IGZhbHNlKSB7XG4gICAgY29uc3QgcmVtb3ZlZEVscyA9IFtdO1xuICAgIGxldCBwaHhDaGlsZHJlbkFkZGVkID0gZmFsc2U7XG4gICAgY29uc3QgdXBkYXRlZEhvb2tJZHMgPSBuZXcgU2V0KCk7XG5cbiAgICB0aGlzLmxpdmVTb2NrZXQudHJpZ2dlckRPTShcIm9uUGF0Y2hTdGFydFwiLCBbcGF0Y2gudGFyZ2V0Q29udGFpbmVyXSk7XG5cbiAgICBwYXRjaC5hZnRlcihcImFkZGVkXCIsIChlbCkgPT4ge1xuICAgICAgdGhpcy5saXZlU29ja2V0LnRyaWdnZXJET00oXCJvbk5vZGVBZGRlZFwiLCBbZWxdKTtcbiAgICAgIGNvbnN0IHBoeFZpZXdwb3J0VG9wID0gdGhpcy5iaW5kaW5nKFBIWF9WSUVXUE9SVF9UT1ApO1xuICAgICAgY29uc3QgcGh4Vmlld3BvcnRCb3R0b20gPSB0aGlzLmJpbmRpbmcoUEhYX1ZJRVdQT1JUX0JPVFRPTSk7XG4gICAgICBET00ubWFpbnRhaW5Qcml2YXRlSG9va3MoZWwsIGVsLCBwaHhWaWV3cG9ydFRvcCwgcGh4Vmlld3BvcnRCb3R0b20pO1xuICAgICAgdGhpcy5tYXliZUFkZE5ld0hvb2soZWwpO1xuICAgICAgaWYgKGVsLmdldEF0dHJpYnV0ZSkge1xuICAgICAgICB0aGlzLm1heWJlTW91bnRlZChlbCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBwYXRjaC5hZnRlcihcInBoeENoaWxkQWRkZWRcIiwgKGVsKSA9PiB7XG4gICAgICBpZiAoRE9NLmlzUGh4U3RpY2t5KGVsKSkge1xuICAgICAgICB0aGlzLmxpdmVTb2NrZXQuam9pblJvb3RWaWV3cygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGh4Q2hpbGRyZW5BZGRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBwYXRjaC5iZWZvcmUoXCJ1cGRhdGVkXCIsIChmcm9tRWwsIHRvRWwpID0+IHtcbiAgICAgIGNvbnN0IGhvb2sgPSB0aGlzLnRyaWdnZXJCZWZvcmVVcGRhdGVIb29rKGZyb21FbCwgdG9FbCk7XG4gICAgICBpZiAoaG9vaykge1xuICAgICAgICB1cGRhdGVkSG9va0lkcy5hZGQoZnJvbUVsLmlkKTtcbiAgICAgIH1cbiAgICAgIC8vIHRyaWdnZXIgSlMgc3BlY2lmaWMgdXBkYXRlIGxvZ2ljIChmb3IgZXhhbXBsZSBmb3IgSlMuaWdub3JlX2F0dHJpYnV0ZXMpXG4gICAgICBKUy5vbkJlZm9yZUVsVXBkYXRlZChmcm9tRWwsIHRvRWwpO1xuICAgIH0pO1xuXG4gICAgcGF0Y2guYWZ0ZXIoXCJ1cGRhdGVkXCIsIChlbCkgPT4ge1xuICAgICAgaWYgKHVwZGF0ZWRIb29rSWRzLmhhcyhlbC5pZCkpIHtcbiAgICAgICAgdGhpcy5nZXRIb29rKGVsKS5fX3VwZGF0ZWQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHBhdGNoLmFmdGVyKFwiZGlzY2FyZGVkXCIsIChlbCkgPT4ge1xuICAgICAgaWYgKGVsLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICByZW1vdmVkRWxzLnB1c2goZWwpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcGF0Y2guYWZ0ZXIoXCJ0cmFuc2l0aW9uc0Rpc2NhcmRlZFwiLCAoZWxzKSA9PlxuICAgICAgdGhpcy5hZnRlckVsZW1lbnRzUmVtb3ZlZChlbHMsIHBydW5lQ2lkcyksXG4gICAgKTtcbiAgICBwYXRjaC5wZXJmb3JtKGlzSm9pblBhdGNoKTtcbiAgICB0aGlzLmFmdGVyRWxlbWVudHNSZW1vdmVkKHJlbW92ZWRFbHMsIHBydW5lQ2lkcyk7XG5cbiAgICB0aGlzLmxpdmVTb2NrZXQudHJpZ2dlckRPTShcIm9uUGF0Y2hFbmRcIiwgW3BhdGNoLnRhcmdldENvbnRhaW5lcl0pO1xuICAgIHJldHVybiBwaHhDaGlsZHJlbkFkZGVkO1xuICB9XG5cbiAgYWZ0ZXJFbGVtZW50c1JlbW92ZWQoZWxlbWVudHMsIHBydW5lQ2lkcykge1xuICAgIGNvbnN0IGRlc3Ryb3llZENJRHMgPSBbXTtcbiAgICBlbGVtZW50cy5mb3JFYWNoKChwYXJlbnQpID0+IHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBET00uYWxsKFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIGBbJHtQSFhfVklFV19SRUZ9PVwiJHt0aGlzLmlkfVwiXVske1BIWF9DT01QT05FTlR9XWAsXG4gICAgICApO1xuICAgICAgY29uc3QgaG9va3MgPSBET00uYWxsKFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIGBbJHt0aGlzLmJpbmRpbmcoUEhYX0hPT0spfV0sIFtkYXRhLXBoeC1ob29rXWAsXG4gICAgICApO1xuICAgICAgY29tcG9uZW50cy5jb25jYXQocGFyZW50KS5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICBjb25zdCBjaWQgPSB0aGlzLmNvbXBvbmVudElEKGVsKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGlzQ2lkKGNpZCkgJiZcbiAgICAgICAgICBkZXN0cm95ZWRDSURzLmluZGV4T2YoY2lkKSA9PT0gLTEgJiZcbiAgICAgICAgICBlbC5nZXRBdHRyaWJ1dGUoUEhYX1ZJRVdfUkVGKSA9PT0gdGhpcy5pZFxuICAgICAgICApIHtcbiAgICAgICAgICBkZXN0cm95ZWRDSURzLnB1c2goY2lkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBob29rcy5jb25jYXQocGFyZW50KS5mb3JFYWNoKChob29rRWwpID0+IHtcbiAgICAgICAgY29uc3QgaG9vayA9IHRoaXMuZ2V0SG9vayhob29rRWwpO1xuICAgICAgICBob29rICYmIHRoaXMuZGVzdHJveUhvb2soaG9vayk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyBXZSBzaG91bGQgbm90IHBydW5lQ2lkcyBvbiBqb2lucy4gT3RoZXJ3aXNlLCBpbiBjYXNlIG9mXG4gICAgLy8gcmVqb2lucywgd2UgbWF5IG5vdGlmeSBjaWRzIHRoYXQgbm8gbG9uZ2VyIGJlbG9uZyB0byB0aGVcbiAgICAvLyBjdXJyZW50IExpdmVWaWV3IHRvIGJlIHJlbW92ZWQuXG4gICAgaWYgKHBydW5lQ2lkcykge1xuICAgICAgdGhpcy5tYXliZVB1c2hDb21wb25lbnRzRGVzdHJveWVkKGRlc3Ryb3llZENJRHMpO1xuICAgIH1cbiAgfVxuXG4gIGpvaW5OZXdDaGlsZHJlbigpIHtcbiAgICBET00uZmluZFBoeENoaWxkcmVuKGRvY3VtZW50LCB0aGlzLmlkKS5mb3JFYWNoKChlbCkgPT4gdGhpcy5qb2luQ2hpbGQoZWwpKTtcbiAgfVxuXG4gIG1heWJlUmVjb3ZlckZvcm1zKGh0bWwsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgcGh4Q2hhbmdlID0gdGhpcy5iaW5kaW5nKFwiY2hhbmdlXCIpO1xuICAgIGNvbnN0IG9sZEZvcm1zID0gdGhpcy5yb290LmZvcm1zRm9yUmVjb3Zlcnk7XG4gICAgLy8gU28gd2h5IGRvIHdlIGNyZWF0ZSBhIHRlbXBsYXRlIGVsZW1lbnQgaGVyZT9cbiAgICAvLyBPbmUgd2F5IHRvIHJlY292ZXIgZm9ybXMgd291bGQgYmUgdG8gaW1tZWRpYXRlbHkgYXBwbHkgdGhlIG1vdW50XG4gICAgLy8gcGF0Y2ggYW5kIHRoZW4gYWZ0ZXJ3YXJkcyByZWNvdmVyIHRoZSBmb3Jtcy4gSG93ZXZlciwgdGhpcyB3b3VsZFxuICAgIC8vIGNhdXNlIGEgZmxpY2tlciwgYmVjYXVzZSB0aGUgbW91bnQgcGF0Y2ggd291bGQgcmVtb3ZlIHRoZSBmb3JtIGNvbnRlbnRcbiAgICAvLyB1bnRpbCBpdCBpcyByZXN0b3JlZC4gVGhlcmVmb3JlIExWIGRlY2lkZWQgdG8gZG8gZm9ybSByZWNvdmVyeSB3aXRoIHRoZVxuICAgIC8vIHJhdyBIVE1MIGJlZm9yZSBpdCBpcyBhcHBsaWVkIGFuZCBkZWxheSB0aGUgbW91bnQgcGF0Y2ggdW50aWwgdGhlIGZvcm1cbiAgICAvLyByZWNvdmVyeSBldmVudHMgYXJlIGRvbmUuXG4gICAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG4gICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbDtcblxuICAgIC8vIHdlIHNwZWNpYWwgY2FzZSA8LnBvcnRhbD4gaGVyZSBhbmQgdGVsZXBvcnQgaXQgaW50byBvdXIgdGVtcG9yYXJ5IERPTSBmb3IgcmVjb3ZlcnlcbiAgICAvLyBhcyB3ZSdkIG90aGVyd2lzZSBub3QgZmluZCB0ZWxlcG9ydGVkIGZvcm1zXG4gICAgRE9NLmFsbCh0ZW1wbGF0ZS5jb250ZW50LCBgWyR7UEhYX1BPUlRBTH1dYCkuZm9yRWFjaCgocG9ydGFsVGVtcGxhdGUpID0+IHtcbiAgICAgIHRlbXBsYXRlLmNvbnRlbnQuZmlyc3RFbGVtZW50Q2hpbGQuYXBwZW5kQ2hpbGQoXG4gICAgICAgIHBvcnRhbFRlbXBsYXRlLmNvbnRlbnQuZmlyc3RFbGVtZW50Q2hpbGQsXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgLy8gYmVjYXVzZSB3ZSB3b3JrIHdpdGggYSB0ZW1wbGF0ZSBlbGVtZW50LCB3ZSBtdXN0IG1hbnVhbGx5IGNvcHkgdGhlIGF0dHJpYnV0ZXNcbiAgICAvLyBvdGhlcndpc2UgdGhlIG93bmVyIC8gdGFyZ2V0IGhlbHBlcnMgZG9uJ3Qgd29yayBwcm9wZXJseVxuICAgIGNvbnN0IHJvb3RFbCA9IHRlbXBsYXRlLmNvbnRlbnQuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgcm9vdEVsLmlkID0gdGhpcy5pZDtcbiAgICByb290RWwuc2V0QXR0cmlidXRlKFBIWF9ST09UX0lELCB0aGlzLnJvb3QuaWQpO1xuICAgIHJvb3RFbC5zZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04sIHRoaXMuZ2V0U2Vzc2lvbigpKTtcbiAgICByb290RWwuc2V0QXR0cmlidXRlKFBIWF9TVEFUSUMsIHRoaXMuZ2V0U3RhdGljKCkpO1xuICAgIHJvb3RFbC5zZXRBdHRyaWJ1dGUoUEhYX1BBUkVOVF9JRCwgdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5pZCA6IG51bGwpO1xuXG4gICAgLy8gd2UgZ28gb3ZlciBhbGwgZm9ybSBlbGVtZW50cyBpbiB0aGUgbmV3IEhUTUwgZm9yIHRoZSBMVlxuICAgIC8vIGFuZCBsb29rIGZvciBvbGQgZm9ybXMgaW4gdGhlIGBmb3Jtc0ZvclJlY292ZXJ5YCBvYmplY3Q7XG4gICAgLy8gdGhlIGZvcm1zRm9yUmVjb3ZlcnkgY2FuIGFsc28gY29udGFpbiBmb3JtcyBmcm9tIGNoaWxkIHZpZXdzXG4gICAgY29uc3QgZm9ybXNUb1JlY292ZXIgPVxuICAgICAgLy8gd2UgZ28gb3ZlciBhbGwgZm9ybXMgaW4gdGhlIG5ldyBET007IGJlY2F1c2UgdGhpcyBpcyBvbmx5IHRoZSBIVE1MIGZvciB0aGUgY3VycmVudFxuICAgICAgLy8gdmlldywgd2UgY2FuIGJlIHN1cmUgdGhhdCBhbGwgZm9ybXMgYXJlIG93bmVkIGJ5IHRoaXMgdmlldzpcbiAgICAgIERPTS5hbGwodGVtcGxhdGUuY29udGVudCwgXCJmb3JtXCIpXG4gICAgICAgIC8vIG9ubHkgcmVjb3ZlciBmb3JtcyB0aGF0IGhhdmUgYW4gaWQgYW5kIGFyZSBpbiB0aGUgb2xkIERPTVxuICAgICAgICAuZmlsdGVyKChuZXdGb3JtKSA9PiBuZXdGb3JtLmlkICYmIG9sZEZvcm1zW25ld0Zvcm0uaWRdKVxuICAgICAgICAvLyBhYmFuZG9uIGZvcm1zIHdlIGFscmVhZHkgdHJpZWQgdG8gcmVjb3ZlciB0byBwcmV2ZW50IGxvb3BpbmcgYSBmYWlsZWQgc3RhdGVcbiAgICAgICAgLmZpbHRlcigobmV3Rm9ybSkgPT4gIXRoaXMucGVuZGluZ0Zvcm1zLmhhcyhuZXdGb3JtLmlkKSlcbiAgICAgICAgLy8gb25seSByZWNvdmVyIGlmIHRoZSBmb3JtIGhhcyB0aGUgc2FtZSBwaHgtY2hhbmdlIHZhbHVlXG4gICAgICAgIC5maWx0ZXIoXG4gICAgICAgICAgKG5ld0Zvcm0pID0+XG4gICAgICAgICAgICBvbGRGb3Jtc1tuZXdGb3JtLmlkXS5nZXRBdHRyaWJ1dGUocGh4Q2hhbmdlKSA9PT1cbiAgICAgICAgICAgIG5ld0Zvcm0uZ2V0QXR0cmlidXRlKHBoeENoYW5nZSksXG4gICAgICAgIClcbiAgICAgICAgLm1hcCgobmV3Rm9ybSkgPT4ge1xuICAgICAgICAgIHJldHVybiBbb2xkRm9ybXNbbmV3Rm9ybS5pZF0sIG5ld0Zvcm1dO1xuICAgICAgICB9KTtcblxuICAgIGlmIChmb3Jtc1RvUmVjb3Zlci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIGZvcm1zVG9SZWNvdmVyLmZvckVhY2goKFtvbGRGb3JtLCBuZXdGb3JtXSwgaSkgPT4ge1xuICAgICAgdGhpcy5wZW5kaW5nRm9ybXMuYWRkKG5ld0Zvcm0uaWQpO1xuICAgICAgLy8gaXQgaXMgaW1wb3J0YW50IHRvIHVzZSB0aGUgZmlyc3RFbGVtZW50Q2hpbGQgb2YgdGhlIHRlbXBsYXRlIGNvbnRlbnRcbiAgICAgIC8vIGJlY2F1c2Ugd2hlbiB0cmF2ZXJzaW5nIGEgZG9jdW1lbnRGcmFnbWVudCB1c2luZyBwYXJlbnROb2RlLCB3ZSB3b24ndCBldmVyIGFycml2ZSBhdFxuICAgICAgLy8gdGhlIGZyYWdtZW50OyBhcyB0aGUgdGVtcGxhdGUgaXMgYWx3YXlzIGEgTGl2ZVZpZXcsIHdlIGNhbiBiZSBzdXJlIHRoYXQgdGhlcmUgaXMgb25seVxuICAgICAgLy8gb25lIGNoaWxkIG9uIHRoZSByb290IGxldmVsXG4gICAgICB0aGlzLnB1c2hGb3JtUmVjb3ZlcnkoXG4gICAgICAgIG9sZEZvcm0sXG4gICAgICAgIG5ld0Zvcm0sXG4gICAgICAgIHRlbXBsYXRlLmNvbnRlbnQuZmlyc3RFbGVtZW50Q2hpbGQsXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdGb3Jtcy5kZWxldGUobmV3Rm9ybS5pZCk7XG4gICAgICAgICAgLy8gd2Ugb25seSBjYWxsIHRoZSBjYWxsYmFjayBvbmNlIGFsbCBmb3JtcyBoYXZlIGJlZW4gcmVjb3ZlcmVkXG4gICAgICAgICAgaWYgKGkgPT09IGZvcm1zVG9SZWNvdmVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldENoaWxkQnlJZChpZCkge1xuICAgIHJldHVybiB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF1baWRdO1xuICB9XG5cbiAgZ2V0RGVzY2VuZGVudEJ5RWwoZWwpIHtcbiAgICBpZiAoZWwuaWQgPT09IHRoaXMuaWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltlbC5nZXRBdHRyaWJ1dGUoUEhYX1BBUkVOVF9JRCldPy5bZWwuaWRdO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3lEZXNjZW5kZW50KGlkKSB7XG4gICAgZm9yIChjb25zdCBwYXJlbnRJZCBpbiB0aGlzLnJvb3QuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAoY29uc3QgY2hpbGRJZCBpbiB0aGlzLnJvb3QuY2hpbGRyZW5bcGFyZW50SWRdKSB7XG4gICAgICAgIGlmIChjaGlsZElkID09PSBpZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJvb3QuY2hpbGRyZW5bcGFyZW50SWRdW2NoaWxkSWRdLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGpvaW5DaGlsZChlbCkge1xuICAgIGNvbnN0IGNoaWxkID0gdGhpcy5nZXRDaGlsZEJ5SWQoZWwuaWQpO1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIGNvbnN0IHZpZXcgPSBuZXcgVmlldyhlbCwgdGhpcy5saXZlU29ja2V0LCB0aGlzKTtcbiAgICAgIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLmlkXVt2aWV3LmlkXSA9IHZpZXc7XG4gICAgICB2aWV3LmpvaW4oKTtcbiAgICAgIHRoaXMuY2hpbGRKb2lucysrO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaXNKb2luUGVuZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5qb2luUGVuZGluZztcbiAgfVxuXG4gIGFja0pvaW4oX2NoaWxkKSB7XG4gICAgdGhpcy5jaGlsZEpvaW5zLS07XG5cbiAgICBpZiAodGhpcy5jaGlsZEpvaW5zID09PSAwKSB7XG4gICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuYWNrSm9pbih0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub25BbGxDaGlsZEpvaW5zQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkFsbENoaWxkSm9pbnNDb21wbGV0ZSgpIHtcbiAgICAvLyB3ZSBjYW4gY2xlYXIgcGVuZGluZyBmb3JtIHJlY292ZXJpZXMgbm93IHRoYXQgd2UndmUgam9pbmVkLlxuICAgIC8vIFRoZXkgZWl0aGVyIGFsbCByZXNvbHZlZCBvciB3ZXJlIGFiYW5kb25lZFxuICAgIHRoaXMucGVuZGluZ0Zvcm1zLmNsZWFyKCk7XG4gICAgLy8gd2UgY2FuIGFsc28gY2xlYXIgdGhlIGZvcm1zRm9yUmVjb3Zlcnkgb2JqZWN0IHRvIG5vdCBrZWVwIG9sZCBmb3JtIGVsZW1lbnRzIGFyb3VuZFxuICAgIHRoaXMuZm9ybXNGb3JSZWNvdmVyeSA9IHt9O1xuICAgIHRoaXMuam9pbkNhbGxiYWNrKCgpID0+IHtcbiAgICAgIHRoaXMucGVuZGluZ0pvaW5PcHMuZm9yRWFjaCgoW3ZpZXcsIG9wXSkgPT4ge1xuICAgICAgICBpZiAoIXZpZXcuaXNEZXN0cm95ZWQoKSkge1xuICAgICAgICAgIG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5wZW5kaW5nSm9pbk9wcyA9IFtdO1xuICAgIH0pO1xuICB9XG5cbiAgdXBkYXRlKGRpZmYsIGV2ZW50cywgaXNQZW5kaW5nID0gZmFsc2UpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLmlzSm9pblBlbmRpbmcoKSB8fFxuICAgICAgKHRoaXMubGl2ZVNvY2tldC5oYXNQZW5kaW5nTGluaygpICYmIHRoaXMucm9vdC5pc01haW4oKSlcbiAgICApIHtcbiAgICAgIC8vIGRvbid0IG11dGF0ZSBpZiB0aGlzIGlzIGFscmVhZHkgYSBwZW5kaW5nIGRpZmZcbiAgICAgIGlmICghaXNQZW5kaW5nKSB7XG4gICAgICAgIHRoaXMucGVuZGluZ0RpZmZzLnB1c2goeyBkaWZmLCBldmVudHMgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJlZC5tZXJnZURpZmYoZGlmZik7XG4gICAgbGV0IHBoeENoaWxkcmVuQWRkZWQgPSBmYWxzZTtcblxuICAgIC8vIFdoZW4gdGhlIGRpZmYgb25seSBjb250YWlucyBjb21wb25lbnQgZGlmZnMsIHRoZW4gd2FsayBjb21wb25lbnRzXG4gICAgLy8gYW5kIHBhdGNoIG9ubHkgdGhlIHBhcmVudCBjb21wb25lbnQgY29udGFpbmVycyBmb3VuZCBpbiB0aGUgZGlmZi5cbiAgICAvLyBPdGhlcndpc2UsIHBhdGNoIGVudGlyZSBMViBjb250YWluZXIuXG4gICAgaWYgKHRoaXMucmVuZGVyZWQuaXNDb21wb25lbnRPbmx5RGlmZihkaWZmKSkge1xuICAgICAgdGhpcy5saXZlU29ja2V0LnRpbWUoXCJjb21wb25lbnQgcGF0Y2ggY29tcGxldGVcIiwgKCkgPT4ge1xuICAgICAgICBjb25zdCBwYXJlbnRDaWRzID0gRE9NLmZpbmRFeGlzdGluZ1BhcmVudENJRHMoXG4gICAgICAgICAgdGhpcy5pZCxcbiAgICAgICAgICB0aGlzLnJlbmRlcmVkLmNvbXBvbmVudENJRHMoZGlmZiksXG4gICAgICAgICk7XG4gICAgICAgIHBhcmVudENpZHMuZm9yRWFjaCgocGFyZW50Q0lEKSA9PiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRQYXRjaChcbiAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlZC5nZXRDb21wb25lbnQoZGlmZiwgcGFyZW50Q0lEKSxcbiAgICAgICAgICAgICAgcGFyZW50Q0lELFxuICAgICAgICAgICAgKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcGh4Q2hpbGRyZW5BZGRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIWlzRW1wdHkoZGlmZikpIHtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC50aW1lKFwiZnVsbCBwYXRjaCBjb21wbGV0ZVwiLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IFtodG1sLCBzdHJlYW1zXSA9IHRoaXMucmVuZGVyQ29udGFpbmVyKGRpZmYsIFwidXBkYXRlXCIpO1xuICAgICAgICBjb25zdCBwYXRjaCA9IG5ldyBET01QYXRjaCh0aGlzLCB0aGlzLmVsLCB0aGlzLmlkLCBodG1sLCBzdHJlYW1zLCBudWxsKTtcbiAgICAgICAgcGh4Q2hpbGRyZW5BZGRlZCA9IHRoaXMucGVyZm9ybVBhdGNoKHBhdGNoLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMubGl2ZVNvY2tldC5kaXNwYXRjaEV2ZW50cyhldmVudHMpO1xuICAgIGlmIChwaHhDaGlsZHJlbkFkZGVkKSB7XG4gICAgICB0aGlzLmpvaW5OZXdDaGlsZHJlbigpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmVuZGVyQ29udGFpbmVyKGRpZmYsIGtpbmQpIHtcbiAgICByZXR1cm4gdGhpcy5saXZlU29ja2V0LnRpbWUoYHRvU3RyaW5nIGRpZmYgKCR7a2luZH0pYCwgKCkgPT4ge1xuICAgICAgY29uc3QgdGFnID0gdGhpcy5lbC50YWdOYW1lO1xuICAgICAgLy8gRG9uJ3Qgc2tpcCBhbnkgY29tcG9uZW50IGluIHRoZSBkaWZmIG5vciBhbnkgbWFya2VkIGFzIHBydW5lZFxuICAgICAgLy8gKGFzIHRoZXkgbWF5IGhhdmUgYmVlbiBhZGRlZCBiYWNrKVxuICAgICAgY29uc3QgY2lkcyA9IGRpZmYgPyB0aGlzLnJlbmRlcmVkLmNvbXBvbmVudENJRHMoZGlmZikgOiBudWxsO1xuICAgICAgY29uc3QgeyBidWZmZXI6IGh0bWwsIHN0cmVhbXMgfSA9IHRoaXMucmVuZGVyZWQudG9TdHJpbmcoY2lkcyk7XG4gICAgICByZXR1cm4gW2A8JHt0YWd9PiR7aHRtbH08LyR7dGFnfT5gLCBzdHJlYW1zXTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbXBvbmVudFBhdGNoKGRpZmYsIGNpZCkge1xuICAgIGlmIChpc0VtcHR5KGRpZmYpKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgeyBidWZmZXI6IGh0bWwsIHN0cmVhbXMgfSA9IHRoaXMucmVuZGVyZWQuY29tcG9uZW50VG9TdHJpbmcoY2lkKTtcbiAgICBjb25zdCBwYXRjaCA9IG5ldyBET01QYXRjaCh0aGlzLCB0aGlzLmVsLCB0aGlzLmlkLCBodG1sLCBzdHJlYW1zLCBjaWQpO1xuICAgIGNvbnN0IGNoaWxkcmVuQWRkZWQgPSB0aGlzLnBlcmZvcm1QYXRjaChwYXRjaCwgdHJ1ZSk7XG4gICAgcmV0dXJuIGNoaWxkcmVuQWRkZWQ7XG4gIH1cblxuICBnZXRIb29rKGVsKSB7XG4gICAgcmV0dXJuIHRoaXMudmlld0hvb2tzW1ZpZXdIb29rLmVsZW1lbnRJRChlbCldO1xuICB9XG5cbiAgYWRkSG9vayhlbCkge1xuICAgIGNvbnN0IGhvb2tFbElkID0gVmlld0hvb2suZWxlbWVudElEKGVsKTtcblxuICAgIC8vIG9ubHkgZXZlciB0cnkgdG8gYWRkIGhvb2tzIHRvIGVsZW1lbnRzIG93bmVkIGJ5IHRoaXMgdmlld1xuICAgIGlmIChlbC5nZXRBdHRyaWJ1dGUgJiYgIXRoaXMub3duc0VsZW1lbnQoZWwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGhvb2tFbElkICYmICF0aGlzLnZpZXdIb29rc1tob29rRWxJZF0pIHtcbiAgICAgIC8vIGhvb2sgY3JlYXRlZCwgYnV0IG5vdCBhdHRhY2hlZCAoY3JlYXRlSG9vayBmb3Igd2ViIGNvbXBvbmVudClcbiAgICAgIGNvbnN0IGhvb2sgPVxuICAgICAgICBET00uZ2V0Q3VzdG9tRWxIb29rKGVsKSB8fFxuICAgICAgICBsb2dFcnJvcihgbm8gaG9vayBmb3VuZCBmb3IgY3VzdG9tIGVsZW1lbnQ6ICR7ZWwuaWR9YCk7XG4gICAgICB0aGlzLnZpZXdIb29rc1tob29rRWxJZF0gPSBob29rO1xuICAgICAgaG9vay5fX2F0dGFjaFZpZXcodGhpcyk7XG4gICAgICByZXR1cm4gaG9vaztcbiAgICB9IGVsc2UgaWYgKGhvb2tFbElkIHx8ICFlbC5nZXRBdHRyaWJ1dGUpIHtcbiAgICAgIC8vIG5vIGhvb2sgZm91bmRcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbmV3IGhvb2sgZm91bmQgd2l0aCBwaHgtaG9vayBhdHRyaWJ1dGVcbiAgICAgIGNvbnN0IGhvb2tOYW1lID1cbiAgICAgICAgZWwuZ2V0QXR0cmlidXRlKGBkYXRhLXBoeC0ke1BIWF9IT09LfWApIHx8XG4gICAgICAgIGVsLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0hPT0spKTtcblxuICAgICAgaWYgKCFob29rTmFtZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGhvb2tEZWZpbml0aW9uID0gdGhpcy5saXZlU29ja2V0LmdldEhvb2tEZWZpbml0aW9uKGhvb2tOYW1lKTtcblxuICAgICAgaWYgKGhvb2tEZWZpbml0aW9uKSB7XG4gICAgICAgIGlmICghZWwuaWQpIHtcbiAgICAgICAgICBsb2dFcnJvcihcbiAgICAgICAgICAgIGBubyBET00gSUQgZm9yIGhvb2sgXCIke2hvb2tOYW1lfVwiLiBIb29rcyByZXF1aXJlIGEgdW5pcXVlIElEIG9uIGVhY2ggZWxlbWVudC5gLFxuICAgICAgICAgICAgZWwsXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaG9va0luc3RhbmNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBob29rRGVmaW5pdGlvbiA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICBob29rRGVmaW5pdGlvbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBWaWV3SG9va1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gSXQncyBhIGNsYXNzIGNvbnN0cnVjdG9yIChzdWJjbGFzcyBvZiBWaWV3SG9vaylcbiAgICAgICAgICAgIGhvb2tJbnN0YW5jZSA9IG5ldyBob29rRGVmaW5pdGlvbih0aGlzLCBlbCk7IC8vIGB0aGlzYCBpcyB0aGUgVmlldyBpbnN0YW5jZVxuICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICB0eXBlb2YgaG9va0RlZmluaXRpb24gPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhvb2tEZWZpbml0aW9uICE9PSBudWxsXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBJdCdzIGFuIG9iamVjdCBsaXRlcmFsLCBwYXNzIGl0IHRvIHRoZSBWaWV3SG9vayBjb25zdHJ1Y3RvciBmb3Igd3JhcHBpbmdcbiAgICAgICAgICAgIGhvb2tJbnN0YW5jZSA9IG5ldyBWaWV3SG9vayh0aGlzLCBlbCwgaG9va0RlZmluaXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgaG9vayBkZWZpbml0aW9uIGZvciBcIiR7aG9va05hbWV9XCIuIEV4cGVjdGVkIGEgY2xhc3MgZXh0ZW5kaW5nIFZpZXdIb29rIG9yIGFuIG9iamVjdCBkZWZpbml0aW9uLmAsXG4gICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiBTdHJpbmcoZSk7XG4gICAgICAgICAgbG9nRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgaG9vayBcIiR7aG9va05hbWV9XCI6ICR7ZXJyb3JNZXNzYWdlfWAsIGVsKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZpZXdIb29rc1tWaWV3SG9vay5lbGVtZW50SUQoaG9va0luc3RhbmNlLmVsKV0gPSBob29rSW5zdGFuY2U7XG4gICAgICAgIHJldHVybiBob29rSW5zdGFuY2U7XG4gICAgICB9IGVsc2UgaWYgKGhvb2tOYW1lICE9PSBudWxsKSB7XG4gICAgICAgIGxvZ0Vycm9yKGB1bmtub3duIGhvb2sgZm91bmQgZm9yIFwiJHtob29rTmFtZX1cImAsIGVsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkZXN0cm95SG9vayhob29rKSB7XG4gICAgLy8gX19kZXN0cm95ZWQgY2xlYXJzIHRoZSBlbGVtZW50SUQgZnJvbSB0aGUgaG9vaywgdGhlcmVmb3JlXG4gICAgLy8gd2UgbmVlZCB0byBnZXQgaXQgYmVmb3JlIGNhbGxpbmcgX19kZXN0cm95ZWRcbiAgICBjb25zdCBob29rSWQgPSBWaWV3SG9vay5lbGVtZW50SUQoaG9vay5lbCk7XG4gICAgaG9vay5fX2Rlc3Ryb3llZCgpO1xuICAgIGhvb2suX19jbGVhbnVwX18oKTtcbiAgICBkZWxldGUgdGhpcy52aWV3SG9va3NbaG9va0lkXTtcbiAgfVxuXG4gIGFwcGx5UGVuZGluZ1VwZGF0ZXMoKSB7XG4gICAgLy8gVG8gcHJldmVudCByYWNlIGNvbmRpdGlvbnMgd2hlcmUgd2UgbWlnaHQgc3RpbGwgYmUgcGVuZGluZyBhIG5ld1xuICAgIC8vIG5hdmlnYXRpb24gb3IgdGhlIGpvaW4gaXMgc3RpbGwgcGVuZGluZywgYHRoaXMudXBkYXRlYCByZXR1cm5zIGZhbHNlXG4gICAgLy8gaWYgdGhlIGRpZmYgd2FzIG5vdCBhcHBsaWVkLlxuICAgIHRoaXMucGVuZGluZ0RpZmZzID0gdGhpcy5wZW5kaW5nRGlmZnMuZmlsdGVyKFxuICAgICAgKHsgZGlmZiwgZXZlbnRzIH0pID0+ICF0aGlzLnVwZGF0ZShkaWZmLCBldmVudHMsIHRydWUpLFxuICAgICk7XG4gICAgdGhpcy5lYWNoQ2hpbGQoKGNoaWxkKSA9PiBjaGlsZC5hcHBseVBlbmRpbmdVcGRhdGVzKCkpO1xuICB9XG5cbiAgZWFjaENoaWxkKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF0gfHwge307XG4gICAgZm9yIChjb25zdCBpZCBpbiBjaGlsZHJlbikge1xuICAgICAgY2FsbGJhY2sodGhpcy5nZXRDaGlsZEJ5SWQoaWQpKTtcbiAgICB9XG4gIH1cblxuICBvbkNoYW5uZWwoZXZlbnQsIGNiKSB7XG4gICAgdGhpcy5saXZlU29ja2V0Lm9uQ2hhbm5lbCh0aGlzLmNoYW5uZWwsIGV2ZW50LCAocmVzcCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNKb2luUGVuZGluZygpKSB7XG4gICAgICAgIC8vIGluIGNhc2UgdGhpcyBpcyBhIHJlam9pbiAoam9pbkNvdW50ID4gMSkgd2Ugc3RvcmUgb3VyIG93biBqb2luIG9wc1xuICAgICAgICBpZiAodGhpcy5qb2luQ291bnQgPiAxKSB7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nSm9pbk9wcy5wdXNoKCgpID0+IGNiKHJlc3ApKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJvb3QucGVuZGluZ0pvaW5PcHMucHVzaChbdGhpcywgKCkgPT4gY2IocmVzcCldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5saXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4gY2IocmVzcCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYmluZENoYW5uZWwoKSB7XG4gICAgLy8gVGhlIGRpZmYgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQgYnkgdGhlIHJlZ3VsYXIgdXBkYXRlIG9wZXJhdGlvbnMuXG4gICAgLy8gQWxsIG90aGVyIG9wZXJhdGlvbnMgYXJlIHF1ZXVlZCB0byBiZSBhcHBsaWVkIG9ubHkgYWZ0ZXIgam9pbi5cbiAgICB0aGlzLmxpdmVTb2NrZXQub25DaGFubmVsKHRoaXMuY2hhbm5lbCwgXCJkaWZmXCIsIChyYXdEaWZmKSA9PiB7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuYXBwbHlEaWZmKFwidXBkYXRlXCIsIHJhd0RpZmYsICh7IGRpZmYsIGV2ZW50cyB9KSA9PlxuICAgICAgICAgIHRoaXMudXBkYXRlKGRpZmYsIGV2ZW50cyksXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLm9uQ2hhbm5lbChcInJlZGlyZWN0XCIsICh7IHRvLCBmbGFzaCB9KSA9PlxuICAgICAgdGhpcy5vblJlZGlyZWN0KHsgdG8sIGZsYXNoIH0pLFxuICAgICk7XG4gICAgdGhpcy5vbkNoYW5uZWwoXCJsaXZlX3BhdGNoXCIsIChyZWRpcikgPT4gdGhpcy5vbkxpdmVQYXRjaChyZWRpcikpO1xuICAgIHRoaXMub25DaGFubmVsKFwibGl2ZV9yZWRpcmVjdFwiLCAocmVkaXIpID0+IHRoaXMub25MaXZlUmVkaXJlY3QocmVkaXIpKTtcbiAgICB0aGlzLmNoYW5uZWwub25FcnJvcigocmVhc29uKSA9PiB0aGlzLm9uRXJyb3IocmVhc29uKSk7XG4gICAgdGhpcy5jaGFubmVsLm9uQ2xvc2UoKHJlYXNvbikgPT4gdGhpcy5vbkNsb3NlKHJlYXNvbikpO1xuICB9XG5cbiAgZGVzdHJveUFsbENoaWxkcmVuKCkge1xuICAgIHRoaXMuZWFjaENoaWxkKChjaGlsZCkgPT4gY2hpbGQuZGVzdHJveSgpKTtcbiAgfVxuXG4gIG9uTGl2ZVJlZGlyZWN0KHJlZGlyKSB7XG4gICAgY29uc3QgeyB0bywga2luZCwgZmxhc2ggfSA9IHJlZGlyO1xuICAgIGNvbnN0IHVybCA9IHRoaXMuZXhwYW5kVVJMKHRvKTtcbiAgICBjb25zdCBlID0gbmV3IEN1c3RvbUV2ZW50KFwicGh4OnNlcnZlci1uYXZpZ2F0ZVwiLCB7XG4gICAgICBkZXRhaWw6IHsgdG8sIGtpbmQsIGZsYXNoIH0sXG4gICAgfSk7XG4gICAgdGhpcy5saXZlU29ja2V0Lmhpc3RvcnlSZWRpcmVjdChlLCB1cmwsIGtpbmQsIGZsYXNoKTtcbiAgfVxuXG4gIG9uTGl2ZVBhdGNoKHJlZGlyKSB7XG4gICAgY29uc3QgeyB0bywga2luZCB9ID0gcmVkaXI7XG4gICAgdGhpcy5ocmVmID0gdGhpcy5leHBhbmRVUkwodG8pO1xuICAgIHRoaXMubGl2ZVNvY2tldC5oaXN0b3J5UGF0Y2godG8sIGtpbmQpO1xuICB9XG5cbiAgZXhwYW5kVVJMKHRvKSB7XG4gICAgcmV0dXJuIHRvLnN0YXJ0c1dpdGgoXCIvXCIpXG4gICAgICA/IGAke3dpbmRvdy5sb2NhdGlvbi5wcm90b2NvbH0vLyR7d2luZG93LmxvY2F0aW9uLmhvc3R9JHt0b31gXG4gICAgICA6IHRvO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7e3RvOiBzdHJpbmcsIGZsYXNoPzogc3RyaW5nLCByZWxvYWRUb2tlbj86IHN0cmluZ319IHJlZGlyZWN0XG4gICAqL1xuICBvblJlZGlyZWN0KHsgdG8sIGZsYXNoLCByZWxvYWRUb2tlbiB9KSB7XG4gICAgdGhpcy5saXZlU29ja2V0LnJlZGlyZWN0KHRvLCBmbGFzaCwgcmVsb2FkVG9rZW4pO1xuICB9XG5cbiAgaXNEZXN0cm95ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVzdHJveWVkO1xuICB9XG5cbiAgam9pbkRlYWQoKSB7XG4gICAgdGhpcy5pc0RlYWQgPSB0cnVlO1xuICB9XG5cbiAgam9pblB1c2goKSB7XG4gICAgdGhpcy5qb2luUHVzaCA9IHRoaXMuam9pblB1c2ggfHwgdGhpcy5jaGFubmVsLmpvaW4oKTtcbiAgICByZXR1cm4gdGhpcy5qb2luUHVzaDtcbiAgfVxuXG4gIGpvaW4oY2FsbGJhY2spIHtcbiAgICB0aGlzLnNob3dMb2FkZXIodGhpcy5saXZlU29ja2V0LmxvYWRlclRpbWVvdXQpO1xuICAgIHRoaXMuYmluZENoYW5uZWwoKTtcbiAgICBpZiAodGhpcy5pc01haW4oKSkge1xuICAgICAgdGhpcy5zdG9wQ2FsbGJhY2sgPSB0aGlzLmxpdmVTb2NrZXQud2l0aFBhZ2VMb2FkaW5nKHtcbiAgICAgICAgdG86IHRoaXMuaHJlZixcbiAgICAgICAga2luZDogXCJpbml0aWFsXCIsXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5qb2luQ2FsbGJhY2sgPSAob25Eb25lKSA9PiB7XG4gICAgICBvbkRvbmUgPSBvbkRvbmUgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICBjYWxsYmFjayA/IGNhbGxiYWNrKHRoaXMuam9pbkNvdW50LCBvbkRvbmUpIDogb25Eb25lKCk7XG4gICAgfTtcblxuICAgIHRoaXMud3JhcFB1c2goKCkgPT4gdGhpcy5jaGFubmVsLmpvaW4oKSwge1xuICAgICAgb2s6IChyZXNwKSA9PiB0aGlzLmxpdmVTb2NrZXQucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB0aGlzLm9uSm9pbihyZXNwKSksXG4gICAgICBlcnJvcjogKGVycm9yKSA9PiB0aGlzLm9uSm9pbkVycm9yKGVycm9yKSxcbiAgICAgIHRpbWVvdXQ6ICgpID0+IHRoaXMub25Kb2luRXJyb3IoeyByZWFzb246IFwidGltZW91dFwiIH0pLFxuICAgIH0pO1xuICB9XG5cbiAgb25Kb2luRXJyb3IocmVzcCkge1xuICAgIGlmIChyZXNwLnJlYXNvbiA9PT0gXCJyZWxvYWRcIikge1xuICAgICAgdGhpcy5sb2coXCJlcnJvclwiLCAoKSA9PiBbXG4gICAgICAgIGBmYWlsZWQgbW91bnQgd2l0aCAke3Jlc3Auc3RhdHVzfS4gRmFsbGluZyBiYWNrIHRvIHBhZ2UgcmVsb2FkYCxcbiAgICAgICAgcmVzcCxcbiAgICAgIF0pO1xuICAgICAgdGhpcy5vblJlZGlyZWN0KHtcbiAgICAgICAgdG86IHRoaXMubGl2ZVNvY2tldC5tYWluLmhyZWYsXG4gICAgICAgIHJlbG9hZFRva2VuOiByZXNwLnRva2VuLFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChyZXNwLnJlYXNvbiA9PT0gXCJ1bmF1dGhvcml6ZWRcIiB8fCByZXNwLnJlYXNvbiA9PT0gXCJzdGFsZVwiKSB7XG4gICAgICB0aGlzLmxvZyhcImVycm9yXCIsICgpID0+IFtcbiAgICAgICAgXCJ1bmF1dGhvcml6ZWQgbGl2ZV9yZWRpcmVjdC4gRmFsbGluZyBiYWNrIHRvIHBhZ2UgcmVxdWVzdFwiLFxuICAgICAgICByZXNwLFxuICAgICAgXSk7XG4gICAgICB0aGlzLm9uUmVkaXJlY3QoeyB0bzogdGhpcy5saXZlU29ja2V0Lm1haW4uaHJlZiwgZmxhc2g6IHRoaXMuZmxhc2ggfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyZXNwLnJlZGlyZWN0IHx8IHJlc3AubGl2ZV9yZWRpcmVjdCkge1xuICAgICAgdGhpcy5qb2luUGVuZGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5jaGFubmVsLmxlYXZlKCk7XG4gICAgfVxuICAgIGlmIChyZXNwLnJlZGlyZWN0KSB7XG4gICAgICByZXR1cm4gdGhpcy5vblJlZGlyZWN0KHJlc3AucmVkaXJlY3QpO1xuICAgIH1cbiAgICBpZiAocmVzcC5saXZlX3JlZGlyZWN0KSB7XG4gICAgICByZXR1cm4gdGhpcy5vbkxpdmVSZWRpcmVjdChyZXNwLmxpdmVfcmVkaXJlY3QpO1xuICAgIH1cbiAgICB0aGlzLmxvZyhcImVycm9yXCIsICgpID0+IFtcInVuYWJsZSB0byBqb2luXCIsIHJlc3BdKTtcbiAgICBpZiAodGhpcy5pc01haW4oKSkge1xuICAgICAgdGhpcy5kaXNwbGF5RXJyb3IoXG4gICAgICAgIFtQSFhfTE9BRElOR19DTEFTUywgUEhYX0VSUk9SX0NMQVNTLCBQSFhfU0VSVkVSX0VSUk9SX0NMQVNTXSxcbiAgICAgICAgeyB1bnN0cnVjdHVyZWRFcnJvcjogcmVzcCwgZXJyb3JLaW5kOiBcInNlcnZlclwiIH0sXG4gICAgICApO1xuICAgICAgaWYgKHRoaXMubGl2ZVNvY2tldC5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgIHRoaXMubGl2ZVNvY2tldC5yZWxvYWRXaXRoSml0dGVyKHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5qb2luQXR0ZW1wdHMgPj0gTUFYX0NISUxEX0pPSU5fQVRURU1QVFMpIHtcbiAgICAgICAgLy8gcHV0IHRoZSByb290IHJldmlldyBpbnRvIHBlcm1hbmVudCBlcnJvciBzdGF0ZSwgYnV0IGRvbid0IGRlc3Ryb3kgaXQgYXMgaXQgY2FuIHJlbWFpbiBhY3RpdmVcbiAgICAgICAgdGhpcy5yb290LmRpc3BsYXlFcnJvcihcbiAgICAgICAgICBbUEhYX0xPQURJTkdfQ0xBU1MsIFBIWF9FUlJPUl9DTEFTUywgUEhYX1NFUlZFUl9FUlJPUl9DTEFTU10sXG4gICAgICAgICAgeyB1bnN0cnVjdHVyZWRFcnJvcjogcmVzcCwgZXJyb3JLaW5kOiBcInNlcnZlclwiIH0sXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMubG9nKFwiZXJyb3JcIiwgKCkgPT4gW1xuICAgICAgICAgIGBnaXZpbmcgdXAgdHJ5aW5nIHRvIG1vdW50IGFmdGVyICR7TUFYX0NISUxEX0pPSU5fQVRURU1QVFN9IHRyaWVzYCxcbiAgICAgICAgICByZXNwLFxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICBjb25zdCB0cnVlQ2hpbGRFbCA9IERPTS5ieUlkKHRoaXMuZWwuaWQpO1xuICAgICAgaWYgKHRydWVDaGlsZEVsKSB7XG4gICAgICAgIERPTS5tZXJnZUF0dHJzKHRydWVDaGlsZEVsLCB0aGlzLmVsKTtcbiAgICAgICAgdGhpcy5kaXNwbGF5RXJyb3IoXG4gICAgICAgICAgW1BIWF9MT0FESU5HX0NMQVNTLCBQSFhfRVJST1JfQ0xBU1MsIFBIWF9TRVJWRVJfRVJST1JfQ0xBU1NdLFxuICAgICAgICAgIHsgdW5zdHJ1Y3R1cmVkRXJyb3I6IHJlc3AsIGVycm9yS2luZDogXCJzZXJ2ZXJcIiB9LFxuICAgICAgICApO1xuICAgICAgICB0aGlzLmVsID0gdHJ1ZUNoaWxkRWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkNsb3NlKHJlYXNvbikge1xuICAgIGlmICh0aGlzLmlzRGVzdHJveWVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgdGhpcy5pc01haW4oKSAmJlxuICAgICAgdGhpcy5saXZlU29ja2V0Lmhhc1BlbmRpbmdMaW5rKCkgJiZcbiAgICAgIHJlYXNvbiAhPT0gXCJsZWF2ZVwiXG4gICAgKSB7XG4gICAgICByZXR1cm4gdGhpcy5saXZlU29ja2V0LnJlbG9hZFdpdGhKaXR0ZXIodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuZGVzdHJveUFsbENoaWxkcmVuKCk7XG4gICAgdGhpcy5saXZlU29ja2V0LmRyb3BBY3RpdmVFbGVtZW50KHRoaXMpO1xuICAgIGlmICh0aGlzLmxpdmVTb2NrZXQuaXNVbmxvYWRlZCgpKSB7XG4gICAgICB0aGlzLnNob3dMb2FkZXIoQkVGT1JFX1VOTE9BRF9MT0FERVJfVElNRU9VVCk7XG4gICAgfVxuICB9XG5cbiAgb25FcnJvcihyZWFzb24pIHtcbiAgICB0aGlzLm9uQ2xvc2UocmVhc29uKTtcbiAgICBpZiAodGhpcy5saXZlU29ja2V0LmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgIHRoaXMubG9nKFwiZXJyb3JcIiwgKCkgPT4gW1widmlldyBjcmFzaGVkXCIsIHJlYXNvbl0pO1xuICAgIH1cbiAgICBpZiAoIXRoaXMubGl2ZVNvY2tldC5pc1VubG9hZGVkKCkpIHtcbiAgICAgIGlmICh0aGlzLmxpdmVTb2NrZXQuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICB0aGlzLmRpc3BsYXlFcnJvcihcbiAgICAgICAgICBbUEhYX0xPQURJTkdfQ0xBU1MsIFBIWF9FUlJPUl9DTEFTUywgUEhYX1NFUlZFUl9FUlJPUl9DTEFTU10sXG4gICAgICAgICAgeyB1bnN0cnVjdHVyZWRFcnJvcjogcmVhc29uLCBlcnJvcktpbmQ6IFwic2VydmVyXCIgfSxcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGlzcGxheUVycm9yKFxuICAgICAgICAgIFtQSFhfTE9BRElOR19DTEFTUywgUEhYX0VSUk9SX0NMQVNTLCBQSFhfQ0xJRU5UX0VSUk9SX0NMQVNTXSxcbiAgICAgICAgICB7IHVuc3RydWN0dXJlZEVycm9yOiByZWFzb24sIGVycm9yS2luZDogXCJjbGllbnRcIiB9LFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRpc3BsYXlFcnJvcihjbGFzc2VzLCBkZXRhaWxzID0ge30pIHtcbiAgICBpZiAodGhpcy5pc01haW4oKSkge1xuICAgICAgRE9NLmRpc3BhdGNoRXZlbnQod2luZG93LCBcInBoeDpwYWdlLWxvYWRpbmctc3RhcnRcIiwge1xuICAgICAgICBkZXRhaWw6IHsgdG86IHRoaXMuaHJlZiwga2luZDogXCJlcnJvclwiLCAuLi5kZXRhaWxzIH0sXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5zaG93TG9hZGVyKCk7XG4gICAgdGhpcy5zZXRDb250YWluZXJDbGFzc2VzKC4uLmNsYXNzZXMpO1xuICAgIHRoaXMuZGVsYXllZERpc2Nvbm5lY3RlZCgpO1xuICB9XG5cbiAgZGVsYXllZERpc2Nvbm5lY3RlZCgpIHtcbiAgICB0aGlzLmRpc2Nvbm5lY3RlZFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmV4ZWNBbGwodGhpcy5iaW5kaW5nKFwiZGlzY29ubmVjdGVkXCIpKTtcbiAgICB9LCB0aGlzLmxpdmVTb2NrZXQuZGlzY29ubmVjdGVkVGltZW91dCk7XG4gIH1cblxuICB3cmFwUHVzaChjYWxsZXJQdXNoLCByZWNlaXZlcykge1xuICAgIGNvbnN0IGxhdGVuY3kgPSB0aGlzLmxpdmVTb2NrZXQuZ2V0TGF0ZW5jeVNpbSgpO1xuICAgIGNvbnN0IHdpdGhMYXRlbmN5ID0gbGF0ZW5jeVxuICAgICAgPyAoY2IpID0+IHNldFRpbWVvdXQoKCkgPT4gIXRoaXMuaXNEZXN0cm95ZWQoKSAmJiBjYigpLCBsYXRlbmN5KVxuICAgICAgOiAoY2IpID0+ICF0aGlzLmlzRGVzdHJveWVkKCkgJiYgY2IoKTtcblxuICAgIHdpdGhMYXRlbmN5KCgpID0+IHtcbiAgICAgIGNhbGxlclB1c2goKVxuICAgICAgICAucmVjZWl2ZShcIm9rXCIsIChyZXNwKSA9PlxuICAgICAgICAgIHdpdGhMYXRlbmN5KCgpID0+IHJlY2VpdmVzLm9rICYmIHJlY2VpdmVzLm9rKHJlc3ApKSxcbiAgICAgICAgKVxuICAgICAgICAucmVjZWl2ZShcImVycm9yXCIsIChyZWFzb24pID0+XG4gICAgICAgICAgd2l0aExhdGVuY3koKCkgPT4gcmVjZWl2ZXMuZXJyb3IgJiYgcmVjZWl2ZXMuZXJyb3IocmVhc29uKSksXG4gICAgICAgIClcbiAgICAgICAgLnJlY2VpdmUoXCJ0aW1lb3V0XCIsICgpID0+XG4gICAgICAgICAgd2l0aExhdGVuY3koKCkgPT4gcmVjZWl2ZXMudGltZW91dCAmJiByZWNlaXZlcy50aW1lb3V0KCkpLFxuICAgICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgcHVzaFdpdGhSZXBseShyZWZHZW5lcmF0b3IsIGV2ZW50LCBwYXlsb2FkKSB7XG4gICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJubyBjb25uZWN0aW9uXCIpKTtcbiAgICB9XG5cbiAgICBjb25zdCBbcmVmLCBbZWxdLCBvcHRzXSA9IHJlZkdlbmVyYXRvclxuICAgICAgPyByZWZHZW5lcmF0b3IoeyBwYXlsb2FkIH0pXG4gICAgICA6IFtudWxsLCBbXSwge31dO1xuICAgIGNvbnN0IG9sZEpvaW5Db3VudCA9IHRoaXMuam9pbkNvdW50O1xuICAgIGxldCBvbkxvYWRpbmdEb25lID0gZnVuY3Rpb24gKCkge307XG4gICAgaWYgKG9wdHMucGFnZV9sb2FkaW5nKSB7XG4gICAgICBvbkxvYWRpbmdEb25lID0gdGhpcy5saXZlU29ja2V0LndpdGhQYWdlTG9hZGluZyh7XG4gICAgICAgIGtpbmQ6IFwiZWxlbWVudFwiLFxuICAgICAgICB0YXJnZXQ6IGVsLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwYXlsb2FkLmNpZCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgZGVsZXRlIHBheWxvYWQuY2lkO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLndyYXBQdXNoKCgpID0+IHRoaXMuY2hhbm5lbC5wdXNoKGV2ZW50LCBwYXlsb2FkLCBQVVNIX1RJTUVPVVQpLCB7XG4gICAgICAgIG9rOiAocmVzcCkgPT4ge1xuICAgICAgICAgIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEFja1JlZiA9IHJlZjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZmluaXNoID0gKGhvb2tSZXBseSkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3AucmVkaXJlY3QpIHtcbiAgICAgICAgICAgICAgdGhpcy5vblJlZGlyZWN0KHJlc3AucmVkaXJlY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3AubGl2ZV9wYXRjaCkge1xuICAgICAgICAgICAgICB0aGlzLm9uTGl2ZVBhdGNoKHJlc3AubGl2ZV9wYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzcC5saXZlX3JlZGlyZWN0KSB7XG4gICAgICAgICAgICAgIHRoaXMub25MaXZlUmVkaXJlY3QocmVzcC5saXZlX3JlZGlyZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uTG9hZGluZ0RvbmUoKTtcbiAgICAgICAgICAgIHJlc29sdmUoeyByZXNwOiByZXNwLCByZXBseTogaG9va1JlcGx5LCByZWYgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAocmVzcC5kaWZmKSB7XG4gICAgICAgICAgICB0aGlzLmxpdmVTb2NrZXQucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuYXBwbHlEaWZmKFwidXBkYXRlXCIsIHJlc3AuZGlmZiwgKHsgZGlmZiwgcmVwbHksIGV2ZW50cyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy51bmRvUmVmcyhyZWYsIHBheWxvYWQuZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZShkaWZmLCBldmVudHMpO1xuICAgICAgICAgICAgICAgIGZpbmlzaChyZXBseSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy51bmRvUmVmcyhyZWYsIHBheWxvYWQuZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluaXNoKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IChyZWFzb24pID0+XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgZmFpbGVkIHdpdGggcmVhc29uOiAke0pTT04uc3RyaW5naWZ5KHJlYXNvbil9YCkpLFxuICAgICAgICB0aW1lb3V0OiAoKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcInRpbWVvdXRcIikpO1xuICAgICAgICAgIGlmICh0aGlzLmpvaW5Db3VudCA9PT0gb2xkSm9pbkNvdW50KSB7XG4gICAgICAgICAgICB0aGlzLmxpdmVTb2NrZXQucmVsb2FkV2l0aEppdHRlcih0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMubG9nKFwidGltZW91dFwiLCAoKSA9PiBbXG4gICAgICAgICAgICAgICAgXCJyZWNlaXZlZCB0aW1lb3V0IHdoaWxlIGNvbW11bmljYXRpbmcgd2l0aCBzZXJ2ZXIuIEZhbGxpbmcgYmFjayB0byBoYXJkIHJlZnJlc2ggZm9yIHJlY292ZXJ5XCIsXG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICB1bmRvUmVmcyhyZWYsIHBoeEV2ZW50LCBvbmx5RWxzKSB7XG4gICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGV4aXQgaWYgZXh0ZXJuYWwgZm9ybSB0cmlnZ2VyZWRcbiAgICBjb25zdCBzZWxlY3RvciA9IGBbJHtQSFhfUkVGX1NSQ309XCIke3RoaXMucmVmU3JjKCl9XCJdYDtcblxuICAgIGlmIChvbmx5RWxzKSB7XG4gICAgICBvbmx5RWxzID0gbmV3IFNldChvbmx5RWxzKTtcbiAgICAgIERPTS5hbGwoZG9jdW1lbnQsIHNlbGVjdG9yLCAocGFyZW50KSA9PiB7XG4gICAgICAgIGlmIChvbmx5RWxzICYmICFvbmx5RWxzLmhhcyhwYXJlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVuZG8gYW55IGNoaWxkIHJlZnMgd2l0aGluIHBhcmVudCBmaXJzdFxuICAgICAgICBET00uYWxsKHBhcmVudCwgc2VsZWN0b3IsIChjaGlsZCkgPT5cbiAgICAgICAgICB0aGlzLnVuZG9FbFJlZihjaGlsZCwgcmVmLCBwaHhFdmVudCksXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMudW5kb0VsUmVmKHBhcmVudCwgcmVmLCBwaHhFdmVudCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgRE9NLmFsbChkb2N1bWVudCwgc2VsZWN0b3IsIChlbCkgPT4gdGhpcy51bmRvRWxSZWYoZWwsIHJlZiwgcGh4RXZlbnQpKTtcbiAgICB9XG4gIH1cblxuICB1bmRvRWxSZWYoZWwsIHJlZiwgcGh4RXZlbnQpIHtcbiAgICBjb25zdCBlbFJlZiA9IG5ldyBFbGVtZW50UmVmKGVsKTtcblxuICAgIGVsUmVmLm1heWJlVW5kbyhyZWYsIHBoeEV2ZW50LCAoY2xvbmVkVHJlZSkgPT4ge1xuICAgICAgLy8gd2UgbmVlZCB0byBwZXJmb3JtIGEgZnVsbCBwYXRjaCBvbiB1bmxvY2tlZCBlbGVtZW50c1xuICAgICAgLy8gdG8gcGVyZm9ybSBhbGwgdGhlIG5lY2Vzc2FyeSBsb2dpYyAobGlrZSBjYWxsaW5nIHVwZGF0ZWQgZm9yIGhvb2tzLCBldGMuKVxuICAgICAgY29uc3QgcGF0Y2ggPSBuZXcgRE9NUGF0Y2godGhpcywgZWwsIHRoaXMuaWQsIGNsb25lZFRyZWUsIFtdLCBudWxsLCB7XG4gICAgICAgIHVuZG9SZWY6IHJlZixcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcGh4Q2hpbGRyZW5BZGRlZCA9IHRoaXMucGVyZm9ybVBhdGNoKHBhdGNoLCB0cnVlKTtcbiAgICAgIERPTS5hbGwoZWwsIGBbJHtQSFhfUkVGX1NSQ309XCIke3RoaXMucmVmU3JjKCl9XCJdYCwgKGNoaWxkKSA9PlxuICAgICAgICB0aGlzLnVuZG9FbFJlZihjaGlsZCwgcmVmLCBwaHhFdmVudCksXG4gICAgICApO1xuICAgICAgaWYgKHBoeENoaWxkcmVuQWRkZWQpIHtcbiAgICAgICAgdGhpcy5qb2luTmV3Q2hpbGRyZW4oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJlZlNyYygpIHtcbiAgICByZXR1cm4gdGhpcy5lbC5pZDtcbiAgfVxuXG4gIHB1dFJlZihlbGVtZW50cywgcGh4RXZlbnQsIGV2ZW50VHlwZSwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgbmV3UmVmID0gdGhpcy5yZWYrKztcbiAgICBjb25zdCBkaXNhYmxlV2l0aCA9IHRoaXMuYmluZGluZyhQSFhfRElTQUJMRV9XSVRIKTtcbiAgICBpZiAob3B0cy5sb2FkaW5nKSB7XG4gICAgICBjb25zdCBsb2FkaW5nRWxzID0gRE9NLmFsbChkb2N1bWVudCwgb3B0cy5sb2FkaW5nKS5tYXAoKGVsKSA9PiB7XG4gICAgICAgIHJldHVybiB7IGVsLCBsb2NrOiB0cnVlLCBsb2FkaW5nOiB0cnVlIH07XG4gICAgICB9KTtcbiAgICAgIGVsZW1lbnRzID0gZWxlbWVudHMuY29uY2F0KGxvYWRpbmdFbHMpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgeyBlbCwgbG9jaywgbG9hZGluZyB9IG9mIGVsZW1lbnRzKSB7XG4gICAgICBpZiAoIWxvY2sgJiYgIWxvYWRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHV0UmVmIHJlcXVpcmVzIGxvY2sgb3IgbG9hZGluZ1wiKTtcbiAgICAgIH1cbiAgICAgIGVsLnNldEF0dHJpYnV0ZShQSFhfUkVGX1NSQywgdGhpcy5yZWZTcmMoKSk7XG4gICAgICBpZiAobG9hZGluZykge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoUEhYX1JFRl9MT0FESU5HLCBuZXdSZWYpO1xuICAgICAgfVxuICAgICAgaWYgKGxvY2spIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKFBIWF9SRUZfTE9DSywgbmV3UmVmKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICAhbG9hZGluZyB8fFxuICAgICAgICAob3B0cy5zdWJtaXR0ZXIgJiYgIShlbCA9PT0gb3B0cy5zdWJtaXR0ZXIgfHwgZWwgPT09IG9wdHMuZm9ybSkpXG4gICAgICApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvY2tDb21wbGV0ZVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGBwaHg6dW5kby1sb2NrOiR7bmV3UmVmfWAsICgpID0+IHJlc29sdmUoZGV0YWlsKSwge1xuICAgICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGxvYWRpbmdDb21wbGV0ZVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgIGBwaHg6dW5kby1sb2FkaW5nOiR7bmV3UmVmfWAsXG4gICAgICAgICAgKCkgPT4gcmVzb2x2ZShkZXRhaWwpLFxuICAgICAgICAgIHsgb25jZTogdHJ1ZSB9LFxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoYHBoeC0ke2V2ZW50VHlwZX0tbG9hZGluZ2ApO1xuICAgICAgY29uc3QgZGlzYWJsZVRleHQgPSBlbC5nZXRBdHRyaWJ1dGUoZGlzYWJsZVdpdGgpO1xuICAgICAgaWYgKGRpc2FibGVUZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmICghZWwuZ2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSkpIHtcbiAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVfV0lUSF9SRVNUT1JFLCBlbC50ZXh0Q29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpc2FibGVUZXh0ICE9PSBcIlwiKSB7XG4gICAgICAgICAgZWwudGV4dENvbnRlbnQgPSBkaXNhYmxlVGV4dDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQSFhfRElTQUJMRUQgY291bGQgaGF2ZSBhbHJlYWR5IGJlZW4gc2V0IGluIGRpc2FibGVGb3JtXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICBQSFhfRElTQUJMRUQsXG4gICAgICAgICAgZWwuZ2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFRCkgfHwgZWwuZGlzYWJsZWQsXG4gICAgICAgICk7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkZXRhaWwgPSB7XG4gICAgICAgIGV2ZW50OiBwaHhFdmVudCxcbiAgICAgICAgZXZlbnRUeXBlOiBldmVudFR5cGUsXG4gICAgICAgIHJlZjogbmV3UmVmLFxuICAgICAgICBpc0xvYWRpbmc6IGxvYWRpbmcsXG4gICAgICAgIGlzTG9ja2VkOiBsb2NrLFxuICAgICAgICBsb2NrRWxlbWVudHM6IGVsZW1lbnRzLmZpbHRlcigoeyBsb2NrIH0pID0+IGxvY2spLm1hcCgoeyBlbCB9KSA9PiBlbCksXG4gICAgICAgIGxvYWRpbmdFbGVtZW50czogZWxlbWVudHNcbiAgICAgICAgICAuZmlsdGVyKCh7IGxvYWRpbmcgfSkgPT4gbG9hZGluZylcbiAgICAgICAgICAubWFwKCh7IGVsIH0pID0+IGVsKSxcbiAgICAgICAgdW5sb2NrOiAoZWxzKSA9PiB7XG4gICAgICAgICAgZWxzID0gQXJyYXkuaXNBcnJheShlbHMpID8gZWxzIDogW2Vsc107XG4gICAgICAgICAgdGhpcy51bmRvUmVmcyhuZXdSZWYsIHBoeEV2ZW50LCBlbHMpO1xuICAgICAgICB9LFxuICAgICAgICBsb2NrQ29tcGxldGU6IGxvY2tDb21wbGV0ZVByb21pc2UsXG4gICAgICAgIGxvYWRpbmdDb21wbGV0ZTogbG9hZGluZ0NvbXBsZXRlUHJvbWlzZSxcbiAgICAgICAgbG9jazogKGxvY2tFbCkgPT4ge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNBY2tlZChuZXdSZWYpKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGRldGFpbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2NrRWwuc2V0QXR0cmlidXRlKFBIWF9SRUZfTE9DSywgbmV3UmVmKTtcbiAgICAgICAgICAgIGxvY2tFbC5zZXRBdHRyaWJ1dGUoUEhYX1JFRl9TUkMsIHRoaXMucmVmU3JjKCkpO1xuICAgICAgICAgICAgbG9ja0VsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgIGBwaHg6bG9jay1zdG9wOiR7bmV3UmVmfWAsXG4gICAgICAgICAgICAgICgpID0+IHJlc29sdmUoZGV0YWlsKSxcbiAgICAgICAgICAgICAgeyBvbmNlOiB0cnVlIH0sXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgfTtcbiAgICAgIGlmIChvcHRzLnBheWxvYWQpIHtcbiAgICAgICAgZGV0YWlsW1wicGF5bG9hZFwiXSA9IG9wdHMucGF5bG9hZDtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRzLnRhcmdldCkge1xuICAgICAgICBkZXRhaWxbXCJ0YXJnZXRcIl0gPSBvcHRzLnRhcmdldDtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRzLm9yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgZGV0YWlsW1wib3JpZ2luYWxFdmVudFwiXSA9IG9wdHMub3JpZ2luYWxFdmVudDtcbiAgICAgIH1cbiAgICAgIGVsLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgIG5ldyBDdXN0b21FdmVudChcInBoeDpwdXNoXCIsIHtcbiAgICAgICAgICBkZXRhaWw6IGRldGFpbCxcbiAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgICB9KSxcbiAgICAgICk7XG4gICAgICBpZiAocGh4RXZlbnQpIHtcbiAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICBuZXcgQ3VzdG9tRXZlbnQoYHBoeDpwdXNoOiR7cGh4RXZlbnR9YCwge1xuICAgICAgICAgICAgZGV0YWlsOiBkZXRhaWwsXG4gICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgICAgICAgfSksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbbmV3UmVmLCBlbGVtZW50cy5tYXAoKHsgZWwgfSkgPT4gZWwpLCBvcHRzXTtcbiAgfVxuXG4gIGlzQWNrZWQocmVmKSB7XG4gICAgcmV0dXJuIHRoaXMubGFzdEFja1JlZiAhPT0gbnVsbCAmJiB0aGlzLmxhc3RBY2tSZWYgPj0gcmVmO1xuICB9XG5cbiAgY29tcG9uZW50SUQoZWwpIHtcbiAgICBjb25zdCBjaWQgPSBlbC5nZXRBdHRyaWJ1dGUgJiYgZWwuZ2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQpO1xuICAgIHJldHVybiBjaWQgPyBwYXJzZUludChjaWQpIDogbnVsbDtcbiAgfVxuXG4gIHRhcmdldENvbXBvbmVudElEKHRhcmdldCwgdGFyZ2V0Q3R4LCBvcHRzID0ge30pIHtcbiAgICBpZiAoaXNDaWQodGFyZ2V0Q3R4KSkge1xuICAgICAgcmV0dXJuIHRhcmdldEN0eDtcbiAgICB9XG5cbiAgICBjb25zdCBjaWRPclNlbGVjdG9yID1cbiAgICAgIG9wdHMudGFyZ2V0IHx8IHRhcmdldC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFwidGFyZ2V0XCIpKTtcbiAgICBpZiAoaXNDaWQoY2lkT3JTZWxlY3RvcikpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChjaWRPclNlbGVjdG9yKTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldEN0eCAmJiAoY2lkT3JTZWxlY3RvciAhPT0gbnVsbCB8fCBvcHRzLnRhcmdldCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsb3Nlc3RDb21wb25lbnRJRCh0YXJnZXRDdHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBjbG9zZXN0Q29tcG9uZW50SUQodGFyZ2V0Q3R4KSB7XG4gICAgaWYgKGlzQ2lkKHRhcmdldEN0eCkpIHtcbiAgICAgIHJldHVybiB0YXJnZXRDdHg7XG4gICAgfSBlbHNlIGlmICh0YXJnZXRDdHgpIHtcbiAgICAgIHJldHVybiBtYXliZShcbiAgICAgICAgLy8gV2UgZWl0aGVyIHVzZSB0aGUgY2xvc2VzdCBkYXRhLXBoeC1jb21wb25lbnQgYmluZGluZywgb3IgLVxuICAgICAgICAvLyBpbiBjYXNlIG9mIHBvcnRhbHMgLSBjb250aW51ZSB3aXRoIHRoZSBwb3J0YWwgc291cmNlLlxuICAgICAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBpZiB0ZWxlcG9ydGluZyBhbiBlbGVtZW50IG91dHNpZGUgb2YgaXRzIExpdmVDb21wb25lbnQuXG4gICAgICAgIHRhcmdldEN0eC5jbG9zZXN0KGBbJHtQSFhfQ09NUE9ORU5UfV0sWyR7UEhYX1RFTEVQT1JURURfU1JDfV1gKSxcbiAgICAgICAgKGVsKSA9PiB7XG4gICAgICAgICAgLy8gRGVmYXVsdCBjYXNlLCBkaXJlY3QgY29tcG9uZW50LlxuICAgICAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm93bnNFbGVtZW50KGVsKSAmJiB0aGlzLmNvbXBvbmVudElEKGVsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVGVsZXBvcnRlZCwgc2VhcmNoIGZvciB0aGUgY2xvc2VzdCBsaXZlIGNvbXBvbmVudCBzdGFydGluZ1xuICAgICAgICAgIC8vIGF0IHRoZSBwb3J0YWwgc291cmNlLlxuICAgICAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoUEhYX1RFTEVQT1JURURfU1JDKSkge1xuICAgICAgICAgICAgY29uc3QgcG9ydGFsUGFyZW50ID0gRE9NLmJ5SWQoZWwuZ2V0QXR0cmlidXRlKFBIWF9URUxFUE9SVEVEX1NSQykpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2VzdENvbXBvbmVudElEKHBvcnRhbFBhcmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHVzaEhvb2tFdmVudChlbCwgdGFyZ2V0Q3R4LCBldmVudCwgcGF5bG9hZCkge1xuICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICB0aGlzLmxvZyhcImhvb2tcIiwgKCkgPT4gW1xuICAgICAgICBcInVuYWJsZSB0byBwdXNoIGhvb2sgZXZlbnQuIExpdmVWaWV3IG5vdCBjb25uZWN0ZWRcIixcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIHBheWxvYWQsXG4gICAgICBdKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgbmV3IEVycm9yKFwidW5hYmxlIHRvIHB1c2ggaG9vayBldmVudC4gTGl2ZVZpZXcgbm90IGNvbm5lY3RlZFwiKSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVmR2VuZXJhdG9yID0gKCkgPT5cbiAgICAgIHRoaXMucHV0UmVmKFt7IGVsLCBsb2FkaW5nOiB0cnVlLCBsb2NrOiB0cnVlIH1dLCBldmVudCwgXCJob29rXCIsIHtcbiAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgdGFyZ2V0OiB0YXJnZXRDdHgsXG4gICAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLnB1c2hXaXRoUmVwbHkocmVmR2VuZXJhdG9yLCBcImV2ZW50XCIsIHtcbiAgICAgIHR5cGU6IFwiaG9va1wiLFxuICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgdmFsdWU6IHBheWxvYWQsXG4gICAgICBjaWQ6IHRoaXMuY2xvc2VzdENvbXBvbmVudElEKHRhcmdldEN0eCksXG4gICAgfSkudGhlbigoeyByZXNwOiBfcmVzcCwgcmVwbHksIHJlZiB9KSA9PiAoeyByZXBseSwgcmVmIH0pKTtcbiAgfVxuXG4gIGV4dHJhY3RNZXRhKGVsLCBtZXRhLCB2YWx1ZSkge1xuICAgIGNvbnN0IHByZWZpeCA9IHRoaXMuYmluZGluZyhcInZhbHVlLVwiKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghbWV0YSkge1xuICAgICAgICBtZXRhID0ge307XG4gICAgICB9XG4gICAgICBjb25zdCBuYW1lID0gZWwuYXR0cmlidXRlc1tpXS5uYW1lO1xuICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICAgIG1ldGFbbmFtZS5yZXBsYWNlKHByZWZpeCwgXCJcIildID0gZWwuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZWwudmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhKGVsIGluc3RhbmNlb2YgSFRNTEZvcm1FbGVtZW50KSkge1xuICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgIG1ldGEgPSB7fTtcbiAgICAgIH1cbiAgICAgIG1ldGEudmFsdWUgPSBlbC52YWx1ZTtcblxuICAgICAgaWYgKFxuICAgICAgICBlbC50YWdOYW1lID09PSBcIklOUFVUXCIgJiZcbiAgICAgICAgQ0hFQ0tBQkxFX0lOUFVUUy5pbmRleE9mKGVsLnR5cGUpID49IDAgJiZcbiAgICAgICAgIWVsLmNoZWNrZWRcbiAgICAgICkge1xuICAgICAgICBkZWxldGUgbWV0YS52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBpZiAoIW1ldGEpIHtcbiAgICAgICAgbWV0YSA9IHt9O1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgbWV0YVtrZXldID0gdmFsdWVba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1ldGE7XG4gIH1cblxuICBwdXNoRXZlbnQodHlwZSwgZWwsIHRhcmdldEN0eCwgcGh4RXZlbnQsIG1ldGEsIG9wdHMgPSB7fSwgb25SZXBseSkge1xuICAgIHRoaXMucHVzaFdpdGhSZXBseShcbiAgICAgIChtYXliZVBheWxvYWQpID0+XG4gICAgICAgIHRoaXMucHV0UmVmKFt7IGVsLCBsb2FkaW5nOiB0cnVlLCBsb2NrOiB0cnVlIH1dLCBwaHhFdmVudCwgdHlwZSwge1xuICAgICAgICAgIC4uLm9wdHMsXG4gICAgICAgICAgcGF5bG9hZDogbWF5YmVQYXlsb2FkPy5wYXlsb2FkLFxuICAgICAgICB9KSxcbiAgICAgIFwiZXZlbnRcIixcbiAgICAgIHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgZXZlbnQ6IHBoeEV2ZW50LFxuICAgICAgICB2YWx1ZTogdGhpcy5leHRyYWN0TWV0YShlbCwgbWV0YSwgb3B0cy52YWx1ZSksXG4gICAgICAgIGNpZDogdGhpcy50YXJnZXRDb21wb25lbnRJRChlbCwgdGFyZ2V0Q3R4LCBvcHRzKSxcbiAgICAgIH0sXG4gICAgKVxuICAgICAgLnRoZW4oKHsgcmVwbHkgfSkgPT4gb25SZXBseSAmJiBvblJlcGx5KHJlcGx5KSlcbiAgICAgIC5jYXRjaCgoZXJyb3IpID0+IGxvZ0Vycm9yKFwiRmFpbGVkIHRvIHB1c2ggZXZlbnRcIiwgZXJyb3IpKTtcbiAgfVxuXG4gIHB1c2hGaWxlUHJvZ3Jlc3MoZmlsZUVsLCBlbnRyeVJlZiwgcHJvZ3Jlc3MsIG9uUmVwbHkgPSBmdW5jdGlvbiAoKSB7fSkge1xuICAgIHRoaXMubGl2ZVNvY2tldC53aXRoaW5Pd25lcnMoZmlsZUVsLmZvcm0sICh2aWV3LCB0YXJnZXRDdHgpID0+IHtcbiAgICAgIHZpZXdcbiAgICAgICAgLnB1c2hXaXRoUmVwbHkobnVsbCwgXCJwcm9ncmVzc1wiLCB7XG4gICAgICAgICAgZXZlbnQ6IGZpbGVFbC5nZXRBdHRyaWJ1dGUodmlldy5iaW5kaW5nKFBIWF9QUk9HUkVTUykpLFxuICAgICAgICAgIHJlZjogZmlsZUVsLmdldEF0dHJpYnV0ZShQSFhfVVBMT0FEX1JFRiksXG4gICAgICAgICAgZW50cnlfcmVmOiBlbnRyeVJlZixcbiAgICAgICAgICBwcm9ncmVzczogcHJvZ3Jlc3MsXG4gICAgICAgICAgY2lkOiB2aWV3LnRhcmdldENvbXBvbmVudElEKGZpbGVFbC5mb3JtLCB0YXJnZXRDdHgpLFxuICAgICAgICB9KVxuICAgICAgICAudGhlbigoKSA9PiBvblJlcGx5KCkpXG4gICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IGxvZ0Vycm9yKFwiRmFpbGVkIHRvIHB1c2ggZmlsZSBwcm9ncmVzc1wiLCBlcnJvcikpO1xuICAgIH0pO1xuICB9XG5cbiAgcHVzaElucHV0KGlucHV0RWwsIHRhcmdldEN0eCwgZm9yY2VDaWQsIHBoeEV2ZW50LCBvcHRzLCBjYWxsYmFjaykge1xuICAgIGlmICghaW5wdXRFbC5mb3JtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmb3JtIGV2ZW50cyByZXF1aXJlIHRoZSBpbnB1dCB0byBiZSBpbnNpZGUgYSBmb3JtXCIpO1xuICAgIH1cblxuICAgIGxldCB1cGxvYWRzO1xuICAgIGNvbnN0IGNpZCA9IGlzQ2lkKGZvcmNlQ2lkKVxuICAgICAgPyBmb3JjZUNpZFxuICAgICAgOiB0aGlzLnRhcmdldENvbXBvbmVudElEKGlucHV0RWwuZm9ybSwgdGFyZ2V0Q3R4LCBvcHRzKTtcbiAgICBjb25zdCByZWZHZW5lcmF0b3IgPSAobWF5YmVQYXlsb2FkKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5wdXRSZWYoXG4gICAgICAgIFtcbiAgICAgICAgICB7IGVsOiBpbnB1dEVsLCBsb2FkaW5nOiB0cnVlLCBsb2NrOiB0cnVlIH0sXG4gICAgICAgICAgeyBlbDogaW5wdXRFbC5mb3JtLCBsb2FkaW5nOiB0cnVlLCBsb2NrOiB0cnVlIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHBoeEV2ZW50LFxuICAgICAgICBcImNoYW5nZVwiLFxuICAgICAgICB7IC4uLm9wdHMsIHBheWxvYWQ6IG1heWJlUGF5bG9hZD8ucGF5bG9hZCB9LFxuICAgICAgKTtcbiAgICB9O1xuICAgIGxldCBmb3JtRGF0YTtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5leHRyYWN0TWV0YShpbnB1dEVsLmZvcm0sIHt9LCBvcHRzLnZhbHVlKTtcbiAgICBjb25zdCBzZXJpYWxpemVPcHRzID0ge307XG4gICAgaWYgKGlucHV0RWwgaW5zdGFuY2VvZiBIVE1MQnV0dG9uRWxlbWVudCkge1xuICAgICAgc2VyaWFsaXplT3B0cy5zdWJtaXR0ZXIgPSBpbnB1dEVsO1xuICAgIH1cbiAgICBpZiAoaW5wdXRFbC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFwiY2hhbmdlXCIpKSkge1xuICAgICAgZm9ybURhdGEgPSBzZXJpYWxpemVGb3JtKGlucHV0RWwuZm9ybSwgc2VyaWFsaXplT3B0cywgW2lucHV0RWwubmFtZV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JtRGF0YSA9IHNlcmlhbGl6ZUZvcm0oaW5wdXRFbC5mb3JtLCBzZXJpYWxpemVPcHRzKTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgRE9NLmlzVXBsb2FkSW5wdXQoaW5wdXRFbCkgJiZcbiAgICAgIGlucHV0RWwuZmlsZXMgJiZcbiAgICAgIGlucHV0RWwuZmlsZXMubGVuZ3RoID4gMFxuICAgICkge1xuICAgICAgTGl2ZVVwbG9hZGVyLnRyYWNrRmlsZXMoaW5wdXRFbCwgQXJyYXkuZnJvbShpbnB1dEVsLmZpbGVzKSk7XG4gICAgfVxuICAgIHVwbG9hZHMgPSBMaXZlVXBsb2FkZXIuc2VyaWFsaXplVXBsb2FkcyhpbnB1dEVsKTtcblxuICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgdHlwZTogXCJmb3JtXCIsXG4gICAgICBldmVudDogcGh4RXZlbnQsXG4gICAgICB2YWx1ZTogZm9ybURhdGEsXG4gICAgICBtZXRhOiB7XG4gICAgICAgIC8vIG5vIHRhcmdldCB3YXMgaW1wbGljaXRseSBzZW50IGFzIFwidW5kZWZpbmVkXCIgaW4gTFYgPD0gMS4wLjUsIHRoZXJlZm9yZVxuICAgICAgICAvLyB3ZSBoYXZlIHRvIGtlZXAgaXQuIEluIDEuMC42IHdlIHN3aXRjaGVkIGZyb20gcGFzc2luZyBtZXRhIGFzIFVSTCBlbmNvZGVkIGRhdGFcbiAgICAgICAgLy8gdG8gcGFzc2luZyBpdCBkaXJlY3RseSBpbiB0aGUgZXZlbnQsIGJ1dCB0aGUgSlNPTiBlbmNvZGUgd291bGQgZHJvcCBrZXlzIHdpdGhcbiAgICAgICAgLy8gdW5kZWZpbmVkIHZhbHVlcy5cbiAgICAgICAgX3RhcmdldDogb3B0cy5fdGFyZ2V0IHx8IFwidW5kZWZpbmVkXCIsXG4gICAgICAgIC4uLm1ldGEsXG4gICAgICB9LFxuICAgICAgdXBsb2FkczogdXBsb2FkcyxcbiAgICAgIGNpZDogY2lkLFxuICAgIH07XG4gICAgdGhpcy5wdXNoV2l0aFJlcGx5KHJlZkdlbmVyYXRvciwgXCJldmVudFwiLCBldmVudClcbiAgICAgIC50aGVuKCh7IHJlc3AgfSkgPT4ge1xuICAgICAgICBpZiAoRE9NLmlzVXBsb2FkSW5wdXQoaW5wdXRFbCkgJiYgRE9NLmlzQXV0b1VwbG9hZChpbnB1dEVsKSkge1xuICAgICAgICAgIC8vIHRoZSBlbGVtZW50IGNvdWxkIGJlIGluc2lkZSBhIGxvY2tlZCBwYXJlbnQgZm9yIG90aGVyIHVucmVsYXRlZCBjaGFuZ2VzO1xuICAgICAgICAgIC8vIHdlIGNhbiBvbmx5IHN0YXJ0IHVwbG9hZHMgd2hlbiB0aGUgdHJlZSBpcyB1bmxvY2tlZCBhbmQgdGhlXG4gICAgICAgICAgLy8gbmVjZXNzYXJ5IGRhdGEgYXR0cmlidXRlcyBhcmUgc2V0IGluIHRoZSByZWFsIERPTVxuICAgICAgICAgIEVsZW1lbnRSZWYub25VbmxvY2soaW5wdXRFbCwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKExpdmVVcGxvYWRlci5maWxlc0F3YWl0aW5nUHJlZmxpZ2h0KGlucHV0RWwpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgW3JlZiwgX2Vsc10gPSByZWZHZW5lcmF0b3IoKTtcbiAgICAgICAgICAgICAgdGhpcy51bmRvUmVmcyhyZWYsIHBoeEV2ZW50LCBbaW5wdXRFbC5mb3JtXSk7XG4gICAgICAgICAgICAgIHRoaXMudXBsb2FkRmlsZXMoXG4gICAgICAgICAgICAgICAgaW5wdXRFbC5mb3JtLFxuICAgICAgICAgICAgICAgIHBoeEV2ZW50LFxuICAgICAgICAgICAgICAgIHRhcmdldEN0eCxcbiAgICAgICAgICAgICAgICByZWYsXG4gICAgICAgICAgICAgICAgY2lkLFxuICAgICAgICAgICAgICAgIChfdXBsb2FkcykgPT4ge1xuICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2socmVzcCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJBd2FpdGluZ1N1Ym1pdChpbnB1dEVsLmZvcm0sIHBoeEV2ZW50KTtcbiAgICAgICAgICAgICAgICAgIHRoaXMudW5kb1JlZnMocmVmLCBwaHhFdmVudCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhyZXNwKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyb3IpID0+IGxvZ0Vycm9yKFwiRmFpbGVkIHRvIHB1c2ggaW5wdXQgZXZlbnRcIiwgZXJyb3IpKTtcbiAgfVxuXG4gIHRyaWdnZXJBd2FpdGluZ1N1Ym1pdChmb3JtRWwsIHBoeEV2ZW50KSB7XG4gICAgY29uc3QgYXdhaXRpbmdTdWJtaXQgPSB0aGlzLmdldFNjaGVkdWxlZFN1Ym1pdChmb3JtRWwpO1xuICAgIGlmIChhd2FpdGluZ1N1Ym1pdCkge1xuICAgICAgY29uc3QgW19lbCwgX3JlZiwgX29wdHMsIGNhbGxiYWNrXSA9IGF3YWl0aW5nU3VibWl0O1xuICAgICAgdGhpcy5jYW5jZWxTdWJtaXQoZm9ybUVsLCBwaHhFdmVudCk7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuXG4gIGdldFNjaGVkdWxlZFN1Ym1pdChmb3JtRWwpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JtU3VibWl0cy5maW5kKChbZWwsIF9yZWYsIF9vcHRzLCBfY2FsbGJhY2tdKSA9PlxuICAgICAgZWwuaXNTYW1lTm9kZShmb3JtRWwpLFxuICAgICk7XG4gIH1cblxuICBzY2hlZHVsZVN1Ym1pdChmb3JtRWwsIHJlZiwgb3B0cywgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5nZXRTY2hlZHVsZWRTdWJtaXQoZm9ybUVsKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRoaXMuZm9ybVN1Ym1pdHMucHVzaChbZm9ybUVsLCByZWYsIG9wdHMsIGNhbGxiYWNrXSk7XG4gIH1cblxuICBjYW5jZWxTdWJtaXQoZm9ybUVsLCBwaHhFdmVudCkge1xuICAgIHRoaXMuZm9ybVN1Ym1pdHMgPSB0aGlzLmZvcm1TdWJtaXRzLmZpbHRlcihcbiAgICAgIChbZWwsIHJlZiwgX29wdHMsIF9jYWxsYmFja10pID0+IHtcbiAgICAgICAgaWYgKGVsLmlzU2FtZU5vZGUoZm9ybUVsKSkge1xuICAgICAgICAgIHRoaXMudW5kb1JlZnMocmVmLCBwaHhFdmVudCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICk7XG4gIH1cblxuICBkaXNhYmxlRm9ybShmb3JtRWwsIHBoeEV2ZW50LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBmaWx0ZXJJZ25vcmVkID0gKGVsKSA9PiB7XG4gICAgICBjb25zdCB1c2VySWdub3JlZCA9IGNsb3Nlc3RQaHhCaW5kaW5nKFxuICAgICAgICBlbCxcbiAgICAgICAgYCR7dGhpcy5iaW5kaW5nKFBIWF9VUERBVEUpfT1pZ25vcmVgLFxuICAgICAgICBlbC5mb3JtLFxuICAgICAgKTtcbiAgICAgIHJldHVybiAhKFxuICAgICAgICB1c2VySWdub3JlZCB8fCBjbG9zZXN0UGh4QmluZGluZyhlbCwgXCJkYXRhLXBoeC11cGRhdGU9aWdub3JlXCIsIGVsLmZvcm0pXG4gICAgICApO1xuICAgIH07XG4gICAgY29uc3QgZmlsdGVyRGlzYWJsZXMgPSAoZWwpID0+IHtcbiAgICAgIHJldHVybiBlbC5oYXNBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9ESVNBQkxFX1dJVEgpKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbHRlckJ1dHRvbiA9IChlbCkgPT4gZWwudGFnTmFtZSA9PSBcIkJVVFRPTlwiO1xuXG4gICAgY29uc3QgZmlsdGVySW5wdXQgPSAoZWwpID0+XG4gICAgICBbXCJJTlBVVFwiLCBcIlRFWFRBUkVBXCIsIFwiU0VMRUNUXCJdLmluY2x1ZGVzKGVsLnRhZ05hbWUpO1xuXG4gICAgY29uc3QgZm9ybUVsZW1lbnRzID0gQXJyYXkuZnJvbShmb3JtRWwuZWxlbWVudHMpO1xuICAgIGNvbnN0IGRpc2FibGVzID0gZm9ybUVsZW1lbnRzLmZpbHRlcihmaWx0ZXJEaXNhYmxlcyk7XG4gICAgY29uc3QgYnV0dG9ucyA9IGZvcm1FbGVtZW50cy5maWx0ZXIoZmlsdGVyQnV0dG9uKS5maWx0ZXIoZmlsdGVySWdub3JlZCk7XG4gICAgY29uc3QgaW5wdXRzID0gZm9ybUVsZW1lbnRzLmZpbHRlcihmaWx0ZXJJbnB1dCkuZmlsdGVyKGZpbHRlcklnbm9yZWQpO1xuXG4gICAgYnV0dG9ucy5mb3JFYWNoKChidXR0b24pID0+IHtcbiAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVELCBidXR0b24uZGlzYWJsZWQpO1xuICAgICAgYnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBpbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShQSFhfUkVBRE9OTFksIGlucHV0LnJlYWRPbmx5KTtcbiAgICAgIGlucHV0LnJlYWRPbmx5ID0gdHJ1ZTtcbiAgICAgIGlmIChpbnB1dC5maWxlcykge1xuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVELCBpbnB1dC5kaXNhYmxlZCk7XG4gICAgICAgIGlucHV0LmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBmb3JtRWxzID0gZGlzYWJsZXNcbiAgICAgIC5jb25jYXQoYnV0dG9ucylcbiAgICAgIC5jb25jYXQoaW5wdXRzKVxuICAgICAgLm1hcCgoZWwpID0+IHtcbiAgICAgICAgcmV0dXJuIHsgZWwsIGxvYWRpbmc6IHRydWUsIGxvY2s6IHRydWUgfTtcbiAgICAgIH0pO1xuXG4gICAgLy8gd2UgcmV2ZXJzZSB0aGUgb3JkZXIgc28gZm9ybSBjaGlsZHJlbiBhcmUgYWxyZWFkeSBsb2NrZWQgYnkgdGhlIHRpbWVcbiAgICAvLyB0aGUgZm9ybSBpcyBsb2NrZWRcbiAgICBjb25zdCBlbHMgPSBbeyBlbDogZm9ybUVsLCBsb2FkaW5nOiB0cnVlLCBsb2NrOiBmYWxzZSB9XVxuICAgICAgLmNvbmNhdChmb3JtRWxzKVxuICAgICAgLnJldmVyc2UoKTtcbiAgICByZXR1cm4gdGhpcy5wdXRSZWYoZWxzLCBwaHhFdmVudCwgXCJzdWJtaXRcIiwgb3B0cyk7XG4gIH1cblxuICBwdXNoRm9ybVN1Ym1pdChmb3JtRWwsIHRhcmdldEN0eCwgcGh4RXZlbnQsIHN1Ym1pdHRlciwgb3B0cywgb25SZXBseSkge1xuICAgIGNvbnN0IHJlZkdlbmVyYXRvciA9IChtYXliZVBheWxvYWQpID0+XG4gICAgICB0aGlzLmRpc2FibGVGb3JtKGZvcm1FbCwgcGh4RXZlbnQsIHtcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgZm9ybTogZm9ybUVsLFxuICAgICAgICBwYXlsb2FkOiBtYXliZVBheWxvYWQ/LnBheWxvYWQsXG4gICAgICAgIHN1Ym1pdHRlcjogc3VibWl0dGVyLFxuICAgICAgfSk7XG4gICAgLy8gc3RvcmUgdGhlIHN1Ym1pdHRlciBpbiB0aGUgZm9ybSBlbGVtZW50IGluIG9yZGVyIHRvIHRyaWdnZXIgaXRcbiAgICAvLyBmb3IgcGh4LXRyaWdnZXItYWN0aW9uXG4gICAgRE9NLnB1dFByaXZhdGUoZm9ybUVsLCBcInN1Ym1pdHRlclwiLCBzdWJtaXR0ZXIpO1xuICAgIGNvbnN0IGNpZCA9IHRoaXMudGFyZ2V0Q29tcG9uZW50SUQoZm9ybUVsLCB0YXJnZXRDdHgpO1xuICAgIGlmIChMaXZlVXBsb2FkZXIuaGFzVXBsb2Fkc0luUHJvZ3Jlc3MoZm9ybUVsKSkge1xuICAgICAgY29uc3QgW3JlZiwgX2Vsc10gPSByZWZHZW5lcmF0b3IoKTtcbiAgICAgIGNvbnN0IHB1c2ggPSAoKSA9PlxuICAgICAgICB0aGlzLnB1c2hGb3JtU3VibWl0KFxuICAgICAgICAgIGZvcm1FbCxcbiAgICAgICAgICB0YXJnZXRDdHgsXG4gICAgICAgICAgcGh4RXZlbnQsXG4gICAgICAgICAgc3VibWl0dGVyLFxuICAgICAgICAgIG9wdHMsXG4gICAgICAgICAgb25SZXBseSxcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlU3VibWl0KGZvcm1FbCwgcmVmLCBvcHRzLCBwdXNoKTtcbiAgICB9IGVsc2UgaWYgKExpdmVVcGxvYWRlci5pbnB1dHNBd2FpdGluZ1ByZWZsaWdodChmb3JtRWwpLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IFtyZWYsIGVsc10gPSByZWZHZW5lcmF0b3IoKTtcbiAgICAgIGNvbnN0IHByb3h5UmVmR2VuID0gKCkgPT4gW3JlZiwgZWxzLCBvcHRzXTtcbiAgICAgIHRoaXMudXBsb2FkRmlsZXMoZm9ybUVsLCBwaHhFdmVudCwgdGFyZ2V0Q3R4LCByZWYsIGNpZCwgKF91cGxvYWRzKSA9PiB7XG4gICAgICAgIC8vIGlmIHdlIHN0aWxsIGhhdmluZyBwZW5kaW5nIHByZWZsaWdodHMgaXQgbWVhbnMgd2UgaGF2ZSBpbnZhbGlkIGVudHJpZXNcbiAgICAgICAgLy8gYW5kIHRoZSBwaHgtc3VibWl0IGNhbm5vdCBiZSBjb21wbGV0ZWRcbiAgICAgICAgaWYgKExpdmVVcGxvYWRlci5pbnB1dHNBd2FpdGluZ1ByZWZsaWdodChmb3JtRWwpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy51bmRvUmVmcyhyZWYsIHBoeEV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5leHRyYWN0TWV0YShmb3JtRWwsIHt9LCBvcHRzLnZhbHVlKTtcbiAgICAgICAgY29uc3QgZm9ybURhdGEgPSBzZXJpYWxpemVGb3JtKGZvcm1FbCwgeyBzdWJtaXR0ZXIgfSk7XG4gICAgICAgIHRoaXMucHVzaFdpdGhSZXBseShwcm94eVJlZkdlbiwgXCJldmVudFwiLCB7XG4gICAgICAgICAgdHlwZTogXCJmb3JtXCIsXG4gICAgICAgICAgZXZlbnQ6IHBoeEV2ZW50LFxuICAgICAgICAgIHZhbHVlOiBmb3JtRGF0YSxcbiAgICAgICAgICBtZXRhOiBtZXRhLFxuICAgICAgICAgIGNpZDogY2lkLFxuICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKCh7IHJlc3AgfSkgPT4gb25SZXBseShyZXNwKSlcbiAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiBsb2dFcnJvcihcIkZhaWxlZCB0byBwdXNoIGZvcm0gc3VibWl0XCIsIGVycm9yKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgIShcbiAgICAgICAgZm9ybUVsLmhhc0F0dHJpYnV0ZShQSFhfUkVGX1NSQykgJiZcbiAgICAgICAgZm9ybUVsLmNsYXNzTGlzdC5jb250YWlucyhcInBoeC1zdWJtaXQtbG9hZGluZ1wiKVxuICAgICAgKVxuICAgICkge1xuICAgICAgY29uc3QgbWV0YSA9IHRoaXMuZXh0cmFjdE1ldGEoZm9ybUVsLCB7fSwgb3B0cy52YWx1ZSk7XG4gICAgICBjb25zdCBmb3JtRGF0YSA9IHNlcmlhbGl6ZUZvcm0oZm9ybUVsLCB7IHN1Ym1pdHRlciB9KTtcbiAgICAgIHRoaXMucHVzaFdpdGhSZXBseShyZWZHZW5lcmF0b3IsIFwiZXZlbnRcIiwge1xuICAgICAgICB0eXBlOiBcImZvcm1cIixcbiAgICAgICAgZXZlbnQ6IHBoeEV2ZW50LFxuICAgICAgICB2YWx1ZTogZm9ybURhdGEsXG4gICAgICAgIG1ldGE6IG1ldGEsXG4gICAgICAgIGNpZDogY2lkLFxuICAgICAgfSlcbiAgICAgICAgLnRoZW4oKHsgcmVzcCB9KSA9PiBvblJlcGx5KHJlc3ApKVxuICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiBsb2dFcnJvcihcIkZhaWxlZCB0byBwdXNoIGZvcm0gc3VibWl0XCIsIGVycm9yKSk7XG4gICAgfVxuICB9XG5cbiAgdXBsb2FkRmlsZXMoZm9ybUVsLCBwaHhFdmVudCwgdGFyZ2V0Q3R4LCByZWYsIGNpZCwgb25Db21wbGV0ZSkge1xuICAgIGNvbnN0IGpvaW5Db3VudEF0VXBsb2FkID0gdGhpcy5qb2luQ291bnQ7XG4gICAgY29uc3QgaW5wdXRFbHMgPSBMaXZlVXBsb2FkZXIuYWN0aXZlRmlsZUlucHV0cyhmb3JtRWwpO1xuICAgIGxldCBudW1GaWxlSW5wdXRzSW5Qcm9ncmVzcyA9IGlucHV0RWxzLmxlbmd0aDtcblxuICAgIC8vIGdldCBlYWNoIGZpbGUgaW5wdXRcbiAgICBpbnB1dEVscy5mb3JFYWNoKChpbnB1dEVsKSA9PiB7XG4gICAgICBjb25zdCB1cGxvYWRlciA9IG5ldyBMaXZlVXBsb2FkZXIoaW5wdXRFbCwgdGhpcywgKCkgPT4ge1xuICAgICAgICBudW1GaWxlSW5wdXRzSW5Qcm9ncmVzcy0tO1xuICAgICAgICBpZiAobnVtRmlsZUlucHV0c0luUHJvZ3Jlc3MgPT09IDApIHtcbiAgICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBlbnRyaWVzID0gdXBsb2FkZXJcbiAgICAgICAgLmVudHJpZXMoKVxuICAgICAgICAubWFwKChlbnRyeSkgPT4gZW50cnkudG9QcmVmbGlnaHRQYXlsb2FkKCkpO1xuXG4gICAgICBpZiAoZW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbnVtRmlsZUlucHV0c0luUHJvZ3Jlc3MtLTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICByZWY6IGlucHV0RWwuZ2V0QXR0cmlidXRlKFBIWF9VUExPQURfUkVGKSxcbiAgICAgICAgZW50cmllczogZW50cmllcyxcbiAgICAgICAgY2lkOiB0aGlzLnRhcmdldENvbXBvbmVudElEKGlucHV0RWwuZm9ybSwgdGFyZ2V0Q3R4KSxcbiAgICAgIH07XG5cbiAgICAgIHRoaXMubG9nKFwidXBsb2FkXCIsICgpID0+IFtcInNlbmRpbmcgcHJlZmxpZ2h0IHJlcXVlc3RcIiwgcGF5bG9hZF0pO1xuXG4gICAgICB0aGlzLnB1c2hXaXRoUmVwbHkobnVsbCwgXCJhbGxvd191cGxvYWRcIiwgcGF5bG9hZClcbiAgICAgICAgLnRoZW4oKHsgcmVzcCB9KSA9PiB7XG4gICAgICAgICAgdGhpcy5sb2coXCJ1cGxvYWRcIiwgKCkgPT4gW1wiZ290IHByZWZsaWdodCByZXNwb25zZVwiLCByZXNwXSk7XG4gICAgICAgICAgLy8gdGhlIHByZWZsaWdodCB3aWxsIHJlamVjdCBlbnRyaWVzIGJleW9uZCB0aGUgbWF4IGVudHJpZXNcbiAgICAgICAgICAvLyBzbyB3ZSBlcnJvciBhbmQgY2FuY2VsIGVudHJpZXMgb24gdGhlIGNsaWVudCB0aGF0IGFyZSBtaXNzaW5nIGZyb20gdGhlIHJlc3BvbnNlXG4gICAgICAgICAgdXBsb2FkZXIuZW50cmllcygpLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzcC5lbnRyaWVzICYmICFyZXNwLmVudHJpZXNbZW50cnkucmVmXSkge1xuICAgICAgICAgICAgICB0aGlzLmhhbmRsZUZhaWxlZEVudHJ5UHJlZmxpZ2h0KFxuICAgICAgICAgICAgICAgIGVudHJ5LnJlZixcbiAgICAgICAgICAgICAgICBcImZhaWxlZCBwcmVmbGlnaHRcIixcbiAgICAgICAgICAgICAgICB1cGxvYWRlcixcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBmb3IgYXV0byB1cGxvYWRzLCB3ZSBtYXkgaGF2ZSBhbiBlbXB0eSBlbnRyaWVzIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlclxuICAgICAgICAgIC8vIGZvciBmb3JtIHN1Ym1pdHMgdGhhdCBjb250YWluIGludmFsaWQgZW50cmllc1xuICAgICAgICAgIGlmIChyZXNwLmVycm9yIHx8IE9iamVjdC5rZXlzKHJlc3AuZW50cmllcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnVuZG9SZWZzKHJlZiwgcGh4RXZlbnQpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gcmVzcC5lcnJvciB8fCBbXTtcbiAgICAgICAgICAgIGVycm9ycy5tYXAoKFtlbnRyeV9yZWYsIHJlYXNvbl0pID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5oYW5kbGVGYWlsZWRFbnRyeVByZWZsaWdodChlbnRyeV9yZWYsIHJlYXNvbiwgdXBsb2FkZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG9uRXJyb3IgPSAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5jaGFubmVsLm9uRXJyb3IoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmpvaW5Db3VudCA9PT0gam9pbkNvdW50QXRVcGxvYWQpIHtcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB1cGxvYWRlci5pbml0QWRhcHRlclVwbG9hZChyZXNwLCBvbkVycm9yLCB0aGlzLmxpdmVTb2NrZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnJvcikgPT4gbG9nRXJyb3IoXCJGYWlsZWQgdG8gcHVzaCB1cGxvYWRcIiwgZXJyb3IpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGhhbmRsZUZhaWxlZEVudHJ5UHJlZmxpZ2h0KHVwbG9hZFJlZiwgcmVhc29uLCB1cGxvYWRlcikge1xuICAgIGlmICh1cGxvYWRlci5pc0F1dG9VcGxvYWQoKSkge1xuICAgICAgLy8gdXBsb2FkUmVmIG1heSBiZSB0b3AgbGV2ZWwgdXBsb2FkIGNvbmZpZyByZWYgb3IgZW50cnkgcmVmXG4gICAgICBjb25zdCBlbnRyeSA9IHVwbG9hZGVyXG4gICAgICAgIC5lbnRyaWVzKClcbiAgICAgICAgLmZpbmQoKGVudHJ5KSA9PiBlbnRyeS5yZWYgPT09IHVwbG9hZFJlZi50b1N0cmluZygpKTtcbiAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICBlbnRyeS5jYW5jZWwoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdXBsb2FkZXIuZW50cmllcygpLm1hcCgoZW50cnkpID0+IGVudHJ5LmNhbmNlbCgpKTtcbiAgICB9XG4gICAgdGhpcy5sb2coXCJ1cGxvYWRcIiwgKCkgPT4gW2BlcnJvciBmb3IgZW50cnkgJHt1cGxvYWRSZWZ9YCwgcmVhc29uXSk7XG4gIH1cblxuICBkaXNwYXRjaFVwbG9hZHModGFyZ2V0Q3R4LCBuYW1lLCBmaWxlc09yQmxvYnMpIHtcbiAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gdGhpcy50YXJnZXRDdHhFbGVtZW50KHRhcmdldEN0eCkgfHwgdGhpcy5lbDtcbiAgICBjb25zdCBpbnB1dHMgPSBET00uZmluZFVwbG9hZElucHV0cyh0YXJnZXRFbGVtZW50KS5maWx0ZXIoXG4gICAgICAoZWwpID0+IGVsLm5hbWUgPT09IG5hbWUsXG4gICAgKTtcbiAgICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbG9nRXJyb3IoYG5vIGxpdmUgZmlsZSBpbnB1dHMgZm91bmQgbWF0Y2hpbmcgdGhlIG5hbWUgXCIke25hbWV9XCJgKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0cy5sZW5ndGggPiAxKSB7XG4gICAgICBsb2dFcnJvcihgZHVwbGljYXRlIGxpdmUgZmlsZSBpbnB1dHMgZm91bmQgbWF0Y2hpbmcgdGhlIG5hbWUgXCIke25hbWV9XCJgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgRE9NLmRpc3BhdGNoRXZlbnQoaW5wdXRzWzBdLCBQSFhfVFJBQ0tfVVBMT0FEUywge1xuICAgICAgICBkZXRhaWw6IHsgZmlsZXM6IGZpbGVzT3JCbG9icyB9LFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0Q3R4RWxlbWVudCh0YXJnZXRDdHgpIHtcbiAgICBpZiAoaXNDaWQodGFyZ2V0Q3R4KSkge1xuICAgICAgY29uc3QgW3RhcmdldF0gPSBET00uZmluZENvbXBvbmVudE5vZGVMaXN0KHRoaXMuaWQsIHRhcmdldEN0eCk7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0Q3R4KSB7XG4gICAgICByZXR1cm4gdGFyZ2V0Q3R4O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwdXNoRm9ybVJlY292ZXJ5KG9sZEZvcm0sIG5ld0Zvcm0sIHRlbXBsYXRlRG9tLCBjYWxsYmFjaykge1xuICAgIC8vIHdlIGFyZSBvbmx5IHJlY292ZXJpbmcgZm9ybXMgaW5zaWRlIHRoZSBjdXJyZW50IHZpZXcsIHRoZXJlZm9yZSBpdCBpcyBzYWZlIHRvXG4gICAgLy8gc2tpcCB3aXRoaW5Pd25lcnMgaGVyZSBhbmQgYWx3YXlzIHVzZSB0aGlzIHdoZW4gcmVmZXJyaW5nIHRvIHRoZSB2aWV3XG4gICAgY29uc3QgcGh4Q2hhbmdlID0gdGhpcy5iaW5kaW5nKFwiY2hhbmdlXCIpO1xuICAgIGNvbnN0IHBoeFRhcmdldCA9IG5ld0Zvcm0uZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhcInRhcmdldFwiKSkgfHwgbmV3Rm9ybTtcbiAgICBjb25zdCBwaHhFdmVudCA9XG4gICAgICBuZXdGb3JtLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0FVVE9fUkVDT1ZFUikpIHx8XG4gICAgICBuZXdGb3JtLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJjaGFuZ2VcIikpO1xuICAgIGNvbnN0IGlucHV0cyA9IEFycmF5LmZyb20ob2xkRm9ybS5lbGVtZW50cykuZmlsdGVyKFxuICAgICAgKGVsKSA9PiBET00uaXNGb3JtSW5wdXQoZWwpICYmIGVsLm5hbWUgJiYgIWVsLmhhc0F0dHJpYnV0ZShwaHhDaGFuZ2UpLFxuICAgICk7XG4gICAgaWYgKGlucHV0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gd2UgbXVzdCBjbGVhciB0cmFja2VkIHVwbG9hZHMgYmVmb3JlIHJlY292ZXJ5IGFzIHRoZXkgbm8gbG9uZ2VyIGhhdmUgdmFsaWQgcmVmc1xuICAgIGlucHV0cy5mb3JFYWNoKFxuICAgICAgKGlucHV0KSA9PlxuICAgICAgICBpbnB1dC5oYXNBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpICYmIExpdmVVcGxvYWRlci5jbGVhckZpbGVzKGlucHV0KSxcbiAgICApO1xuICAgIC8vIHB1c2hJbnB1dCBhc3N1bWVzIHRoYXQgdGhlcmUgaXMgYSBzb3VyY2UgZWxlbWVudCB0aGF0IGluaXRpYXRlZCB0aGUgY2hhbmdlO1xuICAgIC8vIGJlY2F1c2UgdGhpcyBpcyBub3QgdGhlIGNhc2Ugd2hlbiB3ZSByZWNvdmVyIGZvcm1zLCB3ZSBwcm92aWRlIHRoZSBmaXJzdCBpbnB1dCB3ZSBmaW5kXG4gICAgY29uc3QgaW5wdXQgPSBpbnB1dHMuZmluZCgoZWwpID0+IGVsLnR5cGUgIT09IFwiaGlkZGVuXCIpIHx8IGlucHV0c1swXTtcblxuICAgIC8vIGluIHRoZSBjYXNlIHRoYXQgdGhlcmUgYXJlIG11bHRpcGxlIHRhcmdldHMsIHdlIGNvdW50IHRoZSBudW1iZXIgb2YgcGVuZGluZyByZWNvdmVyeSBldmVudHNcbiAgICAvLyBhbmQgb25seSBjYWxsIHRoZSBjYWxsYmFjayBvbmNlIGFsbCBldmVudHMgaGF2ZSBiZWVuIHByb2Nlc3NlZFxuICAgIGxldCBwZW5kaW5nID0gMDtcbiAgICAvLyB3aXRoaW5UYXJnZXRzKHBoeFRhcmdldCwgY2FsbGJhY2ssIGRvbSwgdmlld0VsKVxuICAgIHRoaXMud2l0aGluVGFyZ2V0cyhcbiAgICAgIHBoeFRhcmdldCxcbiAgICAgICh0YXJnZXRWaWV3LCB0YXJnZXRDdHgpID0+IHtcbiAgICAgICAgY29uc3QgY2lkID0gdGhpcy50YXJnZXRDb21wb25lbnRJRChuZXdGb3JtLCB0YXJnZXRDdHgpO1xuICAgICAgICBwZW5kaW5nKys7XG4gICAgICAgIGxldCBlID0gbmV3IEN1c3RvbUV2ZW50KFwicGh4OmZvcm0tcmVjb3ZlcnlcIiwge1xuICAgICAgICAgIGRldGFpbDogeyBzb3VyY2VFbGVtZW50OiBvbGRGb3JtIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBKUy5leGVjKGUsIFwiY2hhbmdlXCIsIHBoeEV2ZW50LCB0aGlzLCBpbnB1dCwgW1xuICAgICAgICAgIFwicHVzaFwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIF90YXJnZXQ6IGlucHV0Lm5hbWUsXG4gICAgICAgICAgICB0YXJnZXRWaWV3LFxuICAgICAgICAgICAgdGFyZ2V0Q3R4LFxuICAgICAgICAgICAgbmV3Q2lkOiBjaWQsXG4gICAgICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgICAgICBwZW5kaW5nLS07XG4gICAgICAgICAgICAgIGlmIChwZW5kaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICAgIH0sXG4gICAgICB0ZW1wbGF0ZURvbSxcbiAgICApO1xuICB9XG5cbiAgcHVzaExpbmtQYXRjaChlLCBocmVmLCB0YXJnZXRFbCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBsaW5rUmVmID0gdGhpcy5saXZlU29ja2V0LnNldFBlbmRpbmdMaW5rKGhyZWYpO1xuICAgIC8vIG9ubHkgYWRkIGxvYWRpbmcgc3RhdGVzIGlmIGV2ZW50IGlzIHRydXN0ZWQgKGl0IHdhcyB0cmlnZ2VyZWQgYnkgdXNlciwgc3VjaCBhcyBjbGljaykgYW5kXG4gICAgLy8gaXQncyBub3QgYSBmb3J3YXJkL2JhY2sgbmF2aWdhdGlvbiBmcm9tIHBvcHN0YXRlXG4gICAgY29uc3QgbG9hZGluZyA9IGUuaXNUcnVzdGVkICYmIGUudHlwZSAhPT0gXCJwb3BzdGF0ZVwiO1xuICAgIGNvbnN0IHJlZkdlbiA9IHRhcmdldEVsXG4gICAgICA/ICgpID0+XG4gICAgICAgICAgdGhpcy5wdXRSZWYoXG4gICAgICAgICAgICBbeyBlbDogdGFyZ2V0RWwsIGxvYWRpbmc6IGxvYWRpbmcsIGxvY2s6IHRydWUgfV0sXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgXCJjbGlja1wiLFxuICAgICAgICAgIClcbiAgICAgIDogbnVsbDtcbiAgICBjb25zdCBmYWxsYmFjayA9ICgpID0+IHRoaXMubGl2ZVNvY2tldC5yZWRpcmVjdCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgY29uc3QgdXJsID0gaHJlZi5zdGFydHNXaXRoKFwiL1wiKVxuICAgICAgPyBgJHtsb2NhdGlvbi5wcm90b2NvbH0vLyR7bG9jYXRpb24uaG9zdH0ke2hyZWZ9YFxuICAgICAgOiBocmVmO1xuXG4gICAgdGhpcy5wdXNoV2l0aFJlcGx5KHJlZkdlbiwgXCJsaXZlX3BhdGNoXCIsIHsgdXJsIH0pLnRoZW4oXG4gICAgICAoeyByZXNwIH0pID0+IHtcbiAgICAgICAgdGhpcy5saXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICAgIGlmIChyZXNwLmxpbmtfcmVkaXJlY3QpIHtcbiAgICAgICAgICAgIHRoaXMubGl2ZVNvY2tldC5yZXBsYWNlTWFpbihocmVmLCBudWxsLCBjYWxsYmFjaywgbGlua1JlZik7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXNwLnJlZGlyZWN0KSB7XG4gICAgICAgICAgICAvLyBoYW5kbGVkIGJ5IGJpbmRDaGFubmVsXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpdmVTb2NrZXQuY29tbWl0UGVuZGluZ0xpbmsobGlua1JlZikpIHtcbiAgICAgICAgICAgICAgdGhpcy5ocmVmID0gaHJlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXBwbHlQZW5kaW5nVXBkYXRlcygpO1xuICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sobGlua1JlZik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICAoeyBlcnJvcjogX2Vycm9yLCB0aW1lb3V0OiBfdGltZW91dCB9KSA9PiBmYWxsYmFjaygpLFxuICAgICk7XG4gIH1cblxuICBnZXRGb3Jtc0ZvclJlY292ZXJ5KCkge1xuICAgIC8vIEZvcm0gcmVjb3ZlcnkgaXMgY29tcGxleCBpbiBMaXZlVmlldzpcbiAgICAvLyBXZSB3YW50IHRvIHN1cHBvcnQgbmVzdGVkIExpdmVWaWV3cyBhbmQgYWxzbyBwcm92aWRlIGEgZ29vZCB1c2VyIGV4cGVyaWVuY2UuXG4gICAgLy8gVGhlcmVmb3JlLCB3aGVuIHRoZSBjaGFubmVsIHJlam9pbnMsIHdlIGNvcHkgYWxsIGZvcm1zIHRoYXQgYXJlIGVsaWdpYmxlIGZvclxuICAgIC8vIHJlY292ZXJ5IHRvIGJlIGFibGUgdG8gYWNjZXNzIHRoZW0gbGF0ZXIuXG4gICAgLy8gV2h5IGRvIHdlIG5lZWQgdG8gY29weSB0aGVtPyBCZWNhdXNlIHdoZW4gdGhlIG1haW4gTGl2ZVZpZXcgam9pbnMsIGFueSBmb3Jtc1xuICAgIC8vIGluIG5lc3RlZCBMaXZlVmlld3Mgd291bGQgYmUgbG9zdC5cbiAgICAvL1xuICAgIC8vIFdlIHNob3VsZCByZXdvcmsgdGhpcyBpbiB0aGUgZnV0dXJlIHRvIHNlcmlhbGl6ZSB0aGUgZm9ybSBwYXlsb2FkIGhlcmVcbiAgICAvLyBpbnN0ZWFkIG9mIGNsb25pbmcgdGhlIERPTSBub2RlcywgYnV0IG1ha2luZyB0aGlzIHdvcmsgY29ycmVjdGx5IGlzIHRlZGlvdXMsXG4gICAgLy8gYXMgc2VuZGluZyB0aGUgY29ycmVjdCBmb3JtIHBheWxvYWQgcmVsaWVzIG9uIEpTLnB1c2ggdG8gZXh0cmFjdCB2YWx1ZXNcbiAgICAvLyBmcm9tIEpTIGNvbW1hbmRzIChwaHgtY2hhbmdlPXtKUy5wdXNoKFwiZXZlbnRcIiwgdmFsdWU6IC4uLiwgdGFyZ2V0OiAuLi4pfSksXG4gICAgLy8gYXMgd2VsbCBhcyB2aWV3LnB1c2hJbnB1dCwgd2hpY2ggZXhwZWN0cyBET00gZWxlbWVudHMuXG5cbiAgICBpZiAodGhpcy5qb2luQ291bnQgPT09IDApIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICBjb25zdCBwaHhDaGFuZ2UgPSB0aGlzLmJpbmRpbmcoXCJjaGFuZ2VcIik7XG5cbiAgICByZXR1cm4gRE9NLmFsbChcbiAgICAgIGRvY3VtZW50LFxuICAgICAgYCMke0NTUy5lc2NhcGUodGhpcy5pZCl9IGZvcm1bJHtwaHhDaGFuZ2V9XSwgWyR7UEhYX1RFTEVQT1JURURfUkVGfT1cIiR7Q1NTLmVzY2FwZSh0aGlzLmlkKX1cIl0gZm9ybVske3BoeENoYW5nZX1dYCxcbiAgICApXG4gICAgICAuZmlsdGVyKChmb3JtKSA9PiBmb3JtLmlkKVxuICAgICAgLmZpbHRlcigoZm9ybSkgPT4gZm9ybS5lbGVtZW50cy5sZW5ndGggPiAwKVxuICAgICAgLmZpbHRlcihcbiAgICAgICAgKGZvcm0pID0+XG4gICAgICAgICAgZm9ybS5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9BVVRPX1JFQ09WRVIpKSAhPT0gXCJpZ25vcmVcIixcbiAgICAgIClcbiAgICAgIC5tYXAoKGZvcm0pID0+IHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBjbG9uZSB0aGUgd2hvbGUgZm9ybSwgYXMgcmVseWluZyBvbiBmb3JtLmVsZW1lbnRzIGNhbiBsZWFkIHRvXG4gICAgICAgIC8vIHNpdHVhdGlvbnMgd2hlcmUgd2UgaGF2ZVxuICAgICAgICAvL1xuICAgICAgICAvLyAgIDxmb3JtPjxmaWVsZHNldCBkaXNhYmxlZD48aW5wdXQgbmFtZT1cImZvb1wiIHZhbHVlPVwiYmFyXCI+PC9maWVsZHNldD48L2Zvcm0+XG4gICAgICAgIC8vXG4gICAgICAgIC8vIGFuZCBmb3JtLmVsZW1lbnRzIHJldHVybnMgYm90aCB0aGUgZmllbGRzZXQgYW5kIHRoZSBpbnB1dCBzZXBhcmF0ZWx5LlxuICAgICAgICAvLyBCZWNhdXNlIHRoZSBmaWVsZHNldCBpcyBkaXNhYmxlZCwgdGhlIGlucHV0IHNob3VsZCBOT1QgYmUgc2VudCB0aG91Z2guXG4gICAgICAgIC8vIFdlIGNhbiBvbmx5IHJlbGlhYmx5IHNlcmlhbGl6ZSB0aGUgZm9ybSBieSBjbG9uaW5nIGl0IGZ1bGx5LlxuICAgICAgICBjb25zdCBjbG9uZWRGb3JtID0gZm9ybS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgIC8vIHdlIGNhbGwgbW9ycGhkb20gdG8gY29weSBhbnkgc3BlY2lhbCBzdGF0ZVxuICAgICAgICAvLyBsaWtlIHRoZSBzZWxlY3RlZCBvcHRpb24gb2YgYSA8c2VsZWN0PiBlbGVtZW50O1xuICAgICAgICAvLyBhbnkgYWxzbyBjb3B5IG92ZXIgcHJpdmF0ZXMgKHdoaWNoIGNvbnRhaW4gaW5mb3JtYXRpb24gYWJvdXQgdG91Y2hlZCBmaWVsZHMpXG4gICAgICAgIG1vcnBoZG9tKGNsb25lZEZvcm0sIGZvcm0sIHtcbiAgICAgICAgICBvbkJlZm9yZUVsVXBkYXRlZDogKGZyb21FbCwgdG9FbCkgPT4ge1xuICAgICAgICAgICAgRE9NLmNvcHlQcml2YXRlcyhmcm9tRWwsIHRvRWwpO1xuICAgICAgICAgICAgaWYgKGZyb21FbC5nZXRBdHRyaWJ1dGUoXCJmb3JtXCIpID09PSBmb3JtLmlkKSB7XG4gICAgICAgICAgICAgIC8vIEluIGNhc2UgdGhlIGZvcm0gY29udGFpbnMgYW4gZWxlbWVudCB3aXRoIGZvcm09XCJpZFwiIHBvaW50aW5nXG4gICAgICAgICAgICAgIC8vIHRvIHRoZSBmb3JtIGl0c2VsZiwgZmlyZWZveCBzdGlsbCBhc3NvY2lhdGVzIHRoZSBlbGVtZW50IHdpdGggdGhlXG4gICAgICAgICAgICAgIC8vIG9yaWdpbmFsIGZvcm0gZWxlbWVudC4gVGhpcyBpcyBub3QgZml4ZWQgYnkgcmVtb3ZpbmcgdGhlIHBhcmFtZXRlcixcbiAgICAgICAgICAgICAgLy8gaW5zdGVhZCB3ZSByZW1vdmUgdGhlIGVsZW1lbnQgZnJvbSB0aGUgZm9ybSBhbmQgYWRkIGl0IGFnYWluIHdpdGhvdXRcbiAgICAgICAgICAgICAgLy8gZm9ybSBwYXJhbWV0ZXIgYmVsb3cuXG4gICAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3Bob2VuaXhmcmFtZXdvcmsvcGhvZW5peF9saXZlX3ZpZXcvaXNzdWVzLzQwMjFcbiAgICAgICAgICAgICAgZnJvbUVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZnJvbUVsKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIG5leHQgdXAsIHdlIGFsc28gbmVlZCB0byBjbG9uZSBhbnkgZWxlbWVudHMgd2l0aCBmb3JtPVwiaWRcIiBwYXJhbWV0ZXJcbiAgICAgICAgY29uc3QgZXh0ZXJuYWxFbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgYFtmb3JtPVwiJHtDU1MuZXNjYXBlKGZvcm0uaWQpfVwiXWAsXG4gICAgICAgICk7XG4gICAgICAgIEFycmF5LmZyb20oZXh0ZXJuYWxFbGVtZW50cykuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgICBjb25zdCBjbG9uZWRFbCA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovIChlbC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgICAgIG1vcnBoZG9tKGNsb25lZEVsLCBlbCk7XG4gICAgICAgICAgRE9NLmNvcHlQcml2YXRlcyhjbG9uZWRFbCwgZWwpO1xuICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhvZW5peGZyYW1ld29yay9waG9lbml4X2xpdmVfdmlldy9pc3N1ZXMvNDAyMVxuICAgICAgICAgIGNsb25lZEVsLnJlbW92ZUF0dHJpYnV0ZShcImZvcm1cIik7XG4gICAgICAgICAgY2xvbmVkRm9ybS5hcHBlbmRDaGlsZChjbG9uZWRFbCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xvbmVkRm9ybTtcbiAgICAgIH0pXG4gICAgICAucmVkdWNlKChhY2MsIGZvcm0pID0+IHtcbiAgICAgICAgYWNjW2Zvcm0uaWRdID0gZm9ybTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIHt9KTtcbiAgfVxuXG4gIG1heWJlUHVzaENvbXBvbmVudHNEZXN0cm95ZWQoZGVzdHJveWVkQ0lEcykge1xuICAgIGxldCB3aWxsRGVzdHJveUNJRHMgPSBkZXN0cm95ZWRDSURzLmZpbHRlcigoY2lkKSA9PiB7XG4gICAgICByZXR1cm4gRE9NLmZpbmRDb21wb25lbnROb2RlTGlzdCh0aGlzLmlkLCBjaWQpLmxlbmd0aCA9PT0gMDtcbiAgICB9KTtcblxuICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgIGlmICghdGhpcy5pc0Rlc3Ryb3llZCgpKSB7XG4gICAgICAgIGxvZ0Vycm9yKFwiRmFpbGVkIHRvIHB1c2ggY29tcG9uZW50cyBkZXN0cm95ZWRcIiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAod2lsbERlc3Ryb3lDSURzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIHdlIG11c3QgcmVzZXQgdGhlIHJlbmRlciBjaGFuZ2UgdHJhY2tpbmcgZm9yIGNpZHMgdGhhdFxuICAgICAgLy8gY291bGQgYmUgYWRkZWQgYmFjayBmcm9tIHRoZSBzZXJ2ZXIgc28gd2UgZG9uJ3Qgc2tpcCB0aGVtXG4gICAgICB3aWxsRGVzdHJveUNJRHMuZm9yRWFjaCgoY2lkKSA9PiB0aGlzLnJlbmRlcmVkLnJlc2V0UmVuZGVyKGNpZCkpO1xuXG4gICAgICB0aGlzLnB1c2hXaXRoUmVwbHkobnVsbCwgXCJjaWRzX3dpbGxfZGVzdHJveVwiLCB7IGNpZHM6IHdpbGxEZXN0cm95Q0lEcyB9KVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgLy8gd2UgbXVzdCB3YWl0IGZvciBwZW5kaW5nIHRyYW5zaXRpb25zIHRvIGNvbXBsZXRlIGJlZm9yZSBkZXRlcm1pbmluZ1xuICAgICAgICAgIC8vIGlmIHRoZSBjaWRzIHdlcmUgYWRkZWQgYmFjayB0byB0aGUgRE9NIGluIHRoZSBtZWFudGltZSAoIzMxMzkpXG4gICAgICAgICAgdGhpcy5saXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgLy8gU2VlIGlmIGFueSBvZiB0aGUgY2lkcyB3ZSB3YW50ZWQgdG8gZGVzdHJveSB3ZXJlIGFkZGVkIGJhY2ssXG4gICAgICAgICAgICAvLyBpZiB0aGV5IHdlcmUgYWRkZWQgYmFjaywgd2UgZG9uJ3QgYWN0dWFsbHkgZGVzdHJveSB0aGVtLlxuICAgICAgICAgICAgbGV0IGNvbXBsZXRlbHlEZXN0cm95Q0lEcyA9IHdpbGxEZXN0cm95Q0lEcy5maWx0ZXIoKGNpZCkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gRE9NLmZpbmRDb21wb25lbnROb2RlTGlzdCh0aGlzLmlkLCBjaWQpLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoY29tcGxldGVseURlc3Ryb3lDSURzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KG51bGwsIFwiY2lkc19kZXN0cm95ZWRcIiwge1xuICAgICAgICAgICAgICAgIGNpZHM6IGNvbXBsZXRlbHlEZXN0cm95Q0lEcyxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoeyByZXNwIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZWQucHJ1bmVDSURzKHJlc3AuY2lkcyk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2gob25FcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChvbkVycm9yKTtcbiAgICB9XG4gIH1cblxuICBvd25zRWxlbWVudChlbCkge1xuICAgIGxldCBwYXJlbnRWaWV3RWwgPSBET00uY2xvc2VzdFZpZXdFbChlbCk7XG4gICAgcmV0dXJuIChcbiAgICAgIGVsLmdldEF0dHJpYnV0ZShQSFhfUEFSRU5UX0lEKSA9PT0gdGhpcy5pZCB8fFxuICAgICAgKHBhcmVudFZpZXdFbCAmJiBwYXJlbnRWaWV3RWwuaWQgPT09IHRoaXMuaWQpIHx8XG4gICAgICAoIXBhcmVudFZpZXdFbCAmJiB0aGlzLmlzRGVhZClcbiAgICApO1xuICB9XG5cbiAgc3VibWl0Rm9ybShmb3JtLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBzdWJtaXR0ZXIsIG9wdHMgPSB7fSkge1xuICAgIERPTS5wdXRQcml2YXRlKGZvcm0sIFBIWF9IQVNfU1VCTUlUVEVELCB0cnVlKTtcbiAgICBjb25zdCBpbnB1dHMgPSBBcnJheS5mcm9tKGZvcm0uZWxlbWVudHMpO1xuICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4gRE9NLnB1dFByaXZhdGUoaW5wdXQsIFBIWF9IQVNfU1VCTUlUVEVELCB0cnVlKSk7XG4gICAgdGhpcy5saXZlU29ja2V0LmJsdXJBY3RpdmVFbGVtZW50KHRoaXMpO1xuICAgIHRoaXMucHVzaEZvcm1TdWJtaXQoZm9ybSwgdGFyZ2V0Q3R4LCBwaHhFdmVudCwgc3VibWl0dGVyLCBvcHRzLCAoKSA9PiB7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQucmVzdG9yZVByZXZpb3VzbHlBY3RpdmVGb2N1cygpO1xuICAgIH0pO1xuICB9XG5cbiAgYmluZGluZyhraW5kKSB7XG4gICAgcmV0dXJuIHRoaXMubGl2ZVNvY2tldC5iaW5kaW5nKGtpbmQpO1xuICB9XG5cbiAgLy8gcGh4LXBvcnRhbFxuICBwdXNoUG9ydGFsRWxlbWVudElkKGlkKSB7XG4gICAgdGhpcy5wb3J0YWxFbGVtZW50SWRzLmFkZChpZCk7XG4gIH1cblxuICBkcm9wUG9ydGFsRWxlbWVudElkKGlkKSB7XG4gICAgdGhpcy5wb3J0YWxFbGVtZW50SWRzLmRlbGV0ZShpZCk7XG4gIH1cblxuICBkZXN0cm95UG9ydGFsRWxlbWVudHMoKSB7XG4gICAgLy8gV2Ugb25seSB1bmxvYWQgdGhlIHNvY2tldCBpZiB3ZSBuYXZpZ2F0ZSBhd2F5XG4gICAgLy8gKGZvciBleGFtcGxlIGZvciBhIGZvcm0gc3VibWl0IG9yIGV4dGVybmFsIG5hdmlnYXRpb24pXG4gICAgLy8gc28gdGhlcmUncyBubyBuZWVkIHRvIHJlbW92ZSBwb3J0YWwgZWxlbWVudHMuXG4gICAgLy8gSW4gZmFjdCwgd2UgYWN0dWFsbHkgbmVlZCB0byBrZWVwIHRoZSBwb3J0YWwgZWxlbWVudHMgaW5cbiAgICAvLyBjYXNlIHRoaXMgaXMgYW4gZXh0ZXJuYWwgZm9ybSBzdWJtaXNzaW9uIGZyb20gYSB0ZWxlcG9ydGVkIGZvcm0uXG4gICAgaWYgKCF0aGlzLmxpdmVTb2NrZXQudW5sb2FkZWQpIHtcbiAgICAgIHRoaXMucG9ydGFsRWxlbWVudElkcy5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgICBjb25zdCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgZWwucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIEJJTkRJTkdfUFJFRklYLFxuICBDT05TRUNVVElWRV9SRUxPQURTLFxuICBERUZBVUxUUyxcbiAgRkFJTFNBRkVfSklUVEVSLFxuICBMT0FERVJfVElNRU9VVCxcbiAgRElTQ09OTkVDVEVEX1RJTUVPVVQsXG4gIE1BWF9SRUxPQURTLFxuICBQSFhfREVCT1VOQ0UsXG4gIFBIWF9EUk9QX1RBUkdFVCxcbiAgUEhYX0hBU19GT0NVU0VELFxuICBQSFhfS0VZLFxuICBQSFhfTElOS19TVEFURSxcbiAgUEhYX0xJVkVfTElOSyxcbiAgUEhYX0xWX0RFQlVHLFxuICBQSFhfTFZfTEFURU5DWV9TSU0sXG4gIFBIWF9MVl9QUk9GSUxFLFxuICBQSFhfTFZfSElTVE9SWV9QT1NJVElPTixcbiAgUEhYX01BSU4sXG4gIFBIWF9QQVJFTlRfSUQsXG4gIFBIWF9WSUVXX1NFTEVDVE9SLFxuICBQSFhfUk9PVF9JRCxcbiAgUEhYX1RIUk9UVExFLFxuICBQSFhfVFJBQ0tfVVBMT0FEUyxcbiAgUEhYX1NFU1NJT04sXG4gIFJFTE9BRF9KSVRURVJfTUlOLFxuICBSRUxPQURfSklUVEVSX01BWCxcbiAgUEhYX1JFRl9TUkMsXG4gIFBIWF9SRUxPQURfU1RBVFVTLFxuICBQSFhfUlVOVElNRV9IT09LLFxuICBQSFhfRFJPUF9UQVJHRVRfQUNUSVZFX0NMQVNTLFxufSBmcm9tIFwiLi9jb25zdGFudHNcIjtcblxuaW1wb3J0IHtcbiAgY2xvbmUsXG4gIGNsb3Nlc3RQaHhCaW5kaW5nLFxuICBjbG9zdXJlLFxuICBkZWJ1ZyxcbiAgbWF5YmUsXG4gIGxvZ0Vycm9yLFxuICBldmVudENvbnRhaW5zRmlsZXMsXG59IGZyb20gXCIuL3V0aWxzXCI7XG5cbmltcG9ydCBCcm93c2VyIGZyb20gXCIuL2Jyb3dzZXJcIjtcbmltcG9ydCBET00gZnJvbSBcIi4vZG9tXCI7XG5pbXBvcnQgSG9va3MgZnJvbSBcIi4vaG9va3NcIjtcbmltcG9ydCBMaXZlVXBsb2FkZXIgZnJvbSBcIi4vbGl2ZV91cGxvYWRlclwiO1xuaW1wb3J0IFZpZXcgZnJvbSBcIi4vdmlld1wiO1xuaW1wb3J0IEpTIGZyb20gXCIuL2pzXCI7XG5pbXBvcnQganNDb21tYW5kcyBmcm9tIFwiLi9qc19jb21tYW5kc1wiO1xuXG5leHBvcnQgY29uc3QgaXNVc2VkSW5wdXQgPSAoZWwpID0+IERPTS5pc1VzZWRJbnB1dChlbCk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpdmVTb2NrZXQge1xuICBjb25zdHJ1Y3Rvcih1cmwsIHBoeFNvY2tldCwgb3B0cyA9IHt9KSB7XG4gICAgdGhpcy51bmxvYWRlZCA9IGZhbHNlO1xuICAgIGlmICghcGh4U29ja2V0IHx8IHBoeFNvY2tldC5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIk9iamVjdFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFxuICAgICAgYSBwaG9lbml4IFNvY2tldCBtdXN0IGJlIHByb3ZpZGVkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gdGhlIExpdmVTb2NrZXQgY29uc3RydWN0b3IuIEZvciBleGFtcGxlOlxuXG4gICAgICAgICAgaW1wb3J0IHtTb2NrZXR9IGZyb20gXCJwaG9lbml4XCJcbiAgICAgICAgICBpbXBvcnQge0xpdmVTb2NrZXR9IGZyb20gXCJwaG9lbml4X2xpdmVfdmlld1wiXG4gICAgICAgICAgbGV0IGxpdmVTb2NrZXQgPSBuZXcgTGl2ZVNvY2tldChcIi9saXZlXCIsIFNvY2tldCwgey4uLn0pXG4gICAgICBgKTtcbiAgICB9XG4gICAgdGhpcy5zb2NrZXQgPSBuZXcgcGh4U29ja2V0KHVybCwgb3B0cyk7XG4gICAgdGhpcy5iaW5kaW5nUHJlZml4ID0gb3B0cy5iaW5kaW5nUHJlZml4IHx8IEJJTkRJTkdfUFJFRklYO1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgdGhpcy5wYXJhbXMgPSBjbG9zdXJlKG9wdHMucGFyYW1zIHx8IHt9KTtcbiAgICB0aGlzLnZpZXdMb2dnZXIgPSBvcHRzLnZpZXdMb2dnZXI7XG4gICAgdGhpcy5tZXRhZGF0YUNhbGxiYWNrcyA9IG9wdHMubWV0YWRhdGEgfHwge307XG4gICAgdGhpcy5kZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oY2xvbmUoREVGQVVMVFMpLCBvcHRzLmRlZmF1bHRzIHx8IHt9KTtcbiAgICB0aGlzLnByZXZBY3RpdmUgPSBudWxsO1xuICAgIHRoaXMuc2lsZW5jZWQgPSBmYWxzZTtcbiAgICB0aGlzLm1haW4gPSBudWxsO1xuICAgIHRoaXMub3V0Z29pbmdNYWluRWwgPSBudWxsO1xuICAgIHRoaXMuY2xpY2tTdGFydGVkQXRUYXJnZXQgPSBudWxsO1xuICAgIHRoaXMubGlua1JlZiA9IDE7XG4gICAgdGhpcy5yb290cyA9IHt9O1xuICAgIHRoaXMuaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICAgIHRoaXMucGVuZGluZ0xpbmsgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudExvY2F0aW9uID0gY2xvbmUod2luZG93LmxvY2F0aW9uKTtcbiAgICB0aGlzLmhvb2tzID0gb3B0cy5ob29rcyB8fCB7fTtcbiAgICB0aGlzLnVwbG9hZGVycyA9IG9wdHMudXBsb2FkZXJzIHx8IHt9O1xuICAgIHRoaXMubG9hZGVyVGltZW91dCA9IG9wdHMubG9hZGVyVGltZW91dCB8fCBMT0FERVJfVElNRU9VVDtcbiAgICB0aGlzLmRpc2Nvbm5lY3RlZFRpbWVvdXQgPSBvcHRzLmRpc2Nvbm5lY3RlZFRpbWVvdXQgfHwgRElTQ09OTkVDVEVEX1RJTUVPVVQ7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1JldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+IHwgbnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJlbG9hZFdpdGhKaXR0ZXJUaW1lciA9IG51bGw7XG4gICAgdGhpcy5tYXhSZWxvYWRzID0gb3B0cy5tYXhSZWxvYWRzIHx8IE1BWF9SRUxPQURTO1xuICAgIHRoaXMucmVsb2FkSml0dGVyTWluID0gb3B0cy5yZWxvYWRKaXR0ZXJNaW4gfHwgUkVMT0FEX0pJVFRFUl9NSU47XG4gICAgdGhpcy5yZWxvYWRKaXR0ZXJNYXggPSBvcHRzLnJlbG9hZEppdHRlck1heCB8fCBSRUxPQURfSklUVEVSX01BWDtcbiAgICB0aGlzLmZhaWxzYWZlSml0dGVyID0gb3B0cy5mYWlsc2FmZUppdHRlciB8fCBGQUlMU0FGRV9KSVRURVI7XG4gICAgdGhpcy5sb2NhbFN0b3JhZ2UgPSBvcHRzLmxvY2FsU3RvcmFnZSB8fCB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICAgIHRoaXMuc2Vzc2lvblN0b3JhZ2UgPSBvcHRzLnNlc3Npb25TdG9yYWdlIHx8IHdpbmRvdy5zZXNzaW9uU3RvcmFnZTtcbiAgICB0aGlzLmJvdW5kVG9wTGV2ZWxFdmVudHMgPSBmYWxzZTtcbiAgICB0aGlzLmJvdW5kRXZlbnROYW1lcyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmJsb2NrUGh4Q2hhbmdlV2hpbGVDb21wb3NpbmcgPVxuICAgICAgb3B0cy5ibG9ja1BoeENoYW5nZVdoaWxlQ29tcG9zaW5nIHx8IGZhbHNlO1xuICAgIHRoaXMuc2VydmVyQ2xvc2VSZWYgPSBudWxsO1xuICAgIHRoaXMuZG9tQ2FsbGJhY2tzID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHtcbiAgICAgICAganNRdWVyeVNlbGVjdG9yQWxsOiBudWxsLFxuICAgICAgICBvblBhdGNoU3RhcnQ6IGNsb3N1cmUoKSxcbiAgICAgICAgb25QYXRjaEVuZDogY2xvc3VyZSgpLFxuICAgICAgICBvbk5vZGVBZGRlZDogY2xvc3VyZSgpLFxuICAgICAgICBvbkJlZm9yZUVsVXBkYXRlZDogY2xvc3VyZSgpLFxuICAgICAgfSxcbiAgICAgIG9wdHMuZG9tIHx8IHt9LFxuICAgICk7XG4gICAgdGhpcy50cmFuc2l0aW9ucyA9IG5ldyBUcmFuc2l0aW9uU2V0KCk7XG4gICAgdGhpcy5jdXJyZW50SGlzdG9yeVBvc2l0aW9uID1cbiAgICAgIHBhcnNlSW50KHRoaXMuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShQSFhfTFZfSElTVE9SWV9QT1NJVElPTikpIHx8IDA7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCAoX2UpID0+IHtcbiAgICAgIHRoaXMudW5sb2FkZWQgPSB0cnVlO1xuICAgIH0pO1xuICAgIHRoaXMuc29ja2V0Lm9uT3BlbigoKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc1VubG9hZGVkKCkpIHtcbiAgICAgICAgLy8gcmVsb2FkIHBhZ2UgaWYgYmVpbmcgcmVzdG9yZWQgZnJvbSBiYWNrL2ZvcndhcmQgY2FjaGUgYW5kIGJyb3dzZXIgZG9lcyBub3QgZW1pdCBcInBhZ2VzaG93XCJcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gcHVibGljXG5cbiAgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gTFZfVlNOO1xuICB9XG5cbiAgaXNQcm9maWxlRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFBIWF9MVl9QUk9GSUxFKSA9PT0gXCJ0cnVlXCI7XG4gIH1cblxuICBpc0RlYnVnRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFBIWF9MVl9ERUJVRykgPT09IFwidHJ1ZVwiO1xuICB9XG5cbiAgaXNEZWJ1Z0Rpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oUEhYX0xWX0RFQlVHKSA9PT0gXCJmYWxzZVwiO1xuICB9XG5cbiAgZW5hYmxlRGVidWcoKSB7XG4gICAgdGhpcy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFBIWF9MVl9ERUJVRywgXCJ0cnVlXCIpO1xuICB9XG5cbiAgZW5hYmxlUHJvZmlsaW5nKCkge1xuICAgIHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShQSFhfTFZfUFJPRklMRSwgXCJ0cnVlXCIpO1xuICB9XG5cbiAgZGlzYWJsZURlYnVnKCkge1xuICAgIHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShQSFhfTFZfREVCVUcsIFwiZmFsc2VcIik7XG4gIH1cblxuICBkaXNhYmxlUHJvZmlsaW5nKCkge1xuICAgIHRoaXMuc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShQSFhfTFZfUFJPRklMRSk7XG4gIH1cblxuICBlbmFibGVMYXRlbmN5U2ltKHVwcGVyQm91bmRNcykge1xuICAgIHRoaXMuZW5hYmxlRGVidWcoKTtcbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIFwibGF0ZW5jeSBzaW11bGF0b3IgZW5hYmxlZCBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoaXMgYnJvd3NlciBzZXNzaW9uLiBDYWxsIGRpc2FibGVMYXRlbmN5U2ltKCkgdG8gZGlzYWJsZVwiLFxuICAgICk7XG4gICAgdGhpcy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFBIWF9MVl9MQVRFTkNZX1NJTSwgdXBwZXJCb3VuZE1zKTtcbiAgfVxuXG4gIGRpc2FibGVMYXRlbmN5U2ltKCkge1xuICAgIHRoaXMuc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShQSFhfTFZfTEFURU5DWV9TSU0pO1xuICB9XG5cbiAgZ2V0TGF0ZW5jeVNpbSgpIHtcbiAgICBjb25zdCBzdHIgPSB0aGlzLnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oUEhYX0xWX0xBVEVOQ1lfU0lNKTtcbiAgICByZXR1cm4gc3RyID8gcGFyc2VJbnQoc3RyKSA6IG51bGw7XG4gIH1cblxuICBnZXRTb2NrZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc29ja2V0O1xuICB9XG5cbiAgY29ubmVjdCgpIHtcbiAgICAvLyBlbmFibGUgZGVidWcgYnkgZGVmYXVsdCBpZiBvbiBsb2NhbGhvc3QgYW5kIG5vdCBleHBsaWNpdGx5IGRpc2FibGVkXG4gICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSA9PT0gXCJsb2NhbGhvc3RcIiAmJiAhdGhpcy5pc0RlYnVnRGlzYWJsZWQoKSkge1xuICAgICAgdGhpcy5lbmFibGVEZWJ1ZygpO1xuICAgIH1cbiAgICBjb25zdCBkb0Nvbm5lY3QgPSAoKSA9PiB7XG4gICAgICB0aGlzLnJlc2V0UmVsb2FkU3RhdHVzKCk7XG4gICAgICBpZiAodGhpcy5qb2luUm9vdFZpZXdzKCkpIHtcbiAgICAgICAgdGhpcy5iaW5kVG9wTGV2ZWxFdmVudHMoKTtcbiAgICAgICAgdGhpcy5zb2NrZXQuY29ubmVjdCgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm1haW4pIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuY29ubmVjdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5iaW5kVG9wTGV2ZWxFdmVudHMoeyBkZWFkOiB0cnVlIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5qb2luRGVhZFZpZXcoKTtcbiAgICB9O1xuICAgIGlmIChcbiAgICAgIFtcImNvbXBsZXRlXCIsIFwibG9hZGVkXCIsIFwiaW50ZXJhY3RpdmVcIl0uaW5kZXhPZihkb2N1bWVudC5yZWFkeVN0YXRlKSA+PSAwXG4gICAgKSB7XG4gICAgICBkb0Nvbm5lY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKCkgPT4gZG9Db25uZWN0KCkpO1xuICAgIH1cbiAgfVxuXG4gIGRpc2Nvbm5lY3QoY2FsbGJhY2spIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5yZWxvYWRXaXRoSml0dGVyVGltZXIpO1xuICAgIC8vIHJlbW92ZSB0aGUgc29ja2V0IGNsb3NlIGxpc3RlbmVyIHRvIGF2b2lkIHRyeWluZyB0byBoYW5kbGVcbiAgICAvLyBhIHNlcnZlciBjbG9zZSBldmVudCB3aGVuIGl0IGlzIGFjdHVhbGx5IGNhdXNlZCBieSB1cyBkaXNjb25uZWN0aW5nXG4gICAgaWYgKHRoaXMuc2VydmVyQ2xvc2VSZWYpIHtcbiAgICAgIHRoaXMuc29ja2V0Lm9mZih0aGlzLnNlcnZlckNsb3NlUmVmKTtcbiAgICAgIHRoaXMuc2VydmVyQ2xvc2VSZWYgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnNvY2tldC5kaXNjb25uZWN0KGNhbGxiYWNrKTtcbiAgfVxuXG4gIHJlcGxhY2VUcmFuc3BvcnQodHJhbnNwb3J0KSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucmVsb2FkV2l0aEppdHRlclRpbWVyKTtcbiAgICB0aGlzLnNvY2tldC5yZXBsYWNlVHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gICAgdGhpcy5jb25uZWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVuY29kZWRKU1xuICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IFtldmVudFR5cGVdXG4gICAqL1xuICBleGVjSlMoZWwsIGVuY29kZWRKUywgZXZlbnRUeXBlID0gbnVsbCkge1xuICAgIGNvbnN0IGUgPSBuZXcgQ3VzdG9tRXZlbnQoXCJwaHg6ZXhlY1wiLCB7IGRldGFpbDogeyBzb3VyY2VFbGVtZW50OiBlbCB9IH0pO1xuICAgIHRoaXMub3duZXIoZWwsICh2aWV3KSA9PiBKUy5leGVjKGUsIGV2ZW50VHlwZSwgZW5jb2RlZEpTLCB2aWV3LCBlbCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IHdpdGggbWV0aG9kcyB0byBtYW5pcHVsYXRlIHRoZSBET00gYW5kIGV4ZWN1dGUgSmF2YVNjcmlwdC5cbiAgICogVGhlIGFwcGxpZWQgY2hhbmdlcyBpbnRlZ3JhdGUgd2l0aCBzZXJ2ZXIgRE9NIHBhdGNoaW5nLlxuICAgKlxuICAgKiBAcmV0dXJucyB7aW1wb3J0KFwiLi9qc19jb21tYW5kc1wiKS5MaXZlU29ja2V0SlNDb21tYW5kc31cbiAgICovXG4gIGpzKCkge1xuICAgIHJldHVybiBqc0NvbW1hbmRzKHRoaXMsIFwianNcIik7XG4gIH1cblxuICAvLyBwcml2YXRlXG5cbiAgdW5sb2FkKCkge1xuICAgIGlmICh0aGlzLnVubG9hZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm1haW4gJiYgdGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICB0aGlzLmxvZyh0aGlzLm1haW4sIFwic29ja2V0XCIsICgpID0+IFtcImRpc2Nvbm5lY3QgZm9yIHBhZ2UgbmF2XCJdKTtcbiAgICB9XG4gICAgdGhpcy51bmxvYWRlZCA9IHRydWU7XG4gICAgdGhpcy5kZXN0cm95QWxsVmlld3MoKTtcbiAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgfVxuXG4gIHRyaWdnZXJET00oa2luZCwgYXJncykge1xuICAgIHRoaXMuZG9tQ2FsbGJhY2tzW2tpbmRdKC4uLmFyZ3MpO1xuICB9XG5cbiAgdGltZShuYW1lLCBmdW5jKSB7XG4gICAgaWYgKCF0aGlzLmlzUHJvZmlsZUVuYWJsZWQoKSB8fCAhY29uc29sZS50aW1lKSB7XG4gICAgICByZXR1cm4gZnVuYygpO1xuICAgIH1cbiAgICBjb25zb2xlLnRpbWUobmFtZSk7XG4gICAgY29uc3QgcmVzdWx0ID0gZnVuYygpO1xuICAgIGNvbnNvbGUudGltZUVuZChuYW1lKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgbG9nKHZpZXcsIGtpbmQsIG1zZ0NhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMudmlld0xvZ2dlcikge1xuICAgICAgY29uc3QgW21zZywgb2JqXSA9IG1zZ0NhbGxiYWNrKCk7XG4gICAgICB0aGlzLnZpZXdMb2dnZXIodmlldywga2luZCwgbXNnLCBvYmopO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0RlYnVnRW5hYmxlZCgpKSB7XG4gICAgICBjb25zdCBbbXNnLCBvYmpdID0gbXNnQ2FsbGJhY2soKTtcbiAgICAgIGRlYnVnKHZpZXcsIGtpbmQsIG1zZywgb2JqKTtcbiAgICB9XG4gIH1cblxuICByZXF1ZXN0RE9NVXBkYXRlKGNhbGxiYWNrKSB7XG4gICAgdGhpcy50cmFuc2l0aW9ucy5hZnRlcihjYWxsYmFjayk7XG4gIH1cblxuICBhc3luY1RyYW5zaXRpb24ocHJvbWlzZSkge1xuICAgIHRoaXMudHJhbnNpdGlvbnMuYWRkQXN5bmNUcmFuc2l0aW9uKHByb21pc2UpO1xuICB9XG5cbiAgdHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUgPSBmdW5jdGlvbiAoKSB7fSkge1xuICAgIHRoaXMudHJhbnNpdGlvbnMuYWRkVHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUpO1xuICB9XG5cbiAgb25DaGFubmVsKGNoYW5uZWwsIGV2ZW50LCBjYikge1xuICAgIGNoYW5uZWwub24oZXZlbnQsIChkYXRhKSA9PiB7XG4gICAgICBjb25zdCBsYXRlbmN5ID0gdGhpcy5nZXRMYXRlbmN5U2ltKCk7XG4gICAgICBpZiAoIWxhdGVuY3kpIHtcbiAgICAgICAgY2IoZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGNiKGRhdGEpLCBsYXRlbmN5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJlbG9hZFdpdGhKaXR0ZXIodmlldywgbG9nKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucmVsb2FkV2l0aEppdHRlclRpbWVyKTtcbiAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICBjb25zdCBtaW5NcyA9IHRoaXMucmVsb2FkSml0dGVyTWluO1xuICAgIGNvbnN0IG1heE1zID0gdGhpcy5yZWxvYWRKaXR0ZXJNYXg7XG4gICAgbGV0IGFmdGVyTXMgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4TXMgLSBtaW5NcyArIDEpKSArIG1pbk1zO1xuICAgIGNvbnN0IHRyaWVzID0gQnJvd3Nlci51cGRhdGVMb2NhbChcbiAgICAgIHRoaXMubG9jYWxTdG9yYWdlLFxuICAgICAgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgQ09OU0VDVVRJVkVfUkVMT0FEUyxcbiAgICAgIDAsXG4gICAgICAoY291bnQpID0+IGNvdW50ICsgMSxcbiAgICApO1xuICAgIGlmICh0cmllcyA+PSB0aGlzLm1heFJlbG9hZHMpIHtcbiAgICAgIGFmdGVyTXMgPSB0aGlzLmZhaWxzYWZlSml0dGVyO1xuICAgIH1cbiAgICB0aGlzLnJlbG9hZFdpdGhKaXR0ZXJUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgLy8gaWYgdmlldyBoYXMgcmVjb3ZlcmVkLCBzdWNoIGFzIHRyYW5zcG9ydCByZXBsYWNlZCwgdGhlbiBjYW5jZWxcbiAgICAgIGlmICh2aWV3LmlzRGVzdHJveWVkKCkgfHwgdmlldy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZpZXcuZGVzdHJveSgpO1xuICAgICAgbG9nXG4gICAgICAgID8gbG9nKClcbiAgICAgICAgOiB0aGlzLmxvZyh2aWV3LCBcImpvaW5cIiwgKCkgPT4gW1xuICAgICAgICAgICAgYGVuY291bnRlcmVkICR7dHJpZXN9IGNvbnNlY3V0aXZlIHJlbG9hZHNgLFxuICAgICAgICAgIF0pO1xuICAgICAgaWYgKHRyaWVzID49IHRoaXMubWF4UmVsb2Fkcykge1xuICAgICAgICB0aGlzLmxvZyh2aWV3LCBcImpvaW5cIiwgKCkgPT4gW1xuICAgICAgICAgIGBleGNlZWRlZCAke3RoaXMubWF4UmVsb2Fkc30gY29uc2VjdXRpdmUgcmVsb2Fkcy4gRW50ZXJpbmcgZmFpbHNhZmUgbW9kZWAsXG4gICAgICAgIF0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGFzUGVuZGluZ0xpbmsoKSkge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24gPSB0aGlzLnBlbmRpbmdMaW5rO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgfVxuICAgIH0sIGFmdGVyTXMpO1xuICB9XG5cbiAgZ2V0SG9va0RlZmluaXRpb24obmFtZSkge1xuICAgIGlmICghbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5tYXliZUludGVybmFsSG9vayhuYW1lKSB8fFxuICAgICAgdGhpcy5ob29rc1tuYW1lXSB8fFxuICAgICAgdGhpcy5tYXliZVJ1bnRpbWVIb29rKG5hbWUpXG4gICAgKTtcbiAgfVxuXG4gIG1heWJlSW50ZXJuYWxIb29rKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZSAmJiBuYW1lLnN0YXJ0c1dpdGgoXCJQaG9lbml4LlwiKSAmJiBIb29rc1tuYW1lLnNwbGl0KFwiLlwiKVsxXV07XG4gIH1cblxuICBtYXliZVJ1bnRpbWVIb29rKG5hbWUpIHtcbiAgICBjb25zdCBydW50aW1lSG9vayA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICBgc2NyaXB0WyR7UEhYX1JVTlRJTUVfSE9PS309XCIke0NTUy5lc2NhcGUobmFtZSl9XCJdYCxcbiAgICApO1xuICAgIGlmICghcnVudGltZUhvb2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGNhbGxiYWNrcyA9IHdpbmRvd1tgcGh4X2hvb2tfJHtuYW1lfWBdO1xuICAgIGlmICghY2FsbGJhY2tzIHx8IHR5cGVvZiBjYWxsYmFja3MgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgbG9nRXJyb3IoXCJhIHJ1bnRpbWUgaG9vayBtdXN0IGJlIGEgZnVuY3Rpb25cIiwgcnVudGltZUhvb2spO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBob29rRGVmaW5pdG9uID0gY2FsbGJhY2tzKCk7XG4gICAgaWYgKFxuICAgICAgaG9va0RlZmluaXRvbiAmJlxuICAgICAgKHR5cGVvZiBob29rRGVmaW5pdG9uID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBob29rRGVmaW5pdG9uID09PSBcImZ1bmN0aW9uXCIpXG4gICAgKSB7XG4gICAgICByZXR1cm4gaG9va0RlZmluaXRvbjtcbiAgICB9XG4gICAgbG9nRXJyb3IoXG4gICAgICBcInJ1bnRpbWUgaG9vayBtdXN0IHJldHVybiBhbiBvYmplY3Qgd2l0aCBob29rIGNhbGxiYWNrcyBvciBhbiBpbnN0YW5jZSBvZiBWaWV3SG9va1wiLFxuICAgICAgcnVudGltZUhvb2ssXG4gICAgKTtcbiAgfVxuXG4gIGlzVW5sb2FkZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5sb2FkZWQ7XG4gIH1cblxuICBpc0Nvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKTtcbiAgfVxuXG4gIGdldEJpbmRpbmdQcmVmaXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmluZGluZ1ByZWZpeDtcbiAgfVxuXG4gIGJpbmRpbmcoa2luZCkge1xuICAgIHJldHVybiBgJHt0aGlzLmdldEJpbmRpbmdQcmVmaXgoKX0ke2tpbmR9YDtcbiAgfVxuXG4gIGNoYW5uZWwodG9waWMsIHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLnNvY2tldC5jaGFubmVsKHRvcGljLCBwYXJhbXMpO1xuICB9XG5cbiAgam9pbkRlYWRWaWV3KCkge1xuICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgIGlmIChcbiAgICAgIGJvZHkgJiZcbiAgICAgICF0aGlzLmlzUGh4Vmlldyhib2R5KSAmJlxuICAgICAgIXRoaXMuaXNQaHhWaWV3KGRvY3VtZW50LmZpcnN0RWxlbWVudENoaWxkKVxuICAgICkge1xuICAgICAgY29uc3QgdmlldyA9IHRoaXMubmV3Um9vdFZpZXcoYm9keSk7XG4gICAgICB2aWV3LnNldEhyZWYodGhpcy5nZXRIcmVmKCkpO1xuICAgICAgdmlldy5qb2luRGVhZCgpO1xuICAgICAgaWYgKCF0aGlzLm1haW4pIHtcbiAgICAgICAgdGhpcy5tYWluID0gdmlldztcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB2aWV3LmV4ZWNOZXdNb3VudGVkKCk7XG4gICAgICAgIC8vIHJlc3RvcmUgc2Nyb2xsIHBvc2l0aW9uIHdoZW4gbmF2aWdhdGluZyBmcm9tIGFuIGV4dGVybmFsIC8gbm9uLWxpdmUgcGFnZVxuICAgICAgICB0aGlzLm1heWJlU2Nyb2xsKGhpc3Rvcnkuc3RhdGU/LnNjcm9sbCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBqb2luUm9vdFZpZXdzKCkge1xuICAgIGxldCByb290c0ZvdW5kID0gZmFsc2U7XG4gICAgRE9NLmFsbChcbiAgICAgIGRvY3VtZW50LFxuICAgICAgYCR7UEhYX1ZJRVdfU0VMRUNUT1J9Om5vdChbJHtQSFhfUEFSRU5UX0lEfV0pYCxcbiAgICAgIChyb290RWwpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmdldFJvb3RCeUlkKHJvb3RFbC5pZCkpIHtcbiAgICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy5uZXdSb290Vmlldyhyb290RWwpO1xuICAgICAgICAgIC8vIHN0aWNraWVzIGNhbm5vdCBiZSBtb3VudGVkIGF0IHRoZSByb3V0ZXIgYW5kIHRoZXJlZm9yZSBzaG91bGQgbm90XG4gICAgICAgICAgLy8gZ2V0IGEgaHJlZiBzZXQgb24gdGhlbVxuICAgICAgICAgIGlmICghRE9NLmlzUGh4U3RpY2t5KHJvb3RFbCkpIHtcbiAgICAgICAgICAgIHZpZXcuc2V0SHJlZih0aGlzLmdldEhyZWYoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZpZXcuam9pbigpO1xuICAgICAgICAgIGlmIChyb290RWwuaGFzQXR0cmlidXRlKFBIWF9NQUlOKSkge1xuICAgICAgICAgICAgdGhpcy5tYWluID0gdmlldztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcm9vdHNGb3VuZCA9IHRydWU7XG4gICAgICB9LFxuICAgICk7XG4gICAgcmV0dXJuIHJvb3RzRm91bmQ7XG4gIH1cblxuICByZWRpcmVjdCh0bywgZmxhc2gsIHJlbG9hZFRva2VuKSB7XG4gICAgaWYgKHJlbG9hZFRva2VuKSB7XG4gICAgICBCcm93c2VyLnNldENvb2tpZShQSFhfUkVMT0FEX1NUQVRVUywgcmVsb2FkVG9rZW4sIDYwKTtcbiAgICB9XG4gICAgdGhpcy51bmxvYWQoKTtcbiAgICBCcm93c2VyLnJlZGlyZWN0KHRvLCBmbGFzaCk7XG4gIH1cblxuICByZXBsYWNlTWFpbihcbiAgICBocmVmLFxuICAgIGZsYXNoLFxuICAgIGNhbGxiYWNrID0gbnVsbCxcbiAgICBsaW5rUmVmID0gdGhpcy5zZXRQZW5kaW5nTGluayhocmVmKSxcbiAgKSB7XG4gICAgY29uc3QgbGl2ZVJlZmVyZXIgPSB0aGlzLmN1cnJlbnRMb2NhdGlvbi5ocmVmO1xuICAgIHRoaXMub3V0Z29pbmdNYWluRWwgPSB0aGlzLm91dGdvaW5nTWFpbkVsIHx8IHRoaXMubWFpbi5lbDtcblxuICAgIGNvbnN0IHN0aWNraWVzID0gRE9NLmZpbmRQaHhTdGlja3koZG9jdW1lbnQpIHx8IFtdO1xuICAgIGNvbnN0IHJlbW92ZUVscyA9IERPTS5hbGwoXG4gICAgICB0aGlzLm91dGdvaW5nTWFpbkVsLFxuICAgICAgYFske3RoaXMuYmluZGluZyhcInJlbW92ZVwiKX1dYCxcbiAgICApLmZpbHRlcigoZWwpID0+ICFET00uaXNDaGlsZE9mQW55KGVsLCBzdGlja2llcykpO1xuXG4gICAgY29uc3QgbmV3TWFpbkVsID0gRE9NLmNsb25lTm9kZSh0aGlzLm91dGdvaW5nTWFpbkVsLCBcIlwiKTtcbiAgICB0aGlzLm1haW4uc2hvd0xvYWRlcih0aGlzLmxvYWRlclRpbWVvdXQpO1xuICAgIHRoaXMubWFpbi5kZXN0cm95KCk7XG5cbiAgICB0aGlzLm1haW4gPSB0aGlzLm5ld1Jvb3RWaWV3KG5ld01haW5FbCwgZmxhc2gsIGxpdmVSZWZlcmVyKTtcbiAgICB0aGlzLm1haW4uc2V0UmVkaXJlY3QoaHJlZik7XG4gICAgdGhpcy50cmFuc2l0aW9uUmVtb3ZlcyhyZW1vdmVFbHMpO1xuICAgIHRoaXMubWFpbi5qb2luKChqb2luQ291bnQsIG9uRG9uZSkgPT4ge1xuICAgICAgaWYgKGpvaW5Db3VudCA9PT0gMSAmJiB0aGlzLmNvbW1pdFBlbmRpbmdMaW5rKGxpbmtSZWYpKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHBoeC1yZW1vdmUgZWxzIHJpZ2h0IGJlZm9yZSB3ZSByZXBsYWNlIHRoZSBtYWluIGVsZW1lbnRcbiAgICAgICAgICByZW1vdmVFbHMuZm9yRWFjaCgoZWwpID0+IGVsLnJlbW92ZSgpKTtcbiAgICAgICAgICBzdGlja2llcy5mb3JFYWNoKChlbCkgPT4gbmV3TWFpbkVsLmFwcGVuZENoaWxkKGVsKSk7XG4gICAgICAgICAgdGhpcy5vdXRnb2luZ01haW5FbC5yZXBsYWNlV2l0aChuZXdNYWluRWwpO1xuICAgICAgICAgIHRoaXMub3V0Z29pbmdNYWluRWwgPSBudWxsO1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGxpbmtSZWYpO1xuICAgICAgICAgIG9uRG9uZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHRyYW5zaXRpb25SZW1vdmVzKGVsZW1lbnRzLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHJlbW92ZUF0dHIgPSB0aGlzLmJpbmRpbmcoXCJyZW1vdmVcIik7XG4gICAgY29uc3Qgc2lsZW5jZUV2ZW50cyA9IChlKSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIH07XG4gICAgZWxlbWVudHMuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgIC8vIHByZXZlbnQgYWxsIGxpc3RlbmVycyB3ZSBjYXJlIGFib3V0IGZyb20gYnViYmxpbmcgdG8gd2luZG93XG4gICAgICAvLyBzaW5jZSB3ZSBhcmUgcmVtb3ZpbmcgdGhlIGVsZW1lbnRcbiAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgdGhpcy5ib3VuZEV2ZW50TmFtZXMpIHtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgc2lsZW5jZUV2ZW50cywgdHJ1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmV4ZWNKUyhlbCwgZWwuZ2V0QXR0cmlidXRlKHJlbW92ZUF0dHIpLCBcInJlbW92ZVwiKTtcbiAgICB9KTtcbiAgICAvLyByZW1vdmUgdGhlIHNpbGVuY2VkIGxpc3RlbmVycyB3aGVuIHRyYW5zaXRpb25zIGFyZSBkb25lIGluY2FzZSB0aGUgZWxlbWVudCBpcyByZS11c2VkXG4gICAgLy8gYW5kIGNhbGwgY2FsbGVyJ3MgY2FsbGJhY2sgYXMgc29vbiBhcyB3ZSBhcmUgZG9uZSB3aXRoIHRyYW5zaXRpb25zXG4gICAgdGhpcy5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgIGVsZW1lbnRzLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgdGhpcy5ib3VuZEV2ZW50TmFtZXMpIHtcbiAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBzaWxlbmNlRXZlbnRzLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgIH0pO1xuICB9XG5cbiAgaXNQaHhWaWV3KGVsKSB7XG4gICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04pICE9PSBudWxsO1xuICB9XG5cbiAgbmV3Um9vdFZpZXcoZWwsIGZsYXNoLCBsaXZlUmVmZXJlcikge1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgVmlldyhlbCwgdGhpcywgbnVsbCwgZmxhc2gsIGxpdmVSZWZlcmVyKTtcbiAgICB0aGlzLnJvb3RzW3ZpZXcuaWRdID0gdmlldztcbiAgICByZXR1cm4gdmlldztcbiAgfVxuXG4gIG93bmVyKGNoaWxkRWwsIGNhbGxiYWNrKSB7XG4gICAgbGV0IHZpZXc7XG4gICAgY29uc3Qgdmlld0VsID0gRE9NLmNsb3Nlc3RWaWV3RWwoY2hpbGRFbCk7XG4gICAgaWYgKHZpZXdFbCkge1xuICAgICAgLy8gaXQgY2FuIGhhcHBlbiB0aGF0IHdlIGZpbmQgYSB2aWV3IHRoYXQgaXMgYWxyZWFkeSBkZXN0cm95ZWQ7XG4gICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgRE8gTk9UIHdhbnQgdG8gZmFsbGJhY2sgdG8gdGhlIG1haW4gZWxlbWVudFxuICAgICAgdmlldyA9IHRoaXMuZ2V0Vmlld0J5RWwodmlld0VsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFjaGlsZEVsLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgIC8vIGlmIHRoZSBlbGVtZW50IGlzIG5vdCBwYXJ0IG9mIHRoZSBET00gYW55IG1vcmVcbiAgICAgICAgLy8gdGhlcmUncyBubyBvd25lciBhbmQgd2Ugc2hvdWxkIG5vdCBkbyBmYWxsIGJhY2tcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2aWV3ID0gdGhpcy5tYWluO1xuICAgIH1cbiAgICByZXR1cm4gdmlldyAmJiBjYWxsYmFjayA/IGNhbGxiYWNrKHZpZXcpIDogdmlldztcbiAgfVxuXG4gIHdpdGhpbk93bmVycyhjaGlsZEVsLCBjYWxsYmFjaykge1xuICAgIHRoaXMub3duZXIoY2hpbGRFbCwgKHZpZXcpID0+IGNhbGxiYWNrKHZpZXcsIGNoaWxkRWwpKTtcbiAgfVxuXG4gIGdldFZpZXdCeUVsKGVsKSB7XG4gICAgY29uc3Qgcm9vdElkID0gZWwuZ2V0QXR0cmlidXRlKFBIWF9ST09UX0lEKTtcbiAgICByZXR1cm4gbWF5YmUodGhpcy5nZXRSb290QnlJZChyb290SWQpLCAocm9vdCkgPT5cbiAgICAgIHJvb3QuZ2V0RGVzY2VuZGVudEJ5RWwoZWwpLFxuICAgICk7XG4gIH1cblxuICBnZXRSb290QnlJZChpZCkge1xuICAgIHJldHVybiB0aGlzLnJvb3RzW2lkXTtcbiAgfVxuXG4gIGRlc3Ryb3lBbGxWaWV3cygpIHtcbiAgICBmb3IgKGNvbnN0IGlkIGluIHRoaXMucm9vdHMpIHtcbiAgICAgIHRoaXMucm9vdHNbaWRdLmRlc3Ryb3koKTtcbiAgICAgIGRlbGV0ZSB0aGlzLnJvb3RzW2lkXTtcbiAgICB9XG4gICAgdGhpcy5tYWluID0gbnVsbDtcbiAgfVxuXG4gIGRlc3Ryb3lWaWV3QnlFbChlbCkge1xuICAgIGNvbnN0IHJvb3QgPSB0aGlzLmdldFJvb3RCeUlkKGVsLmdldEF0dHJpYnV0ZShQSFhfUk9PVF9JRCkpO1xuICAgIGlmIChyb290ICYmIHJvb3QuaWQgPT09IGVsLmlkKSB7XG4gICAgICByb290LmRlc3Ryb3koKTtcbiAgICAgIGRlbGV0ZSB0aGlzLnJvb3RzW3Jvb3QuaWRdO1xuICAgIH0gZWxzZSBpZiAocm9vdCkge1xuICAgICAgcm9vdC5kZXN0cm95RGVzY2VuZGVudChlbC5pZCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0QWN0aXZlRWxlbWVudCgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgfVxuXG4gIGRyb3BBY3RpdmVFbGVtZW50KHZpZXcpIHtcbiAgICBpZiAodGhpcy5wcmV2QWN0aXZlICYmIHZpZXcub3duc0VsZW1lbnQodGhpcy5wcmV2QWN0aXZlKSkge1xuICAgICAgdGhpcy5wcmV2QWN0aXZlID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICByZXN0b3JlUHJldmlvdXNseUFjdGl2ZUZvY3VzKCkge1xuICAgIGlmIChcbiAgICAgIHRoaXMucHJldkFjdGl2ZSAmJlxuICAgICAgdGhpcy5wcmV2QWN0aXZlICE9PSBkb2N1bWVudC5ib2R5ICYmXG4gICAgICB0aGlzLnByZXZBY3RpdmUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudFxuICAgICkge1xuICAgICAgdGhpcy5wcmV2QWN0aXZlLmZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgYmx1ckFjdGl2ZUVsZW1lbnQoKSB7XG4gICAgdGhpcy5wcmV2QWN0aXZlID0gdGhpcy5nZXRBY3RpdmVFbGVtZW50KCk7XG4gICAgaWYgKFxuICAgICAgdGhpcy5wcmV2QWN0aXZlICE9PSBkb2N1bWVudC5ib2R5ICYmXG4gICAgICB0aGlzLnByZXZBY3RpdmUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudFxuICAgICkge1xuICAgICAgdGhpcy5wcmV2QWN0aXZlLmJsdXIoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHt7ZGVhZD86IGJvb2xlYW59fSBbb3B0aW9ucz17fV1cbiAgICovXG4gIGJpbmRUb3BMZXZlbEV2ZW50cyh7IGRlYWQgfSA9IHt9KSB7XG4gICAgaWYgKHRoaXMuYm91bmRUb3BMZXZlbEV2ZW50cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYm91bmRUb3BMZXZlbEV2ZW50cyA9IHRydWU7XG4gICAgLy8gZW50ZXIgZmFpbHNhZmUgcmVsb2FkIGlmIHNlcnZlciBoYXMgZ29uZSBhd2F5IGludGVudGlvbmFsbHksIHN1Y2ggYXMgXCJkaXNjb25uZWN0XCIgYnJvYWRjYXN0XG4gICAgdGhpcy5zZXJ2ZXJDbG9zZVJlZiA9IHRoaXMuc29ja2V0Lm9uQ2xvc2UoKGV2ZW50KSA9PiB7XG4gICAgICAvLyBmYWlsc2FmZSByZWxvYWQgaWYgbm9ybWFsIGNsb3N1cmUgYW5kIHdlIHN0aWxsIGhhdmUgYSBtYWluIExWXG4gICAgICBpZiAoZXZlbnQgJiYgZXZlbnQuY29kZSA9PT0gMTAwMCAmJiB0aGlzLm1haW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVsb2FkV2l0aEppdHRlcih0aGlzLm1haW4pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHt9KTsgLy8gZW5zdXJlIGFsbCBjbGljayBldmVudHMgYnViYmxlIGZvciBtb2JpbGUgU2FmYXJpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcInBhZ2VzaG93XCIsXG4gICAgICAoZSkgPT4ge1xuICAgICAgICBpZiAoZS5wZXJzaXN0ZWQpIHtcbiAgICAgICAgICAvLyByZWxvYWQgcGFnZSBpZiBiZWluZyByZXN0b3JlZCBmcm9tIGJhY2svZm9yd2FyZCBjYWNoZVxuICAgICAgICAgIHRoaXMuZ2V0U29ja2V0KCkuZGlzY29ubmVjdCgpO1xuICAgICAgICAgIHRoaXMud2l0aFBhZ2VMb2FkaW5nKHsgdG86IHdpbmRvdy5sb2NhdGlvbi5ocmVmLCBraW5kOiBcInJlZGlyZWN0XCIgfSk7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdHJ1ZSxcbiAgICApO1xuICAgIGlmICghZGVhZCkge1xuICAgICAgdGhpcy5iaW5kTmF2KCk7XG4gICAgfVxuICAgIHRoaXMuYmluZENsaWNrcygpO1xuICAgIGlmICghZGVhZCkge1xuICAgICAgdGhpcy5iaW5kRm9ybXMoKTtcbiAgICB9XG4gICAgdGhpcy5iaW5kKFxuICAgICAgeyBrZXl1cDogXCJrZXl1cFwiLCBrZXlkb3duOiBcImtleWRvd25cIiB9LFxuICAgICAgKGUsIHR5cGUsIHZpZXcsIHRhcmdldEVsLCBwaHhFdmVudCwgX3BoeFRhcmdldCkgPT4ge1xuICAgICAgICBjb25zdCBtYXRjaEtleSA9IHRhcmdldEVsLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0tFWSkpO1xuICAgICAgICBjb25zdCBwcmVzc2VkS2V5ID0gZS5rZXkgJiYgZS5rZXkudG9Mb3dlckNhc2UoKTsgLy8gY2hyb21lIGNsaWNrZWQgYXV0b2NvbXBsZXRlcyBzZW5kIGEga2V5ZG93biB3aXRob3V0IGtleVxuICAgICAgICBpZiAobWF0Y2hLZXkgJiYgbWF0Y2hLZXkudG9Mb3dlckNhc2UoKSAhPT0gcHJlc3NlZEtleSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRhdGEgPSB7IGtleTogZS5rZXksIC4uLnRoaXMuZXZlbnRNZXRhKHR5cGUsIGUsIHRhcmdldEVsKSB9O1xuICAgICAgICBKUy5leGVjKGUsIHR5cGUsIHBoeEV2ZW50LCB2aWV3LCB0YXJnZXRFbCwgW1wicHVzaFwiLCB7IGRhdGEgfV0pO1xuICAgICAgfSxcbiAgICApO1xuICAgIHRoaXMuYmluZChcbiAgICAgIHsgYmx1cjogXCJmb2N1c291dFwiLCBmb2N1czogXCJmb2N1c2luXCIgfSxcbiAgICAgIChlLCB0eXBlLCB2aWV3LCB0YXJnZXRFbCwgcGh4RXZlbnQsIHBoeFRhcmdldCkgPT4ge1xuICAgICAgICBpZiAoIXBoeFRhcmdldCkge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSB7IGtleTogZS5rZXksIC4uLnRoaXMuZXZlbnRNZXRhKHR5cGUsIGUsIHRhcmdldEVsKSB9O1xuICAgICAgICAgIEpTLmV4ZWMoZSwgdHlwZSwgcGh4RXZlbnQsIHZpZXcsIHRhcmdldEVsLCBbXCJwdXNoXCIsIHsgZGF0YSB9XSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgKTtcbiAgICB0aGlzLmJpbmQoXG4gICAgICB7IGJsdXI6IFwiYmx1clwiLCBmb2N1czogXCJmb2N1c1wiIH0sXG4gICAgICAoZSwgdHlwZSwgdmlldywgdGFyZ2V0RWwsIHBoeEV2ZW50LCBwaHhUYXJnZXQpID0+IHtcbiAgICAgICAgLy8gYmx1ciBhbmQgZm9jdXMgYXJlIHRyaWdnZXJlZCBvbiBkb2N1bWVudCBhbmQgd2luZG93LiBEaXNjYXJkIG9uZSB0byBhdm9pZCBkdXBzXG4gICAgICAgIGlmIChwaHhUYXJnZXQgPT09IFwid2luZG93XCIpIHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5ldmVudE1ldGEodHlwZSwgZSwgdGFyZ2V0RWwpO1xuICAgICAgICAgIEpTLmV4ZWMoZSwgdHlwZSwgcGh4RXZlbnQsIHZpZXcsIHRhcmdldEVsLCBbXCJwdXNoXCIsIHsgZGF0YSB9XSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgKTtcbiAgICB0aGlzLm9uKFwiZHJhZ292ZXJcIiwgKGUpID0+IGUucHJldmVudERlZmF1bHQoKSk7XG4gICAgdGhpcy5vbihcImRyYWdlbnRlclwiLCAoZSkgPT4ge1xuICAgICAgY29uc3QgZHJvcHpvbmUgPSBjbG9zZXN0UGh4QmluZGluZyhcbiAgICAgICAgZS50YXJnZXQsXG4gICAgICAgIHRoaXMuYmluZGluZyhQSFhfRFJPUF9UQVJHRVQpLFxuICAgICAgKTtcblxuICAgICAgaWYgKCFkcm9wem9uZSB8fCAhKGRyb3B6b25lIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50Q29udGFpbnNGaWxlcyhlKSkge1xuICAgICAgICB0aGlzLmpzKCkuYWRkQ2xhc3MoZHJvcHpvbmUsIFBIWF9EUk9QX1RBUkdFVF9BQ1RJVkVfQ0xBU1MpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMub24oXCJkcmFnbGVhdmVcIiwgKGUpID0+IHtcbiAgICAgIGNvbnN0IGRyb3B6b25lID0gY2xvc2VzdFBoeEJpbmRpbmcoXG4gICAgICAgIGUudGFyZ2V0LFxuICAgICAgICB0aGlzLmJpbmRpbmcoUEhYX0RST1BfVEFSR0VUKSxcbiAgICAgICk7XG5cbiAgICAgIGlmICghZHJvcHpvbmUgfHwgIShkcm9wem9uZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEF2b2lkIGFkZC9yZW1vdmUgaml0dGVyIGluIHRoZSBjYXNlIHRoYXQgd2UgZHJhZyBpbnRvIGEgbmV3IGNoaWxkIGFuZCB0aGF0IGNoaWxkIHdvdWxkXG4gICAgICAvLyByZXNvbHZlIHRoZWlyIGNsb3Nlc3QgZHJvcCB0YXJnZXQgdG8gdGhlIGN1cnJlbnQgZHJvcHpvbmUgZWxlbWVudFxuICAgICAgY29uc3QgcmVjdCA9IGRyb3B6b25lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaWYgKFxuICAgICAgICBlLmNsaWVudFggPD0gcmVjdC5sZWZ0IHx8XG4gICAgICAgIGUuY2xpZW50WCA+PSByZWN0LnJpZ2h0IHx8XG4gICAgICAgIGUuY2xpZW50WSA8PSByZWN0LnRvcCB8fFxuICAgICAgICBlLmNsaWVudFkgPj0gcmVjdC5ib3R0b21cbiAgICAgICkge1xuICAgICAgICB0aGlzLmpzKCkucmVtb3ZlQ2xhc3MoZHJvcHpvbmUsIFBIWF9EUk9QX1RBUkdFVF9BQ1RJVkVfQ0xBU1MpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMub24oXCJkcm9wXCIsIChlKSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGNvbnN0IGRyb3B6b25lID0gY2xvc2VzdFBoeEJpbmRpbmcoXG4gICAgICAgIGUudGFyZ2V0LFxuICAgICAgICB0aGlzLmJpbmRpbmcoUEhYX0RST1BfVEFSR0VUKSxcbiAgICAgICk7XG4gICAgICBpZiAoIWRyb3B6b25lIHx8ICEoZHJvcHpvbmUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5qcygpLnJlbW92ZUNsYXNzKGRyb3B6b25lLCBQSFhfRFJPUF9UQVJHRVRfQUNUSVZFX0NMQVNTKTtcblxuICAgICAgY29uc3QgZHJvcFRhcmdldElkID0gZHJvcHpvbmUuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhQSFhfRFJPUF9UQVJHRVQpKTtcbiAgICAgIGNvbnN0IGRyb3BUYXJnZXQgPSBkcm9wVGFyZ2V0SWQgJiYgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZHJvcFRhcmdldElkKTtcbiAgICAgIGNvbnN0IGZpbGVzID0gQXJyYXkuZnJvbShlLmRhdGFUcmFuc2Zlci5maWxlcyB8fCBbXSk7XG4gICAgICBpZiAoXG4gICAgICAgICFkcm9wVGFyZ2V0IHx8XG4gICAgICAgICEoZHJvcFRhcmdldCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQpIHx8XG4gICAgICAgIGRyb3BUYXJnZXQuZGlzYWJsZWQgfHxcbiAgICAgICAgZmlsZXMubGVuZ3RoID09PSAwIHx8XG4gICAgICAgICEoZHJvcFRhcmdldC5maWxlcyBpbnN0YW5jZW9mIEZpbGVMaXN0KVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgTGl2ZVVwbG9hZGVyLnRyYWNrRmlsZXMoZHJvcFRhcmdldCwgZmlsZXMsIGUuZGF0YVRyYW5zZmVyKTtcbiAgICAgIGRyb3BUYXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJpbnB1dFwiLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xuICAgIH0pO1xuICAgIHRoaXMub24oUEhYX1RSQUNLX1VQTE9BRFMsIChlKSA9PiB7XG4gICAgICBjb25zdCB1cGxvYWRUYXJnZXQgPSBlLnRhcmdldDtcbiAgICAgIGlmICghRE9NLmlzVXBsb2FkSW5wdXQodXBsb2FkVGFyZ2V0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBmaWxlcyA9IEFycmF5LmZyb20oZS5kZXRhaWwuZmlsZXMgfHwgW10pLmZpbHRlcihcbiAgICAgICAgKGYpID0+IGYgaW5zdGFuY2VvZiBGaWxlIHx8IGYgaW5zdGFuY2VvZiBCbG9iLFxuICAgICAgKTtcbiAgICAgIExpdmVVcGxvYWRlci50cmFja0ZpbGVzKHVwbG9hZFRhcmdldCwgZmlsZXMpO1xuICAgICAgdXBsb2FkVGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiaW5wdXRcIiwgeyBidWJibGVzOiB0cnVlIH0pKTtcbiAgICB9KTtcbiAgfVxuXG4gIGV2ZW50TWV0YShldmVudE5hbWUsIGUsIHRhcmdldEVsKSB7XG4gICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLm1ldGFkYXRhQ2FsbGJhY2tzW2V2ZW50TmFtZV07XG4gICAgcmV0dXJuIGNhbGxiYWNrID8gY2FsbGJhY2soZSwgdGFyZ2V0RWwpIDoge307XG4gIH1cblxuICBzZXRQZW5kaW5nTGluayhocmVmKSB7XG4gICAgdGhpcy5saW5rUmVmKys7XG4gICAgdGhpcy5wZW5kaW5nTGluayA9IGhyZWY7XG4gICAgdGhpcy5yZXNldFJlbG9hZFN0YXR1cygpO1xuICAgIHJldHVybiB0aGlzLmxpbmtSZWY7XG4gIH1cblxuICAvLyBhbnl0aW1lIHdlIGFyZSBuYXZpZ2F0aW5nIG9yIGNvbm5lY3RpbmcsIGRyb3AgcmVsb2FkIGNvb2tpZSBpbiBjYXNlXG4gIC8vIHdlIGlzc3VlIHRoZSBjb29raWUgYnV0IHRoZSBuZXh0IHJlcXVlc3Qgd2FzIGludGVycnVwdGVkIGFuZCB0aGUgc2VydmVyIG5ldmVyIGRyb3BwZWQgaXRcbiAgcmVzZXRSZWxvYWRTdGF0dXMoKSB7XG4gICAgQnJvd3Nlci5kZWxldGVDb29raWUoUEhYX1JFTE9BRF9TVEFUVVMpO1xuICB9XG5cbiAgY29tbWl0UGVuZGluZ0xpbmsobGlua1JlZikge1xuICAgIGlmICh0aGlzLmxpbmtSZWYgIT09IGxpbmtSZWYpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ocmVmID0gdGhpcy5wZW5kaW5nTGluaztcbiAgICAgIHRoaXMucGVuZGluZ0xpbmsgPSBudWxsO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgZ2V0SHJlZigpIHtcbiAgICByZXR1cm4gdGhpcy5ocmVmO1xuICB9XG5cbiAgaGFzUGVuZGluZ0xpbmsoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5wZW5kaW5nTGluaztcbiAgfVxuXG4gIGJpbmQoZXZlbnRzLCBjYWxsYmFjaykge1xuICAgIGZvciAoY29uc3QgZXZlbnQgaW4gZXZlbnRzKSB7XG4gICAgICBjb25zdCBicm93c2VyRXZlbnROYW1lID0gZXZlbnRzW2V2ZW50XTtcblxuICAgICAgdGhpcy5vbihicm93c2VyRXZlbnROYW1lLCAoZSkgPT4ge1xuICAgICAgICBjb25zdCBiaW5kaW5nID0gdGhpcy5iaW5kaW5nKGV2ZW50KTtcbiAgICAgICAgY29uc3Qgd2luZG93QmluZGluZyA9IHRoaXMuYmluZGluZyhgd2luZG93LSR7ZXZlbnR9YCk7XG4gICAgICAgIGNvbnN0IHRhcmdldFBoeEV2ZW50ID1cbiAgICAgICAgICBlLnRhcmdldC5nZXRBdHRyaWJ1dGUgJiYgZS50YXJnZXQuZ2V0QXR0cmlidXRlKGJpbmRpbmcpO1xuICAgICAgICBpZiAodGFyZ2V0UGh4RXZlbnQpIHtcbiAgICAgICAgICB0aGlzLmRlYm91bmNlKGUudGFyZ2V0LCBlLCBicm93c2VyRXZlbnROYW1lLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLndpdGhpbk93bmVycyhlLnRhcmdldCwgKHZpZXcpID0+IHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soZSwgZXZlbnQsIHZpZXcsIGUudGFyZ2V0LCB0YXJnZXRQaHhFdmVudCwgbnVsbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBET00uYWxsKGRvY3VtZW50LCBgWyR7d2luZG93QmluZGluZ31dYCwgKGVsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwaHhFdmVudCA9IGVsLmdldEF0dHJpYnV0ZSh3aW5kb3dCaW5kaW5nKTtcbiAgICAgICAgICAgIHRoaXMuZGVib3VuY2UoZWwsIGUsIGJyb3dzZXJFdmVudE5hbWUsICgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy53aXRoaW5Pd25lcnMoZWwsICh2aWV3KSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZSwgZXZlbnQsIHZpZXcsIGVsLCBwaHhFdmVudCwgXCJ3aW5kb3dcIik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGJpbmRDbGlja3MoKSB7XG4gICAgdGhpcy5vbihcIm1vdXNlZG93blwiLCAoZSkgPT4gKHRoaXMuY2xpY2tTdGFydGVkQXRUYXJnZXQgPSBlLnRhcmdldCkpO1xuICAgIHRoaXMuYmluZENsaWNrKFwiY2xpY2tcIiwgXCJjbGlja1wiKTtcbiAgfVxuXG4gIGJpbmRDbGljayhldmVudE5hbWUsIGJpbmRpbmdOYW1lKSB7XG4gICAgY29uc3QgY2xpY2sgPSB0aGlzLmJpbmRpbmcoYmluZGluZ05hbWUpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgZXZlbnROYW1lLFxuICAgICAgKGUpID0+IHtcbiAgICAgICAgbGV0IHRhcmdldCA9IG51bGw7XG4gICAgICAgIC8vIGEgc3ludGhldGljIGNsaWNrIGV2ZW50IChkZXRhaWwgMCkgd2lsbCBub3QgaGF2ZSBjYXVzZWQgYSBtb3VzZWRvd24gZXZlbnQsXG4gICAgICAgIC8vIHRoZXJlZm9yZSB0aGUgY2xpY2tTdGFydGVkQXRUYXJnZXQgaXMgc3RhbGVcbiAgICAgICAgaWYgKGUuZGV0YWlsID09PSAwKSB0aGlzLmNsaWNrU3RhcnRlZEF0VGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgIGNvbnN0IGNsaWNrU3RhcnRlZEF0VGFyZ2V0ID0gdGhpcy5jbGlja1N0YXJ0ZWRBdFRhcmdldCB8fCBlLnRhcmdldDtcbiAgICAgICAgLy8gd2hlbiBzZWFyY2hpbmcgdGhlIHRhcmdldCBmb3IgdGhlIGNsaWNrIGV2ZW50LCB3ZSBhbHdheXMgd2FudCB0b1xuICAgICAgICAvLyB1c2UgdGhlIGFjdHVhbCBldmVudCB0YXJnZXQsIHNlZSAjMzM3MlxuICAgICAgICB0YXJnZXQgPSBjbG9zZXN0UGh4QmluZGluZyhlLnRhcmdldCwgY2xpY2spO1xuICAgICAgICB0aGlzLmRpc3BhdGNoQ2xpY2tBd2F5KGUsIGNsaWNrU3RhcnRlZEF0VGFyZ2V0KTtcbiAgICAgICAgdGhpcy5jbGlja1N0YXJ0ZWRBdFRhcmdldCA9IG51bGw7XG4gICAgICAgIGNvbnN0IHBoeEV2ZW50ID0gdGFyZ2V0ICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUoY2xpY2spO1xuICAgICAgICBpZiAoIXBoeEV2ZW50KSB7XG4gICAgICAgICAgaWYgKERPTS5pc05ld1BhZ2VDbGljayhlLCB3aW5kb3cubG9jYXRpb24pKSB7XG4gICAgICAgICAgICB0aGlzLnVubG9hZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFyZ2V0LmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IFwiI1wiKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm9vcCBpZiB3ZSBhcmUgaW4gdGhlIG1pZGRsZSBvZiBhd2FpdGluZyBhbiBhY2sgZm9yIHRoaXMgZWwgYWxyZWFkeVxuICAgICAgICBpZiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZShQSFhfUkVGX1NSQykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRlYm91bmNlKHRhcmdldCwgZSwgXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy53aXRoaW5Pd25lcnModGFyZ2V0LCAodmlldykgPT4ge1xuICAgICAgICAgICAgSlMuZXhlYyhlLCBcImNsaWNrXCIsIHBoeEV2ZW50LCB2aWV3LCB0YXJnZXQsIFtcbiAgICAgICAgICAgICAgXCJwdXNoXCIsXG4gICAgICAgICAgICAgIHsgZGF0YTogdGhpcy5ldmVudE1ldGEoXCJjbGlja1wiLCBlLCB0YXJnZXQpIH0sXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZmFsc2UsXG4gICAgKTtcbiAgfVxuXG4gIGRpc3BhdGNoQ2xpY2tBd2F5KGUsIGNsaWNrU3RhcnRlZEF0KSB7XG4gICAgY29uc3QgcGh4Q2xpY2tBd2F5ID0gdGhpcy5iaW5kaW5nKFwiY2xpY2stYXdheVwiKTtcbiAgICBET00uYWxsKGRvY3VtZW50LCBgWyR7cGh4Q2xpY2tBd2F5fV1gLCAoZWwpID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgIShcbiAgICAgICAgICBlbC5pc1NhbWVOb2RlKGNsaWNrU3RhcnRlZEF0KSB8fFxuICAgICAgICAgIGVsLmNvbnRhaW5zKGNsaWNrU3RhcnRlZEF0KSB8fFxuICAgICAgICAgIC8vIFdoZW4gY2xpY2tpbmcgYSBsaW5rIHdpdGggY3VzdG9tIG1ldGhvZCxcbiAgICAgICAgICAvLyBwaG9lbml4X2h0bWwgdHJpZ2dlcnMgYSBjbGljayBvbiBhIHN1Ym1pdCBidXR0b25cbiAgICAgICAgICAvLyBvZiBhIGhpZGRlbiBmb3JtIGFwcGVuZGVkIHRvIHRoZSBib2R5LiBGb3Igc3VjaCBjYXNlc1xuICAgICAgICAgIC8vIHdoZXJlIHRoZSBjbGlja2VkIHRhcmdldCBpcyBoaWRkZW4sIHdlIHNraXAgY2xpY2stYXdheS5cbiAgICAgICAgICAhSlMuaXNWaXNpYmxlKGNsaWNrU3RhcnRlZEF0KVxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgdGhpcy53aXRoaW5Pd25lcnMoZWwsICh2aWV3KSA9PiB7XG4gICAgICAgICAgY29uc3QgcGh4RXZlbnQgPSBlbC5nZXRBdHRyaWJ1dGUocGh4Q2xpY2tBd2F5KTtcbiAgICAgICAgICBpZiAoSlMuaXNWaXNpYmxlKGVsKSAmJiBKUy5pc0luVmlld3BvcnQoZWwpKSB7XG4gICAgICAgICAgICBKUy5leGVjKGUsIFwiY2xpY2tcIiwgcGh4RXZlbnQsIHZpZXcsIGVsLCBbXG4gICAgICAgICAgICAgIFwicHVzaFwiLFxuICAgICAgICAgICAgICB7IGRhdGE6IHRoaXMuZXZlbnRNZXRhKFwiY2xpY2tcIiwgZSwgZS50YXJnZXQpIH0sXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYmluZE5hdigpIHtcbiAgICBpZiAoIUJyb3dzZXIuY2FuUHVzaFN0YXRlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgIGhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcIm1hbnVhbFwiO1xuICAgIH1cbiAgICBsZXQgc2Nyb2xsVGltZXIgPSBudWxsO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIChfZSkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHNjcm9sbFRpbWVyKTtcbiAgICAgIHNjcm9sbFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIEJyb3dzZXIudXBkYXRlQ3VycmVudFN0YXRlKChzdGF0ZSkgPT5cbiAgICAgICAgICBPYmplY3QuYXNzaWduKHN0YXRlLCB7IHNjcm9sbDogd2luZG93LnNjcm9sbFkgfSksXG4gICAgICAgICk7XG4gICAgICB9LCAxMDApO1xuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJwb3BzdGF0ZVwiLFxuICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5yZWdpc3Rlck5ld0xvY2F0aW9uKHdpbmRvdy5sb2NhdGlvbikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB0eXBlLCBiYWNrVHlwZSwgaWQsIHNjcm9sbCwgcG9zaXRpb24gfSA9IGV2ZW50LnN0YXRlIHx8IHt9O1xuICAgICAgICBjb25zdCBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG5cbiAgICAgICAgLy8gQ29tcGFyZSBwb3NpdGlvbnMgdG8gZGV0ZXJtaW5lIGRpcmVjdGlvblxuICAgICAgICBjb25zdCBpc0ZvcndhcmQgPSBwb3NpdGlvbiA+IHRoaXMuY3VycmVudEhpc3RvcnlQb3NpdGlvbjtcbiAgICAgICAgY29uc3QgbmF2VHlwZSA9IGlzRm9yd2FyZCA/IHR5cGUgOiBiYWNrVHlwZSB8fCB0eXBlO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBjdXJyZW50IHBvc2l0aW9uXG4gICAgICAgIHRoaXMuY3VycmVudEhpc3RvcnlQb3NpdGlvbiA9IHBvc2l0aW9uIHx8IDA7XG4gICAgICAgIHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcbiAgICAgICAgICBQSFhfTFZfSElTVE9SWV9QT1NJVElPTixcbiAgICAgICAgICB0aGlzLmN1cnJlbnRIaXN0b3J5UG9zaXRpb24udG9TdHJpbmcoKSxcbiAgICAgICAgKTtcblxuICAgICAgICBET00uZGlzcGF0Y2hFdmVudCh3aW5kb3csIFwicGh4Om5hdmlnYXRlXCIsIHtcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgICBwYXRjaDogbmF2VHlwZSA9PT0gXCJwYXRjaFwiLFxuICAgICAgICAgICAgcG9wOiB0cnVlLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBpc0ZvcndhcmQgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIixcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWF5YmVTY3JvbGwoc2Nyb2xsKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMubWFpbi5pc0Nvbm5lY3RlZCgpICYmXG4gICAgICAgICAgICBuYXZUeXBlID09PSBcInBhdGNoXCIgJiZcbiAgICAgICAgICAgIGlkID09PSB0aGlzLm1haW4uaWRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5wdXNoTGlua1BhdGNoKGV2ZW50LCBocmVmLCBudWxsLCBjYWxsYmFjayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZU1haW4oaHJlZiwgbnVsbCwgY2FsbGJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZmFsc2UsXG4gICAgKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgIChlKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGNsb3Nlc3RQaHhCaW5kaW5nKGUudGFyZ2V0LCBQSFhfTElWRV9MSU5LKTtcbiAgICAgICAgY29uc3QgdHlwZSA9IHRhcmdldCAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKFBIWF9MSVZFX0xJTkspO1xuICAgICAgICBpZiAoIXR5cGUgfHwgIXRoaXMuaXNDb25uZWN0ZWQoKSB8fCAhdGhpcy5tYWluIHx8IERPTS53YW50c05ld1RhYihlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdoZW4gd3JhcHBpbmcgYW4gU1ZHIGVsZW1lbnQgaW4gYW4gYW5jaG9yIHRhZywgdGhlIGhyZWYgY2FuIGJlIGFuIFNWR0FuaW1hdGVkU3RyaW5nXG4gICAgICAgIGNvbnN0IGhyZWYgPVxuICAgICAgICAgIHRhcmdldC5ocmVmIGluc3RhbmNlb2YgU1ZHQW5pbWF0ZWRTdHJpbmdcbiAgICAgICAgICAgID8gdGFyZ2V0LmhyZWYuYmFzZVZhbFxuICAgICAgICAgICAgOiB0YXJnZXQuaHJlZjtcblxuICAgICAgICBjb25zdCBsaW5rU3RhdGUgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFBIWF9MSU5LX1NUQVRFKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpOyAvLyBkbyBub3QgYnViYmxlIGNsaWNrIHRvIHJlZ3VsYXIgcGh4LWNsaWNrIGJpbmRpbmdzXG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdMaW5rID09PSBocmVmKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gXCJwYXRjaFwiKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hIaXN0b3J5UGF0Y2goZSwgaHJlZiwgbGlua1N0YXRlLCB0YXJnZXQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJyZWRpcmVjdFwiKSB7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnlSZWRpcmVjdChlLCBocmVmLCBsaW5rU3RhdGUsIG51bGwsIHRhcmdldCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYGV4cGVjdGVkICR7UEhYX0xJVkVfTElOS30gdG8gYmUgXCJwYXRjaFwiIG9yIFwicmVkaXJlY3RcIiwgZ290OiAke3R5cGV9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHBoeENsaWNrID0gdGFyZ2V0LmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJjbGlja1wiKSk7XG4gICAgICAgICAgaWYgKHBoeENsaWNrKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RET01VcGRhdGUoKCkgPT4gdGhpcy5leGVjSlModGFyZ2V0LCBwaHhDbGljaywgXCJjbGlja1wiKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBmYWxzZSxcbiAgICApO1xuICB9XG5cbiAgbWF5YmVTY3JvbGwoc2Nyb2xsKSB7XG4gICAgaWYgKHR5cGVvZiBzY3JvbGwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCBzY3JvbGwpO1xuICAgICAgfSk7IC8vIHRoZSBib2R5IG5lZWRzIHRvIHJlbmRlciBiZWZvcmUgd2Ugc2Nyb2xsLlxuICAgIH1cbiAgfVxuXG4gIGRpc3BhdGNoRXZlbnQoZXZlbnQsIHBheWxvYWQgPSB7fSkge1xuICAgIERPTS5kaXNwYXRjaEV2ZW50KHdpbmRvdywgYHBoeDoke2V2ZW50fWAsIHsgZGV0YWlsOiBwYXlsb2FkIH0pO1xuICB9XG5cbiAgZGlzcGF0Y2hFdmVudHMoZXZlbnRzKSB7XG4gICAgZXZlbnRzLmZvckVhY2goKFtldmVudCwgcGF5bG9hZF0pID0+IHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCwgcGF5bG9hZCkpO1xuICB9XG5cbiAgd2l0aFBhZ2VMb2FkaW5nKGluZm8sIGNhbGxiYWNrKSB7XG4gICAgRE9NLmRpc3BhdGNoRXZlbnQod2luZG93LCBcInBoeDpwYWdlLWxvYWRpbmctc3RhcnRcIiwgeyBkZXRhaWw6IGluZm8gfSk7XG4gICAgY29uc3QgZG9uZSA9ICgpID0+XG4gICAgICBET00uZGlzcGF0Y2hFdmVudCh3aW5kb3csIFwicGh4OnBhZ2UtbG9hZGluZy1zdG9wXCIsIHsgZGV0YWlsOiBpbmZvIH0pO1xuICAgIHJldHVybiBjYWxsYmFjayA/IGNhbGxiYWNrKGRvbmUpIDogZG9uZTtcbiAgfVxuXG4gIHB1c2hIaXN0b3J5UGF0Y2goZSwgaHJlZiwgbGlua1N0YXRlLCB0YXJnZXRFbCkge1xuICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCgpIHx8ICF0aGlzLm1haW4uaXNNYWluKCkpIHtcbiAgICAgIHJldHVybiBCcm93c2VyLnJlZGlyZWN0KGhyZWYpO1xuICAgIH1cblxuICAgIHRoaXMud2l0aFBhZ2VMb2FkaW5nKHsgdG86IGhyZWYsIGtpbmQ6IFwicGF0Y2hcIiB9LCAoZG9uZSkgPT4ge1xuICAgICAgdGhpcy5tYWluLnB1c2hMaW5rUGF0Y2goZSwgaHJlZiwgdGFyZ2V0RWwsIChsaW5rUmVmKSA9PiB7XG4gICAgICAgIHRoaXMuaGlzdG9yeVBhdGNoKGhyZWYsIGxpbmtTdGF0ZSwgbGlua1JlZik7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgaGlzdG9yeVBhdGNoKGhyZWYsIGxpbmtTdGF0ZSwgbGlua1JlZiA9IHRoaXMuc2V0UGVuZGluZ0xpbmsoaHJlZikpIHtcbiAgICBpZiAoIXRoaXMuY29tbWl0UGVuZGluZ0xpbmsobGlua1JlZikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJbmNyZW1lbnQgcG9zaXRpb24gZm9yIG5ldyBzdGF0ZVxuICAgIHRoaXMuY3VycmVudEhpc3RvcnlQb3NpdGlvbisrO1xuICAgIHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcbiAgICAgIFBIWF9MVl9ISVNUT1JZX1BPU0lUSU9OLFxuICAgICAgdGhpcy5jdXJyZW50SGlzdG9yeVBvc2l0aW9uLnRvU3RyaW5nKCksXG4gICAgKTtcblxuICAgIC8vIHN0b3JlIHRoZSB0eXBlIGZvciBiYWNrIG5hdmlnYXRpb25cbiAgICBCcm93c2VyLnVwZGF0ZUN1cnJlbnRTdGF0ZSgoc3RhdGUpID0+ICh7IC4uLnN0YXRlLCBiYWNrVHlwZTogXCJwYXRjaFwiIH0pKTtcblxuICAgIEJyb3dzZXIucHVzaFN0YXRlKFxuICAgICAgbGlua1N0YXRlLFxuICAgICAge1xuICAgICAgICB0eXBlOiBcInBhdGNoXCIsXG4gICAgICAgIGlkOiB0aGlzLm1haW4uaWQsXG4gICAgICAgIHBvc2l0aW9uOiB0aGlzLmN1cnJlbnRIaXN0b3J5UG9zaXRpb24sXG4gICAgICB9LFxuICAgICAgaHJlZixcbiAgICApO1xuXG4gICAgRE9NLmRpc3BhdGNoRXZlbnQod2luZG93LCBcInBoeDpuYXZpZ2F0ZVwiLCB7XG4gICAgICBkZXRhaWw6IHsgcGF0Y2g6IHRydWUsIGhyZWYsIHBvcDogZmFsc2UsIGRpcmVjdGlvbjogXCJmb3J3YXJkXCIgfSxcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyTmV3TG9jYXRpb24od2luZG93LmxvY2F0aW9uKTtcbiAgfVxuXG4gIGhpc3RvcnlSZWRpcmVjdChlLCBocmVmLCBsaW5rU3RhdGUsIGZsYXNoLCB0YXJnZXRFbCkge1xuICAgIGNvbnN0IGNsaWNrTG9hZGluZyA9IHRhcmdldEVsICYmIGUuaXNUcnVzdGVkICYmIGUudHlwZSAhPT0gXCJwb3BzdGF0ZVwiO1xuICAgIGlmIChjbGlja0xvYWRpbmcpIHtcbiAgICAgIHRhcmdldEVsLmNsYXNzTGlzdC5hZGQoXCJwaHgtY2xpY2stbG9hZGluZ1wiKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkgfHwgIXRoaXMubWFpbi5pc01haW4oKSkge1xuICAgICAgcmV0dXJuIEJyb3dzZXIucmVkaXJlY3QoaHJlZiwgZmxhc2gpO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgdG8gZnVsbCBocmVmIGlmIG9ubHkgcGF0aCBwcmVmaXhcbiAgICBpZiAoL15cXC8kfF5cXC9bXlxcL10rLiokLy50ZXN0KGhyZWYpKSB7XG4gICAgICBjb25zdCB7IHByb3RvY29sLCBob3N0IH0gPSB3aW5kb3cubG9jYXRpb247XG4gICAgICBocmVmID0gYCR7cHJvdG9jb2x9Ly8ke2hvc3R9JHtocmVmfWA7XG4gICAgfVxuICAgIGNvbnN0IHNjcm9sbCA9IHdpbmRvdy5zY3JvbGxZO1xuICAgIHRoaXMud2l0aFBhZ2VMb2FkaW5nKHsgdG86IGhyZWYsIGtpbmQ6IFwicmVkaXJlY3RcIiB9LCAoZG9uZSkgPT4ge1xuICAgICAgdGhpcy5yZXBsYWNlTWFpbihocmVmLCBmbGFzaCwgKGxpbmtSZWYpID0+IHtcbiAgICAgICAgaWYgKGxpbmtSZWYgPT09IHRoaXMubGlua1JlZikge1xuICAgICAgICAgIC8vIEluY3JlbWVudCBwb3NpdGlvbiBmb3IgbmV3IHN0YXRlXG4gICAgICAgICAgdGhpcy5jdXJyZW50SGlzdG9yeVBvc2l0aW9uKys7XG4gICAgICAgICAgdGhpcy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFxuICAgICAgICAgICAgUEhYX0xWX0hJU1RPUllfUE9TSVRJT04sXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRIaXN0b3J5UG9zaXRpb24udG9TdHJpbmcoKSxcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gc3RvcmUgdGhlIHR5cGUgZm9yIGJhY2sgbmF2aWdhdGlvblxuICAgICAgICAgIEJyb3dzZXIudXBkYXRlQ3VycmVudFN0YXRlKChzdGF0ZSkgPT4gKHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgYmFja1R5cGU6IFwicmVkaXJlY3RcIixcbiAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBCcm93c2VyLnB1c2hTdGF0ZShcbiAgICAgICAgICAgIGxpbmtTdGF0ZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJyZWRpcmVjdFwiLFxuICAgICAgICAgICAgICBpZDogdGhpcy5tYWluLmlkLFxuICAgICAgICAgICAgICBzY3JvbGw6IHNjcm9sbCxcbiAgICAgICAgICAgICAgcG9zaXRpb246IHRoaXMuY3VycmVudEhpc3RvcnlQb3NpdGlvbixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBocmVmLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBET00uZGlzcGF0Y2hFdmVudCh3aW5kb3csIFwicGh4Om5hdmlnYXRlXCIsIHtcbiAgICAgICAgICAgIGRldGFpbDogeyBocmVmLCBwYXRjaDogZmFsc2UsIHBvcDogZmFsc2UsIGRpcmVjdGlvbjogXCJmb3J3YXJkXCIgfSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyTmV3TG9jYXRpb24od2luZG93LmxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBleHBsaWNpdGx5IHVuZG8gY2xpY2stbG9hZGluZyBjbGFzc1xuICAgICAgICAvLyAoaW4gY2FzZSBpdCBvcmlnaW5hdGVkIGluIGEgc3RpY2t5IGxpdmUgdmlldywgb3RoZXJ3aXNlIGl0IHdvdWxkIGJlIHJlbW92ZWQgYW55d2F5KVxuICAgICAgICBpZiAoY2xpY2tMb2FkaW5nKSB7XG4gICAgICAgICAgdGFyZ2V0RWwuY2xhc3NMaXN0LnJlbW92ZShcInBoeC1jbGljay1sb2FkaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmVnaXN0ZXJOZXdMb2NhdGlvbihuZXdMb2NhdGlvbikge1xuICAgIGNvbnN0IHsgcGF0aG5hbWUsIHNlYXJjaCB9ID0gdGhpcy5jdXJyZW50TG9jYXRpb247XG4gICAgaWYgKHBhdGhuYW1lICsgc2VhcmNoID09PSBuZXdMb2NhdGlvbi5wYXRobmFtZSArIG5ld0xvY2F0aW9uLnNlYXJjaCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN1cnJlbnRMb2NhdGlvbiA9IGNsb25lKG5ld0xvY2F0aW9uKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGJpbmRGb3JtcygpIHtcbiAgICBsZXQgaXRlcmF0aW9ucyA9IDA7XG4gICAgbGV0IGV4dGVybmFsRm9ybVN1Ym1pdHRlZCA9IGZhbHNlO1xuXG4gICAgLy8gZGlzYWJsZSBmb3JtcyBvbiBzdWJtaXQgdGhhdCB0cmFjayBwaHgtY2hhbmdlIGJ1dCBwZXJmb3JtIGV4dGVybmFsIHN1Ym1pdFxuICAgIHRoaXMub24oXCJzdWJtaXRcIiwgKGUpID0+IHtcbiAgICAgIGNvbnN0IHBoeFN1Ym1pdCA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJzdWJtaXRcIikpO1xuICAgICAgY29uc3QgcGh4Q2hhbmdlID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhcImNoYW5nZVwiKSk7XG4gICAgICBpZiAoIWV4dGVybmFsRm9ybVN1Ym1pdHRlZCAmJiBwaHhDaGFuZ2UgJiYgIXBoeFN1Ym1pdCkge1xuICAgICAgICBleHRlcm5hbEZvcm1TdWJtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMud2l0aGluT3duZXJzKGUudGFyZ2V0LCAodmlldykgPT4ge1xuICAgICAgICAgIHZpZXcuZGlzYWJsZUZvcm0oZS50YXJnZXQpO1xuICAgICAgICAgIC8vIHNhZmFyaSBuZWVkcyBuZXh0IHRpY2tcbiAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChET00uaXNVbmxvYWRhYmxlRm9ybVN1Ym1pdChlKSkge1xuICAgICAgICAgICAgICB0aGlzLnVubG9hZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZS50YXJnZXQuc3VibWl0KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5vbihcInN1Ym1pdFwiLCAoZSkgPT4ge1xuICAgICAgY29uc3QgcGh4RXZlbnQgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFwic3VibWl0XCIpKTtcbiAgICAgIGlmICghcGh4RXZlbnQpIHtcbiAgICAgICAgaWYgKERPTS5pc1VubG9hZGFibGVGb3JtU3VibWl0KGUpKSB7XG4gICAgICAgICAgdGhpcy51bmxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBlLnRhcmdldC5kaXNhYmxlZCA9IHRydWU7XG4gICAgICB0aGlzLndpdGhpbk93bmVycyhlLnRhcmdldCwgKHZpZXcpID0+IHtcbiAgICAgICAgSlMuZXhlYyhlLCBcInN1Ym1pdFwiLCBwaHhFdmVudCwgdmlldywgZS50YXJnZXQsIFtcbiAgICAgICAgICBcInB1c2hcIixcbiAgICAgICAgICB7IHN1Ym1pdHRlcjogZS5zdWJtaXR0ZXIgfSxcbiAgICAgICAgXSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGZvciAoY29uc3QgdHlwZSBvZiBbXCJjaGFuZ2VcIiwgXCJpbnB1dFwiXSkge1xuICAgICAgdGhpcy5vbih0eXBlLCAoZSkgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgZSBpbnN0YW5jZW9mIEN1c3RvbUV2ZW50ICYmXG4gICAgICAgICAgKGUudGFyZ2V0IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCB8fFxuICAgICAgICAgICAgZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MU2VsZWN0RWxlbWVudCB8fFxuICAgICAgICAgICAgZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MVGV4dEFyZWFFbGVtZW50KSAmJlxuICAgICAgICAgIGUudGFyZ2V0LmZvcm0gPT09IHVuZGVmaW5lZFxuICAgICAgICApIHtcbiAgICAgICAgICAvLyB0aHJvdyBvbiBpbnZhbGlkIEpTLmRpc3BhdGNoIHRhcmdldCBhbmQgbm9vcCBpZiBDdXN0b21FdmVudCB0cmlnZ2VyZWQgb3V0c2lkZSBKUy5kaXNwYXRjaFxuICAgICAgICAgIGlmIChlLmRldGFpbCAmJiBlLmRldGFpbC5kaXNwYXRjaGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBkaXNwYXRjaGluZyBhIGN1c3RvbSAke3R5cGV9IGV2ZW50IGlzIG9ubHkgc3VwcG9ydGVkIG9uIGlucHV0IGVsZW1lbnRzIGluc2lkZSBhIGZvcm1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBoeENoYW5nZSA9IHRoaXMuYmluZGluZyhcImNoYW5nZVwiKTtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBlLnRhcmdldDtcbiAgICAgICAgaWYgKHRoaXMuYmxvY2tQaHhDaGFuZ2VXaGlsZUNvbXBvc2luZyAmJiBlLmlzQ29tcG9zaW5nKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gYGNvbXBvc2l0aW9uLWxpc3RlbmVyLSR7dHlwZX1gO1xuICAgICAgICAgIGlmICghRE9NLnByaXZhdGUoaW5wdXQsIGtleSkpIHtcbiAgICAgICAgICAgIERPTS5wdXRQcml2YXRlKGlucHV0LCBrZXksIHRydWUpO1xuICAgICAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgXCJjb21wb3NpdGlvbmVuZFwiLFxuICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gdHJpZ2dlciBhIG5ldyBpbnB1dC9jaGFuZ2UgZXZlbnRcbiAgICAgICAgICAgICAgICBpbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCh0eXBlLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xuICAgICAgICAgICAgICAgIERPTS5kZWxldGVQcml2YXRlKGlucHV0LCBrZXkpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB7IG9uY2U6IHRydWUgfSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnB1dEV2ZW50ID0gaW5wdXQuZ2V0QXR0cmlidXRlKHBoeENoYW5nZSk7XG4gICAgICAgIGNvbnN0IGZvcm1FdmVudCA9IGlucHV0LmZvcm0gJiYgaW5wdXQuZm9ybS5nZXRBdHRyaWJ1dGUocGh4Q2hhbmdlKTtcbiAgICAgICAgY29uc3QgcGh4RXZlbnQgPSBpbnB1dEV2ZW50IHx8IGZvcm1FdmVudDtcbiAgICAgICAgaWYgKCFwaHhFdmVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgaW5wdXQudHlwZSA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgICAgIGlucHV0LnZhbGlkaXR5ICYmXG4gICAgICAgICAgaW5wdXQudmFsaWRpdHkuYmFkSW5wdXRcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGlzcGF0Y2hlciA9IGlucHV0RXZlbnQgPyBpbnB1dCA6IGlucHV0LmZvcm07XG4gICAgICAgIGNvbnN0IGN1cnJlbnRJdGVyYXRpb25zID0gaXRlcmF0aW9ucztcbiAgICAgICAgaXRlcmF0aW9ucysrO1xuICAgICAgICBjb25zdCB7IGF0OiBhdCwgdHlwZTogbGFzdFR5cGUgfSA9XG4gICAgICAgICAgRE9NLnByaXZhdGUoaW5wdXQsIFwicHJldi1pdGVyYXRpb25cIikgfHwge307XG4gICAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBhbHdheXMgZmlyZSBhdCBsZWFzdCBvbmUgXCJpbnB1dFwiIGV2ZW50IGJlZm9yZSBldmVyeSBcImNoYW5nZVwiXG4gICAgICAgIC8vIElnbm9yZSBcImNoYW5nZVwiIGV2ZW50cywgdW5sZXNzIHRoZXJlIHdhcyBubyBwcmlvciBcImlucHV0XCIgZXZlbnQuXG4gICAgICAgIC8vIFRoaXMgY291bGQgaGFwcGVuIGlmIHVzZXIgY29kZSB0cmlnZ2VycyBhIFwiY2hhbmdlXCIgZXZlbnQsIG9yIGlmIHRoZSBicm93c2VyIGlzIG5vbi1jb25mb3JtaW5nLlxuICAgICAgICBpZiAoXG4gICAgICAgICAgYXQgPT09IGN1cnJlbnRJdGVyYXRpb25zIC0gMSAmJlxuICAgICAgICAgIHR5cGUgPT09IFwiY2hhbmdlXCIgJiZcbiAgICAgICAgICBsYXN0VHlwZSA9PT0gXCJpbnB1dFwiXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIERPTS5wdXRQcml2YXRlKGlucHV0LCBcInByZXYtaXRlcmF0aW9uXCIsIHtcbiAgICAgICAgICBhdDogY3VycmVudEl0ZXJhdGlvbnMsXG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5kZWJvdW5jZShpbnB1dCwgZSwgdHlwZSwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMud2l0aGluT3duZXJzKGRpc3BhdGNoZXIsICh2aWV3KSA9PiB7XG4gICAgICAgICAgICBET00ucHV0UHJpdmF0ZShpbnB1dCwgUEhYX0hBU19GT0NVU0VELCB0cnVlKTtcbiAgICAgICAgICAgIEpTLmV4ZWMoZSwgXCJjaGFuZ2VcIiwgcGh4RXZlbnQsIHZpZXcsIGlucHV0LCBbXG4gICAgICAgICAgICAgIFwicHVzaFwiLFxuICAgICAgICAgICAgICB7IF90YXJnZXQ6IGUudGFyZ2V0Lm5hbWUsIGRpc3BhdGNoZXI6IGRpc3BhdGNoZXIgfSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLm9uKFwicmVzZXRcIiwgKGUpID0+IHtcbiAgICAgIGNvbnN0IGZvcm0gPSBlLnRhcmdldDtcbiAgICAgIERPTS5yZXNldEZvcm0oZm9ybSk7XG4gICAgICBjb25zdCBpbnB1dCA9IEFycmF5LmZyb20oZm9ybS5lbGVtZW50cykuZmluZCgoZWwpID0+IGVsLnR5cGUgPT09IFwicmVzZXRcIik7XG4gICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgLy8gd2FpdCB1bnRpbCBuZXh0IHRpY2sgdG8gZ2V0IHVwZGF0ZWQgaW5wdXQgdmFsdWVcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgaW5wdXQuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICAgIG5ldyBFdmVudChcImlucHV0XCIsIHsgYnViYmxlczogdHJ1ZSwgY2FuY2VsYWJsZTogZmFsc2UgfSksXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBkZWJvdW5jZShlbCwgZXZlbnQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoZXZlbnRUeXBlID09PSBcImJsdXJcIiB8fCBldmVudFR5cGUgPT09IFwiZm9jdXNvdXRcIikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgY29uc3QgcGh4RGVib3VuY2UgPSB0aGlzLmJpbmRpbmcoUEhYX0RFQk9VTkNFKTtcbiAgICBjb25zdCBwaHhUaHJvdHRsZSA9IHRoaXMuYmluZGluZyhQSFhfVEhST1RUTEUpO1xuICAgIGNvbnN0IGRlZmF1bHREZWJvdW5jZSA9IHRoaXMuZGVmYXVsdHMuZGVib3VuY2UudG9TdHJpbmcoKTtcbiAgICBjb25zdCBkZWZhdWx0VGhyb3R0bGUgPSB0aGlzLmRlZmF1bHRzLnRocm90dGxlLnRvU3RyaW5nKCk7XG5cbiAgICB0aGlzLndpdGhpbk93bmVycyhlbCwgKHZpZXcpID0+IHtcbiAgICAgIGNvbnN0IGFzeW5jRmlsdGVyID0gKCkgPT5cbiAgICAgICAgIXZpZXcuaXNEZXN0cm95ZWQoKSAmJiBkb2N1bWVudC5ib2R5LmNvbnRhaW5zKGVsKTtcbiAgICAgIERPTS5kZWJvdW5jZShcbiAgICAgICAgZWwsXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBwaHhEZWJvdW5jZSxcbiAgICAgICAgZGVmYXVsdERlYm91bmNlLFxuICAgICAgICBwaHhUaHJvdHRsZSxcbiAgICAgICAgZGVmYXVsdFRocm90dGxlLFxuICAgICAgICBhc3luY0ZpbHRlcixcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgc2lsZW5jZUV2ZW50cyhjYWxsYmFjaykge1xuICAgIHRoaXMuc2lsZW5jZWQgPSB0cnVlO1xuICAgIGNhbGxiYWNrKCk7XG4gICAgdGhpcy5zaWxlbmNlZCA9IGZhbHNlO1xuICB9XG5cbiAgb24oZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5ib3VuZEV2ZW50TmFtZXMuYWRkKGV2ZW50KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgKGUpID0+IHtcbiAgICAgIGlmICghdGhpcy5zaWxlbmNlZCkge1xuICAgICAgICBjYWxsYmFjayhlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGpzUXVlcnlTZWxlY3RvckFsbChzb3VyY2VFbCwgcXVlcnksIGRlZmF1bHRRdWVyeSkge1xuICAgIGNvbnN0IGFsbCA9IHRoaXMuZG9tQ2FsbGJhY2tzLmpzUXVlcnlTZWxlY3RvckFsbDtcbiAgICByZXR1cm4gYWxsID8gYWxsKHNvdXJjZUVsLCBxdWVyeSwgZGVmYXVsdFF1ZXJ5KSA6IGRlZmF1bHRRdWVyeSgpO1xuICB9XG59XG5cbmNsYXNzIFRyYW5zaXRpb25TZXQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnRyYW5zaXRpb25zID0gbmV3IFNldCgpO1xuICAgIHRoaXMucHJvbWlzZXMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5wZW5kaW5nT3BzID0gW107XG4gIH1cblxuICByZXNldCgpIHtcbiAgICB0aGlzLnRyYW5zaXRpb25zLmZvckVhY2goKHRpbWVyKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgdGhpcy50cmFuc2l0aW9ucy5kZWxldGUodGltZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucHJvbWlzZXMuY2xlYXIoKTtcbiAgICB0aGlzLmZsdXNoUGVuZGluZ09wcygpO1xuICB9XG5cbiAgYWZ0ZXIoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5zaXplKCkgPT09IDApIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHVzaFBlbmRpbmdPcChjYWxsYmFjayk7XG4gICAgfVxuICB9XG5cbiAgYWRkVHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUpIHtcbiAgICBvblN0YXJ0KCk7XG4gICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudHJhbnNpdGlvbnMuZGVsZXRlKHRpbWVyKTtcbiAgICAgIG9uRG9uZSgpO1xuICAgICAgdGhpcy5mbHVzaFBlbmRpbmdPcHMoKTtcbiAgICB9LCB0aW1lKTtcbiAgICB0aGlzLnRyYW5zaXRpb25zLmFkZCh0aW1lcik7XG4gIH1cblxuICBhZGRBc3luY1RyYW5zaXRpb24ocHJvbWlzZSkge1xuICAgIHRoaXMucHJvbWlzZXMuYWRkKHByb21pc2UpO1xuICAgIHByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLnByb21pc2VzLmRlbGV0ZShwcm9taXNlKTtcbiAgICAgIHRoaXMuZmx1c2hQZW5kaW5nT3BzKCk7XG4gICAgfSk7XG4gIH1cblxuICBwdXNoUGVuZGluZ09wKG9wKSB7XG4gICAgdGhpcy5wZW5kaW5nT3BzLnB1c2gob3ApO1xuICB9XG5cbiAgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9ucy5zaXplICsgdGhpcy5wcm9taXNlcy5zaXplO1xuICB9XG5cbiAgZmx1c2hQZW5kaW5nT3BzKCkge1xuICAgIGlmICh0aGlzLnNpemUoKSA+IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb3AgPSB0aGlzLnBlbmRpbmdPcHMuc2hpZnQoKTtcbiAgICBpZiAob3ApIHtcbiAgICAgIG9wKCk7XG4gICAgICB0aGlzLmZsdXNoUGVuZGluZ09wcygpO1xuICAgIH1cbiAgfVxufVxuIiwgIi8qXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuUGhvZW5peCBMaXZlVmlldyBKYXZhU2NyaXB0IENsaWVudFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuU2VlIHRoZSBoZXhkb2NzIGF0IGBodHRwczovL2hleGRvY3MucG0vcGhvZW5peF9saXZlX3ZpZXdgIGZvciBkb2N1bWVudGF0aW9uLlxuKi9cblxuaW1wb3J0IE9yaWdpbmFsTGl2ZVNvY2tldCwgeyBpc1VzZWRJbnB1dCB9IGZyb20gXCIuL2xpdmVfc29ja2V0XCI7XG5pbXBvcnQgRE9NIGZyb20gXCIuL2RvbVwiO1xuaW1wb3J0IHsgVmlld0hvb2sgfSBmcm9tIFwiLi92aWV3X2hvb2tcIjtcbmltcG9ydCBWaWV3IGZyb20gXCIuL3ZpZXdcIjtcbmltcG9ydCB7IGxvZ0Vycm9yIH0gZnJvbSBcIi4vdXRpbHNcIjtcblxuaW1wb3J0IHR5cGUgeyBMaXZlU29ja2V0SlNDb21tYW5kcyB9IGZyb20gXCIuL2pzX2NvbW1hbmRzXCI7XG5pbXBvcnQgdHlwZSB7IEhvb2ssIEhvb2tzT3B0aW9ucyB9IGZyb20gXCIuL3ZpZXdfaG9va1wiO1xuaW1wb3J0IHR5cGUgeyBTb2NrZXQgYXMgUGhvZW5peFNvY2tldCB9IGZyb20gXCJwaG9lbml4XCI7XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgY29uZmlndXJpbmcgdGhlIExpdmVTb2NrZXQgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTGl2ZVNvY2tldE9wdGlvbnMge1xuICAvKipcbiAgICogRGVmYXVsdHMgZm9yIHBoeC1kZWJvdW5jZSBhbmQgcGh4LXRocm90dGxlLlxuICAgKi9cbiAgZGVmYXVsdHM/OiB7XG4gICAgLyoqIFRoZSBtaWxsaXNlY29uZCBwaHgtZGVib3VuY2UgdGltZS4gRGVmYXVsdHMgMzAwICovXG4gICAgZGVib3VuY2U/OiBudW1iZXI7XG4gICAgLyoqIFRoZSBtaWxsaXNlY29uZCBwaHgtdGhyb3R0bGUgdGltZS4gRGVmYXVsdHMgMzAwICovXG4gICAgdGhyb3R0bGU/OiBudW1iZXI7XG4gIH07XG4gIC8qKlxuICAgKiBBbiBvYmplY3Qgb3IgZnVuY3Rpb24gZm9yIHBhc3NpbmcgY29ubmVjdCBwYXJhbXMuXG4gICAqIFRoZSBmdW5jdGlvbiByZWNlaXZlcyB0aGUgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBMaXZlVmlldy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICAgICAoZWwpID0+IHt2aWV3OiBlbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW15LXZpZXctbmFtZVwiLCB0b2tlbjogd2luZG93Lm15VG9rZW59XG4gICAqXG4gICAqL1xuICBwYXJhbXM/OlxuICAgIHwgKChlbDogSFRNTEVsZW1lbnQpID0+IHsgW2tleTogc3RyaW5nXTogYW55IH0pXG4gICAgfCB7IFtrZXk6IHN0cmluZ106IGFueSB9O1xuICAvKipcbiAgICogVGhlIG9wdGlvbmFsIHByZWZpeCB0byB1c2UgZm9yIGFsbCBwaHggRE9NIGFubm90YXRpb25zLlxuICAgKlxuICAgKiBEZWZhdWx0cyB0byBcInBoeC1cIi5cbiAgICovXG4gIGJpbmRpbmdQcmVmaXg/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBDYWxsYmFja3MgZm9yIExpdmVWaWV3IGhvb2tzLlxuICAgKlxuICAgKiBTZWUgW0NsaWVudCBob29rcyB2aWEgYHBoeC1ob29rYF0oaHR0cHM6Ly9oZXhkb2NzLnBtL3Bob2VuaXhfbGl2ZV92aWV3L2pzLWludGVyb3AuaHRtbCNjbGllbnQtaG9va3MtdmlhLXBoeC1ob29rKSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICovXG4gIGhvb2tzPzogSG9va3NPcHRpb25zO1xuICAvKiogQ2FsbGJhY2tzIGZvciBMaXZlVmlldyB1cGxvYWRlcnMuICovXG4gIHVwbG9hZGVycz86IHsgW2tleTogc3RyaW5nXTogYW55IH07IC8vIFRPRE86IGRlZmluZSBtb3JlIHNwZWNpZmljYWxseVxuICAvKiogRGVsYXkgaW4gbWlsbGlzZWNvbmRzIGJlZm9yZSBhcHBseWluZyBsb2FkaW5nIHN0YXRlcy4gKi9cbiAgbG9hZGVyVGltZW91dD86IG51bWJlcjtcbiAgLyoqIERlbGF5IGluIG1pbGxpc2Vjb25kcyBiZWZvcmUgZXhlY3V0aW5nIHBoeC1kaXNjb25uZWN0ZWQgY29tbWFuZHMuICovXG4gIGRpc2Nvbm5lY3RlZFRpbWVvdXQ/OiBudW1iZXI7XG4gIC8qKiBNYXhpbXVtIHJlbG9hZHMgYmVmb3JlIGVudGVyaW5nIGZhaWxzYWZlIG1vZGUuICovXG4gIG1heFJlbG9hZHM/OiBudW1iZXI7XG4gIC8qKiBNaW5pbXVtIHRpbWUgYmV0d2VlbiBub3JtYWwgcmVsb2FkIGF0dGVtcHRzLiAqL1xuICByZWxvYWRKaXR0ZXJNaW4/OiBudW1iZXI7XG4gIC8qKiBNYXhpbXVtIHRpbWUgYmV0d2VlbiBub3JtYWwgcmVsb2FkIGF0dGVtcHRzLiAqL1xuICByZWxvYWRKaXR0ZXJNYXg/OiBudW1iZXI7XG4gIC8qKiBUaW1lIGJldHdlZW4gcmVsb2FkIGF0dGVtcHRzIGluIGZhaWxzYWZlIG1vZGUuICovXG4gIGZhaWxzYWZlSml0dGVyPzogbnVtYmVyO1xuICAvKipcbiAgICogRnVuY3Rpb24gdG8gbG9nIGRlYnVnIGluZm9ybWF0aW9uLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogICAgICh2aWV3LCBraW5kLCBtc2csIG9iaikgPT4gY29uc29sZS5sb2coYCR7dmlldy5pZH0gJHtraW5kfTogJHttc2d9IC0gYCwgb2JqKVxuICAgKi9cbiAgdmlld0xvZ2dlcj86ICh2aWV3OiBWaWV3LCBraW5kOiBzdHJpbmcsIG1zZzogc3RyaW5nLCBvYmo6IGFueSkgPT4gdm9pZDtcbiAgLyoqXG4gICAqIE9iamVjdCBtYXBwaW5nIGV2ZW50IG5hbWVzIHRvIGZ1bmN0aW9ucyBmb3IgcG9wdWxhdGluZyBldmVudCBtZXRhZGF0YS5cbiAgICpcbiAgICogICAgIG1ldGFkYXRhOiB7XG4gICAqICAgICAgIGNsaWNrOiAoZSwgZWwpID0+IHtcbiAgICogICAgICAgICByZXR1cm4ge1xuICAgKiAgICAgICAgICAgY3RybEtleTogZS5jdHJsS2V5LFxuICAgKiAgICAgICAgICAgbWV0YUtleTogZS5tZXRhS2V5LFxuICAgKiAgICAgICAgICAgZGV0YWlsOiBlLmRldGFpbCB8fCAxLFxuICAgKiAgICAgICAgIH1cbiAgICogICAgICAgfSxcbiAgICogICAgICAga2V5ZG93bjogKGUsIGVsKSA9PiB7XG4gICAqICAgICAgICAgcmV0dXJuIHtcbiAgICogICAgICAgICAgIGtleTogZS5rZXksXG4gICAqICAgICAgICAgICBjdHJsS2V5OiBlLmN0cmxLZXksXG4gICAqICAgICAgICAgICBtZXRhS2V5OiBlLm1ldGFLZXksXG4gICAqICAgICAgICAgICBzaGlmdEtleTogZS5zaGlmdEtleVxuICAgKiAgICAgICAgIH1cbiAgICogICAgICAgfVxuICAgKiAgICAgfVxuICAgKlxuICAgKi9cbiAgbWV0YWRhdGE/OiB7IFtldmVudE5hbWU6IHN0cmluZ106IChlOiBFdmVudCwgZWw6IEhUTUxFbGVtZW50KSA9PiBvYmplY3QgfTtcbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIFN0b3JhZ2UgY29tcGF0aWJsZSBvYmplY3RcbiAgICogVXNlZnVsIHdoZW4gTGl2ZVZpZXcgd29uJ3QgaGF2ZSBhY2Nlc3MgdG8gYHNlc3Npb25TdG9yYWdlYC4gRm9yIGV4YW1wbGUsIFRoaXMgY291bGRcbiAgICogaGFwcGVuIGlmIGEgc2l0ZSBsb2FkcyBhIGNyb3NzLWRvbWFpbiBMaXZlVmlldyBpbiBhbiBpZnJhbWUuXG4gICAqXG4gICAqIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgICBjbGFzcyBJbk1lbW9yeVN0b3JhZ2Uge1xuICAgKiAgICAgICBjb25zdHJ1Y3RvcigpIHsgdGhpcy5zdG9yYWdlID0ge30gfVxuICAgKiAgICAgICBnZXRJdGVtKGtleU5hbWUpIHsgcmV0dXJuIHRoaXMuc3RvcmFnZVtrZXlOYW1lXSB8fCBudWxsIH1cbiAgICogICAgICAgcmVtb3ZlSXRlbShrZXlOYW1lKSB7IGRlbGV0ZSB0aGlzLnN0b3JhZ2Vba2V5TmFtZV0gfVxuICAgKiAgICAgICBzZXRJdGVtKGtleU5hbWUsIGtleVZhbHVlKSB7IHRoaXMuc3RvcmFnZVtrZXlOYW1lXSA9IGtleVZhbHVlIH1cbiAgICogICAgIH1cbiAgICovXG4gIHNlc3Npb25TdG9yYWdlPzogU3RvcmFnZTtcbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIFN0b3JhZ2UgY29tcGF0aWJsZSBvYmplY3RcbiAgICogVXNlZnVsIHdoZW4gTGl2ZVZpZXcgd29uJ3QgaGF2ZSBhY2Nlc3MgdG8gYGxvY2FsU3RvcmFnZWAuXG4gICAqXG4gICAqIFNlZSBgc2Vzc2lvblN0b3JhZ2VgIGZvciBhbiBleGFtcGxlLlxuICAgKi9cbiAgbG9jYWxTdG9yYWdlPzogU3RvcmFnZTtcbiAgLyoqXG4gICAqIElmIHNldCB0byBgdHJ1ZWAsIGBwaHgtY2hhbmdlYCBldmVudHMgd2lsbCBiZSBibG9ja2VkICh3aWxsIG5vdCBmaXJlKVxuICAgKiB3aGlsZSB0aGUgdXNlciBpcyBjb21wb3NpbmcgaW5wdXQgdXNpbmcgYW4gSU1FIChJbnB1dCBNZXRob2QgRWRpdG9yKS5cbiAgICogVGhpcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBgZS5pc0NvbXBvc2luZ2AgcHJvcGVydHkgb24ga2V5Ym9hcmQgZXZlbnRzLFxuICAgKiB3aGljaCBpcyBgdHJ1ZWAgd2hlbiB0aGUgdXNlciBpcyBpbiB0aGUgcHJvY2VzcyBvZiBlbnRlcmluZyBjb21wb3NlZCBjaGFyYWN0ZXJzIChmb3IgZXhhbXBsZSxcbiAgICogd2hlbiB0eXBpbmcgSmFwYW5lc2Ugb3IgQ2hpbmVzZSB1c2luZyByb21hamkgb3IgcGlueWluIGlucHV0IG1ldGhvZHMpLlxuICAgKiBCeSBkZWZhdWx0LCBgcGh4LWNoYW5nZWAgd2lsbCBub3QgYmUgYmxvY2tlZCBkdXJpbmcgYSBjb21wb3NpdGlvbiBzZXNzaW9uLFxuICAgKiBidXQgbm90ZSB0aGF0IHRoZXJlIHdlcmUgaXNzdWVzIHJlcG9ydGVkIGluIG9sZGVyIHZlcnNpb25zIG9mIFNhZmFyaSxcbiAgICogd2hlcmUgYSBMaXZlVmlldyBwYXRjaCB0byB0aGUgaW5wdXQgY2F1c2VkIHVuZXhwZWN0ZWQgYmVoYXZpb3IuXG4gICAqXG4gICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbiAgICogLSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9pc0NvbXBvc2luZ1xuICAgKiAtIGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXhfbGl2ZV92aWV3L2lzc3Vlcy8zMzIyXG4gICAqXG4gICAqIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAqL1xuICBibG9ja1BoeENoYW5nZVdoaWxlQ29tcG9zaW5nPzogYm9vbGVhbjtcbiAgLyoqIERPTSBjYWxsYmFja3MuICovXG4gIGRvbT86IHtcbiAgICAvKipcbiAgICAgKiBBbiBvcHRpb25hbCBmdW5jdGlvbiB0byBtb2RpZnkgdGhlIGJlaGF2aW9yIG9mIHF1ZXJ5aW5nIGVsZW1lbnRzIGluIEpTIGNvbW1hbmRzLlxuICAgICAqIEBwYXJhbSBzb3VyY2VFbCAtIFRoZSBzb3VyY2UgZWxlbWVudCwgZS5nLiB0aGUgYnV0dG9uIHRoYXQgd2FzIGNsaWNrZWQuXG4gICAgICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHZhbHVlLlxuICAgICAqIEBwYXJhbSBkZWZhdWx0UXVlcnkgLSBBIGRlZmF1bHQgcXVlcnkgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCBpZiBubyBjdXN0b20gcXVlcnkgc2hvdWxkIGJlIGFwcGxpZWQuXG4gICAgICogQHJldHVybnMgQSBsaXN0IG9mIERPTSBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBqc1F1ZXJ5U2VsZWN0b3JBbGw/OiAoXG4gICAgICBzb3VyY2VFbDogSFRNTEVsZW1lbnQsXG4gICAgICBxdWVyeTogc3RyaW5nLFxuICAgICAgZGVmYXVsdFF1ZXJ5OiAoKSA9PiBFbGVtZW50W10sXG4gICAgKSA9PiBFbGVtZW50W107XG4gICAgLyoqXG4gICAgICogV2hlbiBkZWZpbmVkLCBjYWxsZWQgd2l0aCBhIHN0YXJ0IGNhbGxiYWNrIHRoYXQgbmVlZHMgdG8gYmUgY2FsbGVkXG4gICAgICogdG8gcGVyZm9ybSB0aGUgYWN0dWFsIHBhdGNoLiBGYWlsaW5nIHRvIGNhbGwgdGhlIHN0YXJ0IGNhbGxiYWNrIGNhdXNlc1xuICAgICAqIHRoZSBwYWdlIHRvIGJlY29tZSBzdHVjay5cbiAgICAgKlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gZGVsYXkgcGF0Y2hlcyBpbiBvcmRlciB0byBwZXJmb3JtIHZpZXcgdHJhbnNpdGlvbnMsXG4gICAgICogZm9yIGV4YW1wbGU6XG4gICAgICpcbiAgICAgKiBgYGBqYXZhc2NyaXB0XG4gICAgICogbGV0IGxpdmVTb2NrZXQgPSBuZXcgTGl2ZVNvY2tldChcIi9saXZlXCIsIFNvY2tldCwge1xuICAgICAqICAgZG9tOiB7XG4gICAgICogICAgIG9uRG9jdW1lbnRQYXRjaChzdGFydCkge1xuICAgICAqICAgICAgIGRvY3VtZW50LnN0YXJ0Vmlld1RyYW5zaXRpb24oc3RhcnQpO1xuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICogfSlcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEl0IGlzIHN0cm9uZ2x5IGFkdmlzZWQgdG8gY2FsbCBzdGFydCBhcyBxdWlja2x5IGFzIHBvc3NpYmxlLlxuICAgICAqL1xuICAgIG9uRG9jdW1lbnRQYXRjaD86IChzdGFydDogKCkgPT4gdm9pZCkgPT4gdm9pZDtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgaW1tZWRpYXRlbHkgYmVmb3JlIGEgRE9NIHBhdGNoIGlzIGFwcGxpZWQuXG4gICAgICovXG4gICAgb25QYXRjaFN0YXJ0PzogKGNvbnRhaW5lcjogSFRNTEVsZW1lbnQpID0+IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIGEgRE9NIHBhdGNoIGlzIGFwcGxpZWQuXG4gICAgICovXG4gICAgb25QYXRjaEVuZD86IChjb250YWluZXI6IEhUTUxFbGVtZW50KSA9PiB2b2lkO1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGEgbmV3IERPTSBub2RlIGlzIGFkZGVkLlxuICAgICAqL1xuICAgIG9uTm9kZUFkZGVkPzogKG5vZGU6IE5vZGUpID0+IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGJlZm9yZSBhbiBlbGVtZW50IGlzIHVwZGF0ZWQuXG4gICAgICovXG4gICAgb25CZWZvcmVFbFVwZGF0ZWQ/OiAoZnJvbUVsOiBFbGVtZW50LCB0b0VsOiBFbGVtZW50KSA9PiB2b2lkO1xuICB9O1xuICAvKiogQWxsb3cgcGFzc3Rocm91Z2ggb2Ygb3RoZXIgb3B0aW9ucyB0byB0aGUgUGhvZW5peCBTb2NrZXQgY29uc3RydWN0b3IuICovXG4gIFtrZXk6IHN0cmluZ106IGFueTtcbn1cblxuLyoqXG4gKiBJbnRlcmZhY2UgZGVzY3JpYmluZyB0aGUgcHVibGljIEFQSSBvZiBhIExpdmVTb2NrZXQgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTGl2ZVNvY2tldEluc3RhbmNlSW50ZXJmYWNlIHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZlcnNpb24gb2YgdGhlIExpdmVWaWV3IGNsaWVudC5cbiAgICovXG4gIHZlcnNpb24oKTogc3RyaW5nO1xuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHByb2ZpbGluZyBpcyBlbmFibGVkLiBTZWUgYGVuYWJsZVByb2ZpbGluZ2AgYW5kIGBkaXNhYmxlUHJvZmlsaW5nYC5cbiAgICovXG4gIGlzUHJvZmlsZUVuYWJsZWQoKTogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBkZWJ1Z2dpbmcgaXMgZW5hYmxlZC4gU2VlIGBlbmFibGVEZWJ1Z2AgYW5kIGBkaXNhYmxlRGVidWdgLlxuICAgKi9cbiAgaXNEZWJ1Z0VuYWJsZWQoKTogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBkZWJ1Z2dpbmcgaXMgZGlzYWJsZWQuIFNlZSBgZW5hYmxlRGVidWdgIGFuZCBgZGlzYWJsZURlYnVnYC5cbiAgICovXG4gIGlzRGVidWdEaXNhYmxlZCgpOiBib29sZWFuO1xuICAvKipcbiAgICogRW5hYmxlcyBkZWJ1Z2dpbmcuXG4gICAqXG4gICAqIFdoZW4gZGVidWdnaW5nIGlzIGVuYWJsZWQsIHRoZSBMaXZlVmlldyBjbGllbnQgd2lsbCBsb2cgZGVidWcgaW5mb3JtYXRpb24gdG8gdGhlIGNvbnNvbGUuXG4gICAqIFNlZSBbRGVidWdnaW5nIGNsaWVudCBldmVudHNdKGh0dHBzOi8vaGV4ZG9jcy5wbS9waG9lbml4X2xpdmVfdmlldy9qcy1pbnRlcm9wLmh0bWwjZGVidWdnaW5nLWNsaWVudC1ldmVudHMpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgZW5hYmxlRGVidWcoKTogdm9pZDtcbiAgLyoqXG4gICAqIEVuYWJsZXMgcHJvZmlsaW5nLlxuICAgKlxuICAgKiBXaGVuIHByb2ZpbGluZyBpcyBlbmFibGVkLCB0aGUgTGl2ZVZpZXcgY2xpZW50IHdpbGwgbG9nIHByb2ZpbGluZyBpbmZvcm1hdGlvbiB0byB0aGUgY29uc29sZS5cbiAgICovXG4gIGVuYWJsZVByb2ZpbGluZygpOiB2b2lkO1xuICAvKipcbiAgICogRGlzYWJsZXMgZGVidWdnaW5nLlxuICAgKi9cbiAgZGlzYWJsZURlYnVnKCk6IHZvaWQ7XG4gIC8qKlxuICAgKiBEaXNhYmxlcyBwcm9maWxpbmcuXG4gICAqL1xuICBkaXNhYmxlUHJvZmlsaW5nKCk6IHZvaWQ7XG4gIC8qKlxuICAgKiBFbmFibGVzIGxhdGVuY3kgc2ltdWxhdGlvbi5cbiAgICpcbiAgICogV2hlbiBsYXRlbmN5IHNpbXVsYXRpb24gaXMgZW5hYmxlZCwgdGhlIExpdmVWaWV3IGNsaWVudCB3aWxsIGFkZCBhIGRlbGF5IHRvIHJlcXVlc3RzIGFuZCByZXNwb25zZXMgZnJvbSB0aGUgc2VydmVyLlxuICAgKiBTZWUgW1NpbXVsYXRpbmcgTGF0ZW5jeV0oaHR0cHM6Ly9oZXhkb2NzLnBtL3Bob2VuaXhfbGl2ZV92aWV3L2pzLWludGVyb3AuaHRtbCNzaW11bGF0aW5nLWxhdGVuY3kpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgZW5hYmxlTGF0ZW5jeVNpbSh1cHBlckJvdW5kTXM6IG51bWJlcik6IHZvaWQ7XG4gIC8qKlxuICAgKiBEaXNhYmxlcyBsYXRlbmN5IHNpbXVsYXRpb24uXG4gICAqL1xuICBkaXNhYmxlTGF0ZW5jeVNpbSgpOiB2b2lkO1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBsYXRlbmN5IHNpbXVsYXRpb24gdXBwZXIgYm91bmQuXG4gICAqL1xuICBnZXRMYXRlbmN5U2ltKCk6IG51bWJlciB8IG51bGw7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBQaG9lbml4IFNvY2tldCBpbnN0YW5jZS5cbiAgICovXG4gIGdldFNvY2tldCgpOiBQaG9lbml4U29ja2V0O1xuICAvKipcbiAgICogQ29ubmVjdHMgdG8gdGhlIExpdmVWaWV3IHNlcnZlci5cbiAgICovXG4gIGNvbm5lY3QoKTogdm9pZDtcbiAgLyoqXG4gICAqIERpc2Nvbm5lY3RzIGZyb20gdGhlIExpdmVWaWV3IHNlcnZlci5cbiAgICovXG4gIGRpc2Nvbm5lY3QoY2FsbGJhY2s/OiAoKSA9PiB2b2lkKTogdm9pZDtcbiAgLyoqXG4gICAqIENhbiBiZSB1c2VkIHRvIHJlcGxhY2UgdGhlIHRyYW5zcG9ydCB1c2VkIGJ5IHRoZSB1bmRlcmx5aW5nIFBob2VuaXggU29ja2V0LlxuICAgKi9cbiAgcmVwbGFjZVRyYW5zcG9ydCh0cmFuc3BvcnQ6IGFueSk6IHZvaWQ7XG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhbiBlbmNvZGVkIEpTIGNvbW1hbmQsIHRhcmdldGluZyB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICpcbiAgICogU2VlIFtgUGhvZW5peC5MaXZlVmlldy5KU2BdKGh0dHBzOi8vaGV4ZG9jcy5wbS9waG9lbml4X2xpdmVfdmlldy9QaG9lbml4LkxpdmVWaWV3LkpTLmh0bWwpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgZXhlY0pTKGVsOiBIVE1MRWxlbWVudCwgZW5jb2RlZEpTOiBzdHJpbmcsIGV2ZW50VHlwZT86IHN0cmluZyB8IG51bGwpOiB2b2lkO1xuICAvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBtZXRob2RzIHRvIG1hbmlwdWxhdGUgdGhlIERPTSBhbmQgZXhlY3V0ZSBKYXZhU2NyaXB0LlxuICAgKiBUaGUgYXBwbGllZCBjaGFuZ2VzIGludGVncmF0ZSB3aXRoIHNlcnZlciBET00gcGF0Y2hpbmcuXG4gICAqXG4gICAqIFNlZSBbSmF2YVNjcmlwdCBpbnRlcm9wZXJhYmlsaXR5XShodHRwczovL2hleGRvY3MucG0vcGhvZW5peF9saXZlX3ZpZXcvanMtaW50ZXJvcC5odG1sKSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICovXG4gIGpzKCk6IExpdmVTb2NrZXRKU0NvbW1hbmRzO1xufVxuXG4vKipcbiAqIEludGVyZmFjZSBkZXNjcmliaW5nIHRoZSBMaXZlU29ja2V0IGNvbnN0cnVjdG9yLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIExpdmVTb2NrZXRDb25zdHJ1Y3RvciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IExpdmVTb2NrZXQgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSBlbmRwb2ludCAtIFRoZSBzdHJpbmcgV2ViU29ja2V0IGVuZHBvaW50LCBpZSwgYFwid3NzOi8vZXhhbXBsZS5jb20vbGl2ZVwiYCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcIi9saXZlXCJgIChpbmhlcml0ZWQgaG9zdCAmIHByb3RvY29sKVxuICAgKiBAcGFyYW0gc29ja2V0IC0gdGhlIHJlcXVpcmVkIFBob2VuaXggU29ja2V0IGNsYXNzIGltcG9ydGVkIGZyb20gXCJwaG9lbml4XCIuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgICAgaW1wb3J0IHtTb2NrZXR9IGZyb20gXCJwaG9lbml4XCJcbiAgICogICAgIGltcG9ydCB7TGl2ZVNvY2tldH0gZnJvbSBcInBob2VuaXhfbGl2ZV92aWV3XCJcbiAgICogICAgIGxldCBsaXZlU29ja2V0ID0gbmV3IExpdmVTb2NrZXQoXCIvbGl2ZVwiLCBTb2NrZXQsIHsuLi59KVxuICAgKlxuICAgKiBAcGFyYW0gb3B0cyAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24uXG4gICAqL1xuICBuZXcgKFxuICAgIGVuZHBvaW50OiBzdHJpbmcsXG4gICAgc29ja2V0OiB0eXBlb2YgUGhvZW5peFNvY2tldCxcbiAgICBvcHRzPzogTGl2ZVNvY2tldE9wdGlvbnMsXG4gICk6IExpdmVTb2NrZXRJbnN0YW5jZUludGVyZmFjZTtcbn1cblxuLy8gYmVjYXVzZSBMaXZlU29ja2V0IGlzIGluIEpTIChmb3Igbm93KSwgd2UgY2FzdCBpdCB0byBvdXIgZGVmaW5lZCBUeXBlU2NyaXB0IGNvbnN0cnVjdG9yLlxuY29uc3QgTGl2ZVNvY2tldCA9IE9yaWdpbmFsTGl2ZVNvY2tldCBhcyB1bmtub3duIGFzIExpdmVTb2NrZXRDb25zdHJ1Y3RvcjtcblxuLyoqIENyZWF0ZXMgYSBob29rIGluc3RhbmNlIGZvciB0aGUgZ2l2ZW4gZWxlbWVudCBhbmQgY2FsbGJhY2tzLlxuICpcbiAqIEBwYXJhbSBlbCAtIFRoZSBlbGVtZW50IHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBob29rLlxuICogQHBhcmFtIGNhbGxiYWNrcyAtIFRoZSBsaXN0IG9mIGhvb2sgY2FsbGJhY2tzLCBzdWNoIGFzIG1vdW50ZWQsXG4gKiAgIHVwZGF0ZWQsIGRlc3Ryb3llZCwgZXRjLlxuICpcbiAqICpOb3RlKjogYGNyZWF0ZUhvb2tgIG11c3QgYmUgY2FsbGVkIGZyb20gdGhlIGBjb25uZWN0ZWRDYWxsYmFja2AgbGlmZWN5Y2xlXG4gKiB3aGljaCBpcyB0cmlnZ2VyZWQgYWZ0ZXIgdGhlIGVsZW1lbnQgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIERPTS4gSWYgeW91IHRyeVxuICogdG8gY2FsbCBgY3JlYXRlSG9va2AgZnJvbSB0aGUgY29uc3RydWN0b3IsIGFuIGVycm9yIHdpbGwgYmUgbG9nZ2VkLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogY2xhc3MgTXlDb21wb25lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gKiAgIGNvbm5lY3RlZENhbGxiYWNrKCl7XG4gKiAgICAgbGV0IG9uTGl2ZVZpZXdNb3VudGVkID0gKCkgPT4gdGhpcy5ob29rLnB1c2hFdmVudCguLi4pKVxuICogICAgIHRoaXMuaG9vayA9IGNyZWF0ZUhvb2sodGhpcywge21vdW50ZWQ6IG9uTGl2ZVZpZXdNb3VudGVkfSlcbiAqICAgfVxuICogfVxuICpcbiAqIEByZXR1cm5zIFJldHVybnMgdGhlIEhvb2sgaW5zdGFuY2UgZm9yIHRoZSBjdXN0b20gZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSG9vayhlbDogSFRNTEVsZW1lbnQsIGNhbGxiYWNrczogSG9vayk6IFZpZXdIb29rIHtcbiAgbGV0IGV4aXN0aW5nSG9vayA9IERPTS5nZXRDdXN0b21FbEhvb2soZWwpO1xuICBpZiAoZXhpc3RpbmdIb29rKSB7XG4gICAgcmV0dXJuIGV4aXN0aW5nSG9vaztcbiAgfVxuXG4gIGlmICghZWwuaGFzQXR0cmlidXRlKFwiaWRcIikpIHtcbiAgICBsb2dFcnJvcihcbiAgICAgIFwiRWxlbWVudHMgcGFzc2VkIHRvIGNyZWF0ZUhvb2sgbmVlZCB0byBoYXZlIGEgdW5pcXVlIGlkIGF0dHJpYnV0ZVwiLFxuICAgICAgZWwsXG4gICAgKTtcbiAgfVxuXG4gIGxldCBob29rID0gbmV3IFZpZXdIb29rKFZpZXcuY2xvc2VzdFZpZXcoZWwpLCBlbCwgY2FsbGJhY2tzKTtcbiAgRE9NLnB1dEN1c3RvbUVsSG9vayhlbCwgaG9vayk7XG4gIHJldHVybiBob29rO1xufVxuXG5leHBvcnQgeyBMaXZlU29ja2V0LCBpc1VzZWRJbnB1dCwgY3JlYXRlSG9vaywgVmlld0hvb2ssIEhvb2ssIEhvb2tzT3B0aW9ucyB9O1xuIiwgIi8qKlxyXG4gKiBVcGRhdGVkIGJ5IFRha2F5dWtpIEthbWl5YW1hIG9uIDIwMjYvMDEvMDIuXHJcbiAqIFRlYW0gJ1JlZCBFeWVzLCBCbGFjayBEcmFnb24uJ1xyXG4gKi9cclxuXHJcbiQoZnVuY3Rpb24gKCkge1xyXG4gICAgJCgnYVtocmVmXj0jXScpLmNsaWNrKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBzcGVlZCA9IDQwMDsgLy8gbWlsbGlzZWNvbmRcclxuICAgICAgICBsZXQgaHJlZiA9ICQodGhpcykuYXR0cihcImhyZWZcIik7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gJChocmVmID09PSBcIiNcIiB8fCBocmVmID09PSBcIlwiID8gJ2h0bWwnIDogaHJlZik7XHJcbiAgICAgICAgJCgkLmJyb3dzZXIuc2FmYXJpID8gJ2JvZHknIDogJ2h0bWwnKS5hbmltYXRlKHtcclxuICAgICAgICAgICAgc2Nyb2xsVG9wOiBwb3NpdGlvblxyXG4gICAgICAgIH0sIHNwZWVkLCAnc3dpbmcnKTtcclxuICAgICAgICBsZXQgYm9keSA9ICdib2R5JztcclxuICAgICAgICBjb25zdCB1c2VyQWdlbnQgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGlmICh1c2VyQWdlbnQuaW5kZXhPZignbXNpZScpID4gLTEgfHwgdXNlckFnZW50LmluZGV4T2YoJ3RyaWRlbnQnKSA+IC0xIHx8IHVzZXJBZ2VudC5pbmRleE9mKFwiZmlyZWZveFwiKSA+IC0xKSB7XHJcbiAgICAgICAgICAgIGJvZHkgPSAnaHRtbCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICQoYm9keSkuYW5pbWF0ZSh7XHJcbiAgICAgICAgICAgIHNjcm9sbFRvcDogcG9zaXRpb25cclxuICAgICAgICB9LCBzcGVlZCwgJ3N3aW5nJyk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSk7XHJcbn0pOyIsICIvLyBJZiB5b3Ugd2FudCB0byB1c2UgUGhvZW5peCBjaGFubmVscywgcnVuIGBtaXggaGVscCBwaHguZ2VuLmNoYW5uZWxgXHJcbi8vIHRvIGdldCBzdGFydGVkIGFuZCB0aGVuIHVuY29tbWVudCB0aGUgbGluZSBiZWxvdy5cclxuLy8gaW1wb3J0IFwiLi91c2VyX3NvY2tldC5qc1wiXHJcblxyXG4vLyBZb3UgY2FuIGluY2x1ZGUgZGVwZW5kZW5jaWVzIGluIHR3byB3YXlzLlxyXG4vL1xyXG4vLyBUaGUgc2ltcGxlc3Qgb3B0aW9uIGlzIHRvIHB1dCB0aGVtIGluIGFzc2V0cy92ZW5kb3IgYW5kXHJcbi8vIGltcG9ydCB0aGVtIHVzaW5nIHJlbGF0aXZlIHBhdGhzOlxyXG4vL1xyXG4vLyAgICAgaW1wb3J0IFwiLi4vdmVuZG9yL3NvbWUtcGFja2FnZS5qc1wiXHJcbi8vXHJcbi8vIEFsdGVybmF0aXZlbHksIHlvdSBjYW4gYG5wbSBpbnN0YWxsIHNvbWUtcGFja2FnZSAtLXByZWZpeCBhc3NldHNgIGFuZCBpbXBvcnRcclxuLy8gdGhlbSB1c2luZyBhIHBhdGggc3RhcnRpbmcgd2l0aCB0aGUgcGFja2FnZSBuYW1lOlxyXG4vL1xyXG4vLyAgICAgaW1wb3J0IFwic29tZS1wYWNrYWdlXCJcclxuLy9cclxuLy8gSWYgeW91IGhhdmUgZGVwZW5kZW5jaWVzIHRoYXQgdHJ5IHRvIGltcG9ydCBDU1MsIGVzYnVpbGQgd2lsbCBnZW5lcmF0ZSBhIHNlcGFyYXRlIGBhcHAuY3NzYCBmaWxlLlxyXG4vLyBUbyBsb2FkIGl0LCBzaW1wbHkgYWRkIGEgc2Vjb25kIGA8bGluaz5gIHRvIHlvdXIgYHJvb3QuaHRtbC5oZWV4YCBmaWxlLlxyXG5cclxuLy8gSW5jbHVkZSBwaG9lbml4X2h0bWwgdG8gaGFuZGxlIG1ldGhvZD1QVVQvREVMRVRFIGluIGZvcm1zIGFuZCBidXR0b25zLlxyXG5pbXBvcnQgXCJwaG9lbml4X2h0bWxcIlxyXG4vLyBFc3RhYmxpc2ggUGhvZW5peCBTb2NrZXQgYW5kIExpdmVWaWV3IGNvbmZpZ3VyYXRpb24uXHJcbmltcG9ydCB7U29ja2V0fSBmcm9tIFwicGhvZW5peFwiXHJcbmltcG9ydCB7TGl2ZVNvY2tldH0gZnJvbSBcInBob2VuaXhfbGl2ZV92aWV3XCJcclxuLy8gaW1wb3J0IHtob29rcyBhcyBjb2xvY2F0ZWRIb29rc30gZnJvbSBcInBob2VuaXgtY29sb2NhdGVkL2RhcmtrbmlnaHRcIlxyXG5pbXBvcnQgJy4vY2Fpcm8uanMnXHJcblxyXG5jb25zdCBjc3JmVG9rZW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwibWV0YVtuYW1lPSdjc3JmLXRva2VuJ11cIikuZ2V0QXR0cmlidXRlKFwiY29udGVudFwiKVxyXG5jb25zdCBsaXZlU29ja2V0ID0gbmV3IExpdmVTb2NrZXQoXCIvbGl2ZVwiLCBTb2NrZXQsIHtcclxuICAgIGxvbmdQb2xsRmFsbGJhY2tNczogMjUwMCxcclxuICAgIHBhcmFtczoge19jc3JmX3Rva2VuOiBjc3JmVG9rZW59LFxyXG4gICAgaG9va3M6IHsuLi5jb2xvY2F0ZWRIb29rc30sXHJcbn0pXHJcblxyXG4vLyBTaG93IHByb2dyZXNzIGJhciBvbiBsaXZlIG5hdmlnYXRpb24gYW5kIGZvcm0gc3VibWl0c1xyXG50b3BiYXIuY29uZmlnKHtiYXJDb2xvcnM6IHswOiBcIiMyOWRcIn0sIHNoYWRvd0NvbG9yOiBcInJnYmEoMCwgMCwgMCwgLjMpXCJ9KVxyXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBoeDpwYWdlLWxvYWRpbmctc3RhcnRcIiwgX2luZm8gPT4gdG9wYmFyLnNob3coMzAwKSlcclxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwaHg6cGFnZS1sb2FkaW5nLXN0b3BcIiwgX2luZm8gPT4gdG9wYmFyLmhpZGUoKSlcclxuXHJcbi8vIGNvbm5lY3QgaWYgdGhlcmUgYXJlIGFueSBMaXZlVmlld3Mgb24gdGhlIHBhZ2VcclxubGl2ZVNvY2tldC5jb25uZWN0KClcclxuXHJcbi8vIGV4cG9zZSBsaXZlU29ja2V0IG9uIHdpbmRvdyBmb3Igd2ViIGNvbnNvbGUgZGVidWcgbG9ncyBhbmQgbGF0ZW5jeSBzaW11bGF0aW9uOlxyXG4vLyA+PiBsaXZlU29ja2V0LmVuYWJsZURlYnVnKClcclxuLy8gPj4gbGl2ZVNvY2tldC5lbmFibGVMYXRlbmN5U2ltKDEwMDApICAvLyBlbmFibGVkIGZvciBkdXJhdGlvbiBvZiBicm93c2VyIHNlc3Npb25cclxuLy8gPj4gbGl2ZVNvY2tldC5kaXNhYmxlTGF0ZW5jeVNpbSgpXHJcbndpbmRvdy5saXZlU29ja2V0ID0gbGl2ZVNvY2tldFxyXG5cclxuLy8gVGhlIGxpbmVzIGJlbG93IGVuYWJsZSBxdWFsaXR5IG9mIGxpZmUgcGhvZW5peF9saXZlX3JlbG9hZFxyXG4vLyBkZXZlbG9wbWVudCBmZWF0dXJlczpcclxuLy9cclxuLy8gICAgIDEuIHN0cmVhbSBzZXJ2ZXIgbG9ncyB0byB0aGUgYnJvd3NlciBjb25zb2xlXHJcbi8vICAgICAyLiBjbGljayBvbiBlbGVtZW50cyB0byBqdW1wIHRvIHRoZWlyIGRlZmluaXRpb25zIGluIHlvdXIgY29kZSBlZGl0b3JcclxuLy9cclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGh4OmxpdmVfcmVsb2FkOmF0dGFjaGVkXCIsICh7ZGV0YWlsOiByZWxvYWRlcn0pID0+IHtcclxuICAgICAgICAvLyBFbmFibGUgc2VydmVyIGxvZyBzdHJlYW1pbmcgdG8gY2xpZW50LlxyXG4gICAgICAgIC8vIERpc2FibGUgd2l0aCByZWxvYWRlci5kaXNhYmxlU2VydmVyTG9ncygpXHJcbiAgICAgICAgcmVsb2FkZXIuZW5hYmxlU2VydmVyTG9ncygpXHJcblxyXG4gICAgICAgIC8vIE9wZW4gY29uZmlndXJlZCBQTFVHX0VESVRPUiBhdCBmaWxlOmxpbmUgb2YgdGhlIGNsaWNrZWQgZWxlbWVudCdzIEhFRXggY29tcG9uZW50XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICogY2xpY2sgd2l0aCBcImNcIiBrZXkgcHJlc3NlZCB0byBvcGVuIGF0IGNhbGxlciBsb2NhdGlvblxyXG4gICAgICAgIC8vICAgKiBjbGljayB3aXRoIFwiZFwiIGtleSBwcmVzc2VkIHRvIG9wZW4gYXQgZnVuY3Rpb24gY29tcG9uZW50IGRlZmluaXRpb24gbG9jYXRpb25cclxuICAgICAgICBsZXQga2V5RG93blxyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBlID0+IGtleURvd24gPSBlLmtleSlcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIF9lID0+IGtleURvd24gPSBudWxsKVxyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChrZXlEb3duID09PSBcImNcIikge1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXHJcbiAgICAgICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpXHJcbiAgICAgICAgICAgICAgICByZWxvYWRlci5vcGVuRWRpdG9yQXRDYWxsZXIoZS50YXJnZXQpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5RG93biA9PT0gXCJkXCIpIHtcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxyXG4gICAgICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKVxyXG4gICAgICAgICAgICAgICAgcmVsb2FkZXIub3BlbkVkaXRvckF0RGVmKGUudGFyZ2V0KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgdHJ1ZSlcclxuXHJcbiAgICAgICAgd2luZG93LmxpdmVSZWxvYWRlciA9IHJlbG9hZGVyXHJcbiAgICB9KVxyXG59XHJcblxyXG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUEscURBQUMsV0FBVztBQUNWLDBEQUFJLGdCQUFnQixpQkFBaUI7QUFFckMsK0RBQVMsbUJBQW1CO0FBQzFCLDREQUFJLE9BQU8sT0FBTyxnQkFBZ0IsV0FBWSxRQUFPLE9BQU87QUFFNUQsaUVBQVNBLGFBQVksT0FBTyxRQUFRO0FBQ2xDLG1FQUFTLFVBQVUsRUFBQyxTQUFTLE9BQU8sWUFBWSxPQUFPLFFBQVEsT0FBUztBQUN4RSw4REFBSSxNQUFNLFNBQVMsWUFBWSxhQUFhO0FBQzVDLDhEQUFJLGdCQUFnQixPQUFPLE9BQU8sU0FBUyxPQUFPLFlBQVksT0FBTyxNQUFNO0FBQzNFLGlFQUFPO3dEQUNUO0FBQ0FBLHFFQUFZLFlBQVksT0FBTyxNQUFNO0FBQ3JDLCtEQUFPQTtzREFDVDtBQUVBLCtEQUFTLGlCQUFpQixNQUFNLE9BQU87QUFDckMsNERBQUksUUFBUSxTQUFTLGNBQWMsT0FBTztBQUMxQyw4REFBTSxPQUFPO0FBQ2IsOERBQU0sT0FBTztBQUNiLDhEQUFNLFFBQVE7QUFDZCwrREFBTztzREFDVDtBQUVBLCtEQUFTLFlBQVksU0FBUyxtQkFBbUI7QUFDL0MsNERBQUksS0FBSyxRQUFRLGFBQWEsU0FBUyxHQUNuQyxTQUFTLGlC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QkFBb0I7c0RBQ3BCLFFBQVEsRUFBQyxhQUFhLFVBQVM7c0RBQy9CLE9BQU8sRUFBQyxHQUFHLGVBQWM7b0RBQzdCLENBQUM7QUFHRCwyREFBTyxPQUFPLEVBQUMsV0FBVyxFQUFDLEdBQUcsT0FBTSxHQUFHLGFBQWEsb0JBQW1CLENBQUM7QUFDeEUsMkRBQU8saUJBQWlCLDBCQUEwQixDQUFBLFVBQVMsT0FBTyxLQUFLLEdBQUcsQ0FBQztBQUMzRSwyREFBTyxpQkFBaUIseUJBQXlCLENBQUEsVUFBUyxPQUFPLEtBQUssQ0FBQztBQUd2RSwrREFBVyxRQUFRO0FBTW5CLDJEQUFPLGFBQWE7QUFRcEIsd0RBQUksTUFBd0M7QUFDeEMsNkRBQU8saUJBQWlCLDRCQUE0QixDQUFDLEVBQUMsUUFBUSxTQUFRLE1BQU07QUFHeEUsaUVBQVMsaUJBQWlCO0FBTTFCLDREQUFJO0FBQ0osK0RBQU8saUJBQWlCLFdBQVcsQ0FBQSxNQUFLLFVBQVUsRUFBRSxHQUFHO0FBQ3ZELCtEQUFPLGlCQUFpQixTQUFTLENBQUEsT0FBTSxVQUFVLElBQUk7QUFDckQsK0RBQU8saUJBQWlCLFNBQVMsQ0FBQSxNQUFLO0FBQ2xDLDhEQUFJLFlBQVksS0FBSztBQUNqQiw4REFBRSxlQUFlO0FBQ2pCLDhEQUFFLHlCQUF5QjtBQUMzQixxRUFBUyxtQkFBbUIsRUFBRSxNQUFNOzBEQUN4QyxXQUFXLFlBQVksS0FBSztBQUN4Qiw4REFBRSxlQUFlO0FBQ2pCLDhEQUFFLHlCQUF5QjtBQUMzQixxRUFBUyxnQkFBZ0IsRUFBRSxNQUFNOzBEQUNyQzt3REFDSixHQUFHLElBQUk7QUFFUCwrREFBTyxlQUFlO3NEQUMxQixDQUFDO29EQUNMOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsiLAogICJuYW1lcyI6IFsiQ3VzdG9tRXZlbnQiLCAiY2xvc3VyZSIsICJsaXZlU29ja2V0IiwgImRvYyIsICJpc0VtcHR5IiwgImZpbGUiLCAibW9ycGhBdHRycyIsICJtb3JwaGRvbSIsICJjaGlsZHJlbk9ubHkiLCAidGFyZ2V0Q29udGFpbmVyIiwgImNsb25lIiwgImVsIiwgImlucHV0c1VudXNlZCIsICJvbmx5SGlkZGVuSW5wdXRzIiwgImxvY2siLCAibG9hZGluZyIsICJlbnRyeSIsICJpbnB1dCIsICJwb3NpdGlvbiIsICJMaXZlU29ja2V0Il0KfQo=
